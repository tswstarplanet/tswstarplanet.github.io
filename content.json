[{"title":"","date":"2018-08-20T13:44:31.000Z","path":"2018/08/20/dubbo同步调用的实现机制/","text":"title: Dubbo同步调用在消费者端的实现机制date: 2018-8-20—\b Dubbo的同步调用\b使用Dubbo很长时间了，基本使用的都是Dubbo的同步调用方式。Dubbo默认使用的是协议格式Dubbo协议，序列化方式是Hessian\b，传输层使用的是Tcp协议，默认使用netty框架。\b Dubbo的同步调用是指，调用一个远程服务时，发起调用这个线程会一直阻塞（至少从\b使用者的感觉来说是这样的）到远程\b服务返回结果，或是超时为止。 那么Dubbo是如何实现这种同步调用机制的呢？我们知道RPC的本质是用TCP协议向另一个进程（可能在同一台机器上，也可能不在）发送请求，服务端进程接收到请求后，将请求解析为对本地方法的一个调用，调用之后将结果返回给客户端。客户端\b接收到返回之后，再将结果反序列化为需要的结果，返回给上层的业务。 Dubbo同步调用在客户端的实现Dubbo的整个调用流程是：1.服务提供者导出服务到本机的IP和端口上，即是建立一个TCP服务器；2.\b服务提供者发布服务到注册中心；3.服务消费者\b向注册中心订阅服务提供者的信息；4.服务消费者建立\b远程服务的代理，并建立一个TCP客户端。 以上几步分别是服务提供者和服务消费者启动时做的事情，这之后消费者和提供者之间就建立了TCP长连接，实际调用服务时是无需经过注册中心的，直接通过TCP连接完成。 下面就来看一下消费者是\b如何发起到提供者的请求，以及如何实现对上层业务而言的同步调用，以及超时机制等。 Dubbo\b消费者在发起调用之后，经过重重阻隔，经历了各种包装的代理类之后（暂时忽略集群容错和负载均衡等），最终会到达下面这个类： 123456public class DubboInvoker&lt;T&gt; extends AbstractInvoker&lt;T&gt; &#123; // 省略\b大量代码 @Override protected Result doInvoke(final Invocation invocation) throws Throwable &#123; //省略大量代码 return (Result) currentClient.request(inv, timeout).get(); \b最后这个return语句返回的就是最终调用返回的结果。再进入\b这个\brequest方法： 123456789101112131415161718192021final class HeaderExchangeChannel implements ExchangeChannel &#123; // 省略大量代码 @Override public ResponseFuture request(Object request, int timeout) throws RemotingException &#123; if (closed) &#123; throw new RemotingException(this.getLocalAddress(), null, \"Failed to send request \" + request + \", cause: The channel \" + this + \" is closed!\"); &#125; // create request. Request req = new Request(); req.setVersion(Version.getProtocolVersion()); req.setTwoWay(true); req.setData(request); DefaultFuture future = new DefaultFuture(channel, req, timeout); try &#123; channel.send(req); &#125; catch (RemotingException e) &#123; future.cancel(); throw e; &#125; return future; &#125; 我们看到，在这个方法中，先是创建了发送给提供者服务的请求request，之后创建了一个DefaultFuture的类。最好就调用channel将请求发送出去（此处的channel是dubbo定义的一个类的实例，但内部包装了netty的channel）。 我们看到，调用channel的send方法发送请求，但这个方法并没有返回值。而是在下方直接返回了这个DefaultFuture类的实例。 再回到上面DubboInvoke中，在\brequest返回了DefaultFuture实例之后，就调用get方法去获取调用结果。\b因此再看get方法： 12345678910111213141516171819202122232425262728293031@Override public Object get() throws RemotingException &#123; return get(timeout); &#125; @Override public Object get(int timeout) throws RemotingException &#123; if (timeout &lt;= 0) &#123; timeout = Constants.DEFAULT_TIMEOUT; &#125; if (!isDone()) &#123; long start = System.currentTimeMillis(); lock.lock(); try &#123; while (!isDone()) &#123; done.await(timeout, TimeUnit.MILLISECONDS); if (isDone() || System.currentTimeMillis() - start &gt; timeout) &#123; break; &#125; &#125; &#125; catch (InterruptedException e) &#123; throw new RuntimeException(e); &#125; finally &#123; lock.unlock(); &#125; if (!isDone()) &#123; throw new TimeoutException(sent &gt; 0, channel, getTimeoutMessage(false)); &#125; &#125; return returnFromResponse(); &#125; 到这个方法中就清除了，首先判断一下调用是否有返回结果，如果还没有返回，就先记录一下当前时间，之后\b用一个可重入锁将代码块加锁。\b之后在一个\bwhile循环条件中判断调用是否有返回。若没有返回就直接将线程进入等待状态，只有另一个线程向它发信号，才能唤醒它继续执行。唤醒之后，再次判断是否有返回，或是已经超时，则跳出循环。\b之后判断若没有返回，则已经超时。若有返回结果，则正常返回结果。 那么哪里有一个线程会来唤醒这个调用线程呢？ 答案就是netty提供的机制，netty客户端在发送请求给服务端，当有结果返回时，会触发事先注册的处理器，将请求通知上层调用。最终会调用到DefaultFuture中的received方法12345678910111213141516171819202122232425262728293031public static void received(Channel channel, Response response) &#123; try &#123; DefaultFuture future = FUTURES.remove(response.getId()); if (future != null) &#123; future.doReceived(response); &#125; else &#123; logger.warn(\"The timeout response finally returned at \" + (new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.SSS\").format(new Date())) + \", response \" + response + (channel == null ? \"\" : \", channel: \" + channel.getLocalAddress() + \" -&gt; \" + channel.getRemoteAddress())); &#125; &#125; finally &#123; CHANNELS.remove(response.getId()); &#125; &#125; private void doReceived(Response res) &#123; lock.lock(); try &#123; response = res; if (done != null) &#123; done.signal(); &#125; &#125; finally &#123; lock.unlock(); &#125; if (callback != null) &#123; invokeCallback(callback); &#125; &#125; 首先是获取当前调用的DefaultFuture实例，之后调用它的doReceived方法。这个\b方法先加了锁，之后\b将返回结果赋给DefaultFuture的response（这个response是DefaultFuture的一个实例属性，也就是上层业务要获取的结果）。之后就是上面说的向线程发信号，唤醒\b等待中的调用线程。 以上就是Dubbo将底层的netty的异步调用转为同步调用。还有一个问题是dubbo是如何实现\b接口调用超时的。 答案在下面： 12345678910public class DefaultFuture implements ResponseFuture &#123; private static final Map&lt;Long, DefaultFuture&gt; FUTURES = new ConcurrentHashMap&lt;Long, DefaultFuture&gt;(); static &#123; Thread th = new Thread(new RemotingInvocationTimeoutScan(), \"DubboResponseTimeoutScanTimer\"); th.setDaemon(true); th.start(); &#125; DefaultFuture中用了一个FUTURES的map来保存每个\b具体调用的DefaultFuture实例。它的key是每次调用的id，这个id就是用来区分不同的调用的，每个请求都不一样。之后\b在初始化这个类时，启动一个守护线程，它就是\b用来实现超时的。它的run方法如下： 123456789101112131415161718192021222324252627private static class RemotingInvocationTimeoutScan implements Runnable &#123; @Override public void run() &#123; while (true) &#123; try &#123; for (DefaultFuture future : FUTURES.values()) &#123; if (future == null || future.isDone()) &#123; continue; &#125; if (System.currentTimeMillis() - future.getStartTimestamp() &gt; future.getTimeout()) &#123; // create exception response. Response timeoutResponse = new Response(future.getId()); // set timeout status. timeoutResponse.setStatus(future.isSent() ? Response.SERVER_TIMEOUT : Response.CLIENT_TIMEOUT); timeoutResponse.setErrorMessage(future.getTimeoutMessage(true)); // handle response. DefaultFuture.received(future.getChannel(), timeoutResponse); &#125; &#125; Thread.sleep(30); &#125; catch (Throwable e) &#123; logger.error(\"Exception when scan the timeout invocation of remoting.\", e); &#125; &#125; &#125; &#125; 逻辑很简单，就是\b每30毫秒轮询一次所有的DefaultFuture，若\bfuture已经有返回结果，则跳过；若没有返回，则计算一下当前时间是否超时，若超时，则构造一个超时的返回结果，之后调用上面提到的DefaultFuture的received方法。 总结以上就是Dubbo同步调用在消费者端的大体实现。主要\b就是用了一个锁来将调用线程阻塞起来，之后netty接收到返回结果之后，会发信号唤醒调用线程。或是超时，也会返回一个超时的结果，并唤醒调用线程。这样就实现了对上层业务来说的同步调用。因为Dubbo的\b流程非常复杂，因此本篇文章限于篇幅，无法将\b它的上下游流程勾勒得很清楚。只是提纲挈领地写出关键之处。对于整体流程的把握，还是需要自己去研究代码才行。","tags":[]},{"title":"FutureTask的简单实用和源码解析","date":"2018-08-11T16:00:00.000Z","path":"2018/08/12/FutureTask的简单使用和源码解析/","text":"从一个问题说起假设有4个方法，可以获取四个值，这四个值可以用来构造一个用户的实例。如果要写一个方法，并发获取这4个值。 这个题目应该用Future来做。下面是我模拟的程序。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100/** * 服务类，有4个方法 */class Service &#123; public int get1() &#123; try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return 1; &#125; public int get2() &#123; try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return 2; &#125; public int get3() &#123; try &#123; Thread.sleep(3000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return 3; &#125; public int get4() &#123; try &#123; Thread.sleep(4000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return 4; &#125;&#125;public class FutureTaskTest &#123; public static void main(String[] args) &#123; Service service = new Service(); /** 记录\b\b开始执行时间 */ long start = System.currentTimeMillis(); \b/** * \b用4个FutureTask来并行执行service的4个方法, 执行完之后\b一并 * 获取执行结果 */ FutureTask&lt;Integer&gt; futureTask1 = new FutureTask&lt;&gt;(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; return service.get1(); &#125; &#125;); Thread thread1 = new Thread(futureTask1); thread1.start(); FutureTask&lt;Integer&gt; futureTask2 = new FutureTask&lt;&gt;(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; return service.get2(); &#125; &#125;); Thread thread2 = new Thread(futureTask2); thread2.start(); FutureTask&lt;Integer&gt; futureTask3 = new FutureTask&lt;&gt;(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; return service.get3(); &#125; &#125;); Thread thread3 = new Thread(futureTask3); thread3.start(); FutureTask&lt;Integer&gt; futureTask4 = new FutureTask&lt;&gt;(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; return service.get4(); &#125; &#125;); Thread thread4 = new Thread(futureTask4); thread4.start(); try &#123; int a = futureTask1.get(); int b = futureTask2.get(); int c = futureTask3.get(); int d = futureTask4.get(); long end = System.currentTimeMillis(); System.out.println(end - start); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125;&#125; \b执行结果，打印执行时间为4007毫秒，与预期相同，也就是并行执行4个任务中耗时最长的一个。 下面就来分析\bFutureTask的原理。 FutureTask的使用Java中，\b使用线程执行任务一般实现Runnable接口。它只有一个run方法，没有返回值。因此当主线程需要用一个\b子线程去执行某个任务，并返回某个结果时，必须采用其他的方法。比如在Thread中添加一个实例，然后运行run方法时去修改这个值。但这有一个问题，就是主线程并不知道子线程\b何时执行结束。因此又引出其他的问题。显然\b仅靠Runnable\b并不是解决这类问题的好方法。 因此，Java提供了Callable接口，它代表一个能返回执行结果的任务。它的定义如下：123456789public interface Callable&lt;V&gt; &#123; /** * Computes a result, or throws an exception if unable to do so. * * @return computed result * @throws Exception if unable to compute a result */ V call() throws Exception;&#125; 这个接口有一个参数类型V，同时只有一个方法call。当call方法执行完之后，会返回一个V类型的实例。 但是我们遍览jdk的类库，发现并没有一个public的类是实现了Callable接口的。因此它是一个完全由用户实现的接口，必须搭配其他的接口和类才能使用。 于是java又提供了Future接口：123456789101112131415161718192021222324252627public interface Future&lt;V&gt; &#123; /** * 取消任务执行，参数代表如果任务已经开始执行，\b是否要中断 */ boolean cancel(boolean mayInterruptIfRunning); /** * 判断任务是否已经取消 */ boolean isCancelled(); /** * 判断任务是否执行完成 */ boolean isDone(); /** * 获取线程执行的结果 */ V get() throws InterruptedException, ExecutionException; /** * 获取线程\b执行结果，并设置一个超时时间，若超过了则抛出异常 */ V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125; 这个接口的注释说：这个接口代表了一次异步计算的结果。所谓异步计算，也就是代表一个线程。 \bFutureTask源码解析通过上面的例子，\b我们可以通过推理和验证的方式来研究FutureTask的源码实现。首先FutureTask能作为参数传递给Thread类来实例化一个线程，说明它实现了Runnable接口。同时\b它\b也实现了Future接口，否则我们这篇文章也不会写它了。 于是我们看FutureTask的定义头:1public class FutureTask&lt;V&gt; implements RunnableFuture&lt;V&gt; &#123; 而RunnableFuture的定义头：1public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; 果如所料。 再从上面的例子中可以看出，FutureTask的构造方法\b的参数是一个Callable接口。那说明它内部就是通过一个Callable实例来执行具体的逻辑的，并且Callable的实现类是由用户提供的。FutureTask的构造方法如下： 123456public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; // ensure visibility of callable&#125; 从构造方法可以看出，FutureTask还有一个实例属性是state，并且在构造方法中被初始化为NEW。\b这个属性和可能的值\b定义如下： 1234567891011121314151617/** * 任务运行状态，初始化为NEW，这个状态变量只会在set方法、setException和cancel方法中被转化为终态 * * Possible state transitions: * NEW -&gt; COMPLETING -&gt; NORMAL * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL * NEW -&gt; CANCELLED * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED */ private volatile int state; private static final int NEW = 0; private static final int COMPLETING = 1; private static final int NORMAL = 2; private static final int EXCEPTIONAL = 3; private static final int CANCELLED = 4; private static final int INTERRUPTING = 5; private static final int INTERRUPTED = 6; 详细的状态转化在下面方法中介绍。 构造了FutureTask之后，就需要用一个Thread去执行它。Thread执行它持有的Runnable实例的run方法。那么我们看一下FutureTask的run方法： 1234567891011121314151617181920212223242526272829303132333435public void run() &#123; // 若state不为NEW，或者不能将执行此FutureTask的线程赋值给FutureTask的Thread属性，则放弃执行 if (state != NEW || !UNSAFE.compareAndSwapObject(this, runnerOffset, null, Thread.currentThread())) return; try &#123; Callable&lt;V&gt; c = callable; // \b再次判断state必须为NEW才执行 if (c != null &amp;&amp; state == NEW) &#123; V result; boolean ran; try &#123; // 执行\b\bCallable方法，获取结果 result = c.call(); ran = true; &#125; catch (Throwable ex) &#123; // 捕获异常时处理异常 result = null; ran = false; setException(ex); &#125; // 执行正常结束时设置结果 if (ran) set(result); &#125; &#125; finally &#123; // runner在将state设置为能阻止对run的并发调用前必须保持非null的值 runner = null; // 再次读取state，若为\b正在中断中，或已中断，则进行相应处理 int s = state; if (s &gt;= INTERRUPTING) handlePossibleCancellationInterrupt(s); &#125;&#125; 进入run方法时，用了Oracle的私有api Unsafe的方法compareAndSwapObject来线程安全地将FutureTask持有的Thread实例初始化为当前执行的线程（也就是\b被主线程开启的子线程本身）。这个方法\b采用了CAS（Compare and Swap），也就是要修改的参数必须符合预期的值才能给它赋新值。这里是为了\b确保只有一个子线程能执行FutureTask，以避免并发执行带来的问题。 当执行完之后，无论是正常还是\b捕获到异常，都需要将runner置为null。而再次读state，则是若runner被中断了，需要进行相应处理。具体处理在后面介绍。 \b下面我们看get方法。get方法的作用是获取执行的结果。在看代码之前，我们可以设想，虽然FutureTask的执行只能由一个线程来完成。但是\b应该是允许多个线程来并发获取结果的。那它必然有某种数据结构来保存读取结果的线程。\b说这么多，其实这种数据结构就是WaitNode：12345678910111213/** Treiber stack of waiting threads */private volatile WaitNode waiters;/** * 记录等待线程（即是读取\b\b执行结果的线程）的简单链表 * */static final class WaitNode &#123; volatile Thread thread; volatile WaitNode next; WaitNode() &#123; thread = Thread.currentThread(); &#125;&#125; \bget方法：123456public V get() throws InterruptedException, ExecutionException &#123; int s = state; if (s &lt;= COMPLETING) s = awaitDone(false, 0L); return report(s);&#125; 首先判断state，若处于完成中，或者NEW。则调用awaitDone\b。否则直接调用report返回结果。 在我们的例子中看到，当在主线程调用FutureTask的get的时候，会一直等待到子线程将任务执行完成，再将结果返回给主线程。这个等待过程就是通过await\bDone方法来完成的。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849/** * 等待完成，若已中断或超时则终止 * * @param timed true if use timed waits * @param nanos time to wait, if timed * @return state upon completion */private int awaitDone(boolean timed, long nanos) throws InterruptedException &#123; final long deadline = timed ? System.nanoTime() + nanos : 0L; WaitNode q = null; boolean queued = false; for (;;) &#123; // 若线程已中断，则从\b等待链表中移除当前线程节点 if (Thread.interrupted()) &#123; removeWaiter(q); throw new InterruptedException(); &#125; int s = state; // 若非NEW或完成中状态，则将节点的线程置为null，并返回当前状态 if (s &gt; COMPLETING) &#123; if (q != null) q.thread = null; return s; &#125; // 若为完成中状态，则当前线程让出CPU执行时间，待下次竞争到CPU时再判断是否完成 else if (s == COMPLETING) // cannot time out yet Thread.yield(); // \b若state为NEW，则新建等待队列节点 else if (q == null) q = new WaitNode(); // 若当前线程所属的等待节点还没有插入\b链表，则插入到链表头 else if (!queued) queued = UNSAFE.compareAndSwapObject(this, waitersOffset, q.next = waiters, q); // 如果\b考虑超时时间，则计算时间并进行处理 else if (timed) &#123; nanos = deadline - System.nanoTime(); if (nanos &lt;= 0L) &#123; removeWaiter(q); return state; &#125; LockSupport.parkNanos(this, nanos); &#125; else LockSupport.park(this); &#125;&#125; 从上述代码看出，awaitDone的逻辑也不是很复杂，主要就是根据state的各种状态，进行新建\b等待节点，节点入\b等待列表等操作。 \breport方法：1234567891011121314/** * 任务完成时返回结果或抛出异常 * * @param s completed state value */@SuppressWarnings(\"unchecked\")private V report(int s) throws ExecutionException &#123; Object x = outcome; if (s == NORMAL) return (V)x; if (s &gt;= CANCELLED) throw new CancellationException(); throw new ExecutionException((Throwable)x);&#125; outcome就是要返回的执行结果。那么它的值是在哪里赋的呢？就是我们前面提到过的set方法。 123456789101112131415/** * * 若执行结果还没有赋值，或被取消时，设置执行结果 * * @param v the value */protected void set(V v) &#123; // 先将state从NEW转化为完成中 if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123; outcome = v; // 将state从NEW转化为\b正常结束 UNSAFE.putOrderedInt(this, stateOffset, NORMAL); // final state finishCompletion(); &#125;&#125; 当执行Callable的call方法\b发生异常时，会调用setException方法。123456789protected void setException(Throwable t) &#123; // 先将state从NEW转化为完成中 if (UNSAFE.compareAndSwapInt(this, stateOffset, NEW, COMPLETING)) &#123; outcome = t; // 将state从NEW转化为\b发生异常 UNSAFE.putOrderedInt(this, stateOffset, EXCEPTIONAL); // final state finishCompletion(); &#125;&#125; finishCompletion主要完成一些扫尾工作。123456789101112131415161718192021222324private void finishCompletion() &#123; // assert state &gt; COMPLETING; for (WaitNode q; (q = waiters) != null;) &#123; if (UNSAFE.compareAndSwapObject(this, waitersOffset, q, null)) &#123; for (;;) &#123; Thread t = q.thread; if (t != null) &#123; q.thread = null; LockSupport.unpark(t); &#125; WaitNode next = q.next; if (next == null) break; q.next = null; // unlink to help gc q = next; &#125; break; &#125; &#125; done(); callable = null; // to reduce footprint&#125; 此方法的逻辑也很简单，就是遍历等待列表，将每一个节点都从列表删除，同时将每个\b等待线程解除阻塞。 以上分析了任务执行完成的情况，还有一种情况是执行被取消。它通过cancel方法来实现。123456789101112131415161718192021public boolean cancel(boolean mayInterruptIfRunning) &#123; // 此条件等价于: state != NEW || !UNSAFE.compareAndSwapInt(this, stateOffset, NEW,mayInterruptIfRunning ? INTERRUPTING : CANCELLED) if (!(state == NEW &amp;&amp; UNSAFE.compareAndSwapInt(this, stateOffset, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED))) return false; try &#123; // in case call to interrupt throws exception if (mayInterruptIfRunning) &#123; try &#123; Thread t = runner; if (t != null) t.interrupt(); &#125; finally &#123; // final state UNSAFE.putOrderedInt(this, stateOffset, INTERRUPTED); &#125; &#125; &#125; finally &#123; finishCompletion(); &#125; return true;&#125; 当state为NEW时，返回fasle。若为NEW，则根据传入的参数，若传入true，则将state转化为正在中断，否则转化为已取消。 若传入参数为true，取消时还需中断执行任务的线程。之后将state设置为已中断。 总结以上就是FutureTask的简单使用和源码解析。除了直接使用\b新建线程来执行FutureTask，还可以使用线程池，本文没有对此进行介绍。 分析FutureTask的源码，发现还是比较简单的。主要就是通过\b一个内部持有的Thread来执行任务，同时用一个等待\b列表来存放等待获取结果的线程。当等待线程尝试用get获取结果时，会先判断是否为完成中以后的状态，若是则\b直接返回结果。否则\b就一直轮询，等待状态更新。最后执行完成之后，则遍历等待列表，将所有等待线程都解除阻塞。\b当然还有处理异常等情况，此处不再分析。","tags":[]},{"title":"Dubbo中对线程池的使用","date":"2018-08-04T16:00:00.000Z","path":"2018/08/05/Dubbo中对线程池的使用/","text":"线程池的概念线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。 Dubbo中的线程池Dubbo是一款高性能的分布式服务框架，它实现了\b透明化的远程\b调用，只需要通过配置，就能像调用当前jvm内的方法一样调用另一个JVM中的方法，而无需关心底层通信细节。 我们在使用Dubbo时，\b如果只是\b发布一个服务供其他\bjava进程调用，或是调用另一个JVM进程中的方法，一般不需要\b显式地关注多线程的使用。但是我们\b的一个程序，可以发布多个接口，可以并发处理多个接口的调用。或是并发地调用\b多个远程接口。这显然是底层框架帮我们处理了多线程的工作。 \bDubbo中对Netty线程的使用Dubbo在传输层默认使用的是Netty作为通信框架。Dubbo作为服务提供者时使用Netty建立Tcp服务端，作为服务使用者时也使用Netty建立Tcp客户端。 Netty\b是基于java的NIO技术\b并结合线程池的通信框架。以下是Dubbo建立\b服务端的代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class NettyServer extends AbstractServer implements Server &#123; private static final Logger logger = LoggerFactory.getLogger(NettyServer.class); private Map&lt;String, Channel&gt; channels; // &lt;ip:port, channel&gt; private ServerBootstrap bootstrap; private io.netty.channel.Channel channel; private EventLoopGroup bossGroup; private EventLoopGroup workerGroup; public NettyServer(URL url, ChannelHandler handler) throws RemotingException &#123; super(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME))); &#125; @Override protected void doOpen() throws Throwable &#123; bootstrap = new ServerBootstrap(); bossGroup = new NioEventLoopGroup(1, new DefaultThreadFactory(\"NettyServerBoss\", true)); workerGroup = new NioEventLoopGroup(getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS), new DefaultThreadFactory(\"NettyServerWorker\", true)); final NettyServerHandler nettyServerHandler = new NettyServerHandler(getUrl(), this); channels = nettyServerHandler.getChannels(); bootstrap.group(bossGroup, workerGroup) .channel(NioServerSocketChannel.class) .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE) .childOption(ChannelOption.SO_REUSEADDR, Boolean.TRUE) .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT) .childHandler(new ChannelInitializer&lt;NioSocketChannel&gt;() &#123; @Override protected void initChannel(NioSocketChannel ch) throws Exception &#123; NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyServer.this); ch.pipeline()//.addLast(\"logging\",new LoggingHandler(LogLevel.INFO))//for debug .addLast(\"decoder\", adapter.getDecoder()) .addLast(\"encoder\", adapter.getEncoder()) .addLast(\"handler\", nettyServerHandler); &#125; &#125;); // bind ChannelFuture channelFuture = bootstrap.bind(getBindAddress()); channelFuture.syncUninterruptibly(); channel = channelFuture.channel(); &#125; // 省略若干代码&#125; \bServerBootstrap是Netty的一个类，用于建立服务端的功能。它使用了两组线程池，一个是父线程池，用于处理接受客户端的连接请求，因为\bDubbo协议只需要监听一个端口，所以这个线程池只需要一个线程即可。另一个是子线程池，每当\b和一个客户端建立连接之后，就会从此线程池中选择一个线程进行IO操作。 Dubbo中建立tcp客户端也使用了Netty，下面是实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243public class NettyClient extends AbstractClient &#123; private static final Logger logger = LoggerFactory.getLogger(NettyClient.class); private static final NioEventLoopGroup nioEventLoopGroup = new NioEventLoopGroup(Constants.DEFAULT_IO_THREADS, new DefaultThreadFactory(\"NettyClientWorker\", true)); private Bootstrap bootstrap; private volatile Channel channel; // volatile, please copy reference to use public NettyClient(final URL url, final ChannelHandler handler) throws RemotingException &#123; super(url, wrapChannelHandler(url, handler)); &#125; @Override protected void doOpen() throws Throwable &#123; final NettyClientHandler nettyClientHandler = new NettyClientHandler(getUrl(), this); bootstrap = new Bootstrap(); bootstrap.group(nioEventLoopGroup) .option(ChannelOption.SO_KEEPALIVE, true) .option(ChannelOption.TCP_NODELAY, true) .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT) //.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, getTimeout()) .channel(NioSocketChannel.class); if (getTimeout() &lt; 3000) &#123; bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, 3000); &#125; else &#123; bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, getTimeout()); &#125; bootstrap.handler(new ChannelInitializer() &#123; @Override protected void initChannel(Channel ch) throws Exception &#123; NettyCodecAdapter adapter = new NettyCodecAdapter(getCodec(), getUrl(), NettyClient.this); ch.pipeline()//.addLast(\"logging\",new LoggingHandler(LogLevel.INFO))//for debug .addLast(\"decoder\", adapter.getDecoder()) .addLast(\"encoder\", adapter.getEncoder()) .addLast(\"handler\", nettyClientHandler); &#125; &#125;); &#125; Netty客户端只需要一个线程池就可以。 以上是Dubbo中对于IO线程池的使用。此外，Dubbo\b发送请求和处理请求也使用了线程池。 Dubbo业务线程池的使用Dubbo中线程池的种类Dubbo中使用的线程池都是基于Java提供的ThreadPoolExecutor类。它基于不同的策略提供了创建不同的ThreadPoolExecutor的线程池工厂。包括以下几种： CachedThreadPool : 缓存线程池，它创建的是一个可以扩展的线程池，可以配置核心线程数量，最大线程数量，任务队列长度，空闲线程保活时间。这个线程池默认的队列长度是java中int类型的最大值。 EagerThreadPool : 这个线程\b池工厂提供的是一个Dubbo提供自定义的线程池类EagerThreadPoolExecutor，这个线程池扩展了java中的ThreadPoolExecutor。当所有的核心线程都处于忙碌状态时，若有新任务到来，将会直接创建新线程，而不是放到任务队列中。 FixedThreadPool : \b固定线程池，它创建的是一个拥有固定线程数量的线程池。用户可配置相关参数。这个线程池是默认选项。 LimitedThreadPool : 可伸缩线程池。它提供的线程池的特色是，线程池设定的线程保活时间是Long类型的最大值。因此它的线程不会减少，只会增加。 Dubbo中对业务线程池的\b配置是在下面这个类中实现的。 123456789101112131415161718192021222324public class WrappedChannelHandler implements ChannelHandlerDelegate &#123; protected static final Logger logger = LoggerFactory.getLogger(WrappedChannelHandler.class); protected static final ExecutorService SHARED_EXECUTOR = Executors.newCachedThreadPool(new NamedThreadFactory(\"DubboSharedHandler\", true)); protected final ExecutorService executor; protected final ChannelHandler handler; protected final URL url; public WrappedChannelHandler(ChannelHandler handler, URL url) &#123; this.handler = handler; this.url = url; executor = (ExecutorService) ExtensionLoader.getExtensionLoader(ThreadPool.class).getAdaptiveExtension().getExecutor(url); String componentKey = Constants.EXECUTOR_SERVICE_COMPONENT_KEY; if (Constants.CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(Constants.SIDE_KEY))) &#123; componentKey = Constants.CONSUMER_SIDE; &#125; DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension(); dataStore.put(componentKey, Integer.toString(url.getPort()), executor); &#125; 这个类持有了一个线程池接口\bExecutorService executor。当实例化这个类时，会根据URL的参数获取对应的线程池，也就是上面说的四种线程池中的一种。 以上是对Dubbo中线程池\b使用的简要介绍，还有很多地方没有深入。后续有机会再分析。","tags":[]},{"title":"Spring容器ClassPathXmlApplicationContext启动过程解析","date":"2018-05-26T16:00:00.000Z","path":"2018/05/27/Spring容器ClasspathXmlApplicationContext启动过程解析/","text":"Spring是企业级\bJava开发中应用最广泛的编程框架。在EJB日渐式微的情况下，Spring已成为企业级Java开发的事实标准。经过十多年的发展，不仅传统的配置方式仍然在广泛使用，同时也诞生了Spring Boot，Spring Cloud等基于Spring的新的框架，在\b方兴未艾的微服务领域继续引领着潮流。 在使用Spring的过程中，相信我们都很容易感受到Spring给我们带来的便利，这不禁就会引发我们对Spring本身的设计和实现的兴趣。通过阅读文档和代码，我们\b会发现Spring堪称Java项目设计与实现的典范，它的设计非常地优雅，是我们学习Java开发，乃至面向对象设计与开放的很好的教材。 在Spring\b的体系中，\b依赖注入（Dependency Injection，简称DI）是一个基础设施级的功能。一般说使用Spring，默认都会认为必然会使用DI的功能。所以学习Spring的源代码，一般也会从DI入手。 Spring的依赖注入主要是靠应用上下文（ApplicationContext）来实现\b的。顾名思义，应用上下文就是持有了应用启动必须的各种\b信息的对象。在多种ApplicationContext中，ClassPathXmlApplicationContext是比较简单的一个，从它的名字可以看出，它是基于Java的Classpath的，同时是基于Xml配置的。 下面先分析一下ClassPathXmlApplicationContext的类关系\b我们\b首先\b关注一下ClassPathXmlApplicationContext到ApplicationContext的继承和实现关系。从顶向下各个接口和实现类的功能如下： ApplicationContext：这个接口是提供了应用\b程序配置的核心接口，当程序运行时它是只读的，不能修改状态，但是可以重新加载（reload），只要具体的实现类支持。 ConfigurableApplicationContext：这是一个支持SPI加载的接口，绝大多数应用上下文都实现了它。它内部定义了\b一些默认的基础常量，同时提供了ApplicationContext之外的配置应用程序的方法。 AbstractApplicationContext：应用上下文的抽象实现类。这个类可以说是应用上下文的骨架实现类。它不\b关心\b用到的配置的存储方式；实现了通用的应用上下文功能；采用了模板设计模式，具体的实现类需要实现它定义的抽象方法。 Base class for {@link org.springframework.context.ApplicationContext} implementations which are supposed to support multiple calls to {@link #refresh()}, creating a new internal bean factory instance every time. Typically (but not necessarily), such a context will be driven by a set of config locations to load bean definitions from. AbstractRefreshableApplicationContext：这个类支持\b多次刷新上下文。每次刷新时，它会创建一个新的内部Bean Factory（Bean工厂，通过它实际持有创建的bean）。 AbstractRefreshableConfigApplicationContext：提供了对某种形式的存储配置文件路径的支持，包括类路径（ClassPath），文件系统等。 AbstractXmlApplicationContext：这个类提供了从XML文件中提取bean定义的功能（通过XmlBeanDefinitionReader实现） ClassPathXmlApplicationContext：\b这个类从Class path获取Context配置文件。 下面就以dubbo源代码中提供的demo来跟踪一下ClassPathXmlApplicationContext这个\b应用上下文的启动过程。它主要通过下面这一行代码\b来启动： 1ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;\"META-INF/spring/dubbo-demo-provider.xml\"&#125;); 这行代码很简单，就是调用了构造方法，参数是一个字符串数组，只有一个元素，指出了配置文件的路径。 进入这个构造方法：123456789/** * Create a new ClassPathXmlApplicationContext, loading the definitions * from the given XML files and automatically refreshing the context. * @param configLocations array of resource locations * @throws BeansException if context creation failed */public ClassPathXmlApplicationContext(String... configLocations) throws BeansException &#123; this(configLocations, true, null); &#125; 它又调用了自己的另一个构造函数1234567891011121314151617181920/** * Create a new ClassPathXmlApplicationContext with the given parent, * loading the definitions from the given XML files. * @param configLocations array of resource locations * @param refresh whether to automatically refresh the context, * loading all bean definitions and creating all singletons. * Alternatively, call refresh manually after further configuring the context. * @param parent the parent context * @throws BeansException if context creation failed * @see #refresh() */ public ClassPathXmlApplicationContext(String[] configLocations, boolean refresh, ApplicationContext parent) throws BeansException &#123; super(parent); setConfigLocations(configLocations); if (refresh) &#123; refresh(); &#125; &#125; 这个构造函数先调用了\b超类的构造函数，之后判断传入的是否刷新的布尔值，如果为true，则调用refresh方法。 超类的构造方法基本什么也没做，除了每个超类定义的在构造函数之前就需要初始化的field的初始化之外，只是在AbstractApplicationContext的构造函数中设置了一下\b\bparent context（Spring支持有层级的应用上下文，但本例中不涉及）。 由此可见，所有的启动和刷新上下文的功能都是refresh这个方法完成的。这个方法是在ConfigurableApplicationContext中定义，在AbstractApplicationContext中定义的，子类没有\b覆盖它，这也说明Spring不同的上下文启动和刷新的流程是通用的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364 @Overridepublic void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; // Prepare this context for refreshing. prepareRefresh(); // Tell the subclass to refresh the internal bean factory. ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // Prepare the bean factory for use in this context. prepareBeanFactory(beanFactory); try &#123; // Allows post-processing of the bean factory in context subclasses. postProcessBeanFactory(beanFactory); // Invoke factory processors registered as beans in the context. invokeBeanFactoryPostProcessors(beanFactory); // Register bean processors that intercept bean creation. registerBeanPostProcessors(beanFactory); // Initialize message source for this context. initMessageSource(); // Initialize event multicaster for this context. initApplicationEventMulticaster(); // Initialize other special beans in specific context subclasses. onRefresh(); // Check for listener beans and register them. registerListeners(); // Instantiate all remaining (non-lazy-init) singletons. finishBeanFactoryInitialization(beanFactory); // Last step: publish corresponding event. finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // Reset common introspection caches in Spring's core, since we // might not ever need metadata for singleton beans anymore... resetCommonCaches(); &#125; &#125; &#125; prepareFresh方法主要做了一些准备工作，如设置启动时间，设置关闭状态为false，活动状态为true，初始化属性源等。 obtainFreshBeanFactory方法内部通过AbstractRefreshableApplicationContext中的refreshBeanFactory方法刷新bean工厂，它先判断内部的bean factory是否已存在，若存在则销毁它们保存的bean，并关闭之。\b之后这个方法的核心工作是调用了createBeanFactory方法创建内部的bean factory。 1234567891011121314151617/** * Create an internal bean factory for this context. * Called for each &#123;@link #refresh()&#125; attempt. * &lt;p&gt;The default implementation creates a * &#123;@link org.springframework.beans.factory.support.DefaultListableBeanFactory&#125; * with the &#123;@linkplain #getInternalParentBeanFactory() internal bean factory&#125; of this * context's parent as parent bean factory. Can be overridden in subclasses, * for example to customize DefaultListableBeanFactory's settings. * @return the bean factory for this context * @see org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowBeanDefinitionOverriding * @see org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowEagerClassLoading * @see org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowCircularReferences * @see org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowRawInjectionDespiteWrapping */ protected DefaultListableBeanFactory createBeanFactory() &#123; return new DefaultListableBeanFactory(getInternalParentBeanFactory()); &#125; 可见是新建了一个DefaultListableBeanFactory。这个类的类关系如下图： \b关注一下BeanFactory这个接口，它是访问Spring\b bean容器的根接口，提供了访问bean容器的基本功能。 Extension of the {@link BeanFactory} interface to be implemented by bean factories that can enumerate all their bean instances, rather than attempting bean lookup by name one by one as requested by clients. BeanFactory implementations that preload all their bean definitions (such as XML-based factories) may implement this interface. ListableBeanFactory提供了枚举bean实例的功能，它会预加载bean的定义 BeanDefinitionRegistry：持有bean定义，例如root bean \bdefinition和child bean definition实例通常被bean factory实现。 DefaultListableBeanFactory\b：ListableBeanFactory和BeanDefinitionRegistry的默认实现。常用于在访问bean之前，\b保存所有bean的definition。 123456789101112131415161718192021222324/** * This implementation performs an actual refresh of this context's underlying * bean factory, shutting down the previous bean factory (if any) and * initializing a fresh bean factory for the next phase of the context's lifecycle. */ @Override protected final void refreshBeanFactory() throws BeansException &#123; if (hasBeanFactory()) &#123; destroyBeans(); closeBeanFactory(); &#125; try &#123; DefaultListableBeanFactory beanFactory = createBeanFactory(); beanFactory.setSerializationId(getId()); customizeBeanFactory(beanFactory); loadBeanDefinitions(beanFactory); synchronized (this.beanFactoryMonitor) &#123; this.beanFactory = beanFactory; &#125; &#125; catch (IOException ex) &#123; throw new ApplicationContextException(\"I/O error parsing bean definition source for \" + getDisplayName(), ex); &#125; &#125; 通过loadBeanDefinition\b加载定义到beanFactory中。\b这个方法是通过XmlBeanDefinitionReader去加载配置文件中的bean定义。具体过程比较繁琐，这里就不展开了，后续有时间再专门介绍。加载完之后，会将beanDefinition保存在DefaultListableBeanFactory的一个field中： 12/** Map of bean definition objects, keyed by bean name */ private final Map&lt;String, BeanDefinition&gt; beanDefinitionMap = new ConcurrentHashMap&lt;String, BeanDefinition&gt;(256); 至此，Spring\b容器启动过程中的第一大步骤就算基本完成了，就是将bean定义从配置文件中读取出来，并解析为BeanDefinition保存在应用上下文的内置bean factory的内部的一个map钟，key为配置文件中定义的bean的name。 之后回到refresh方法，下面是prepareBeanFactory方法，这个方法就是对内部的\bbean factory做各种设置，以方便后面使用。具体就不介绍了。感兴趣可以自行研究代码。 postProcessBeanFactory是一个空方法，可以自定义一些对bean factory的定制化处理。由此以及后续的过程可以看出，Spring非常注重扩展性，留出了很多供使用者灵活扩展的地方，充分体现了“对修改关闭，对扩展开放”的面向对象设计原则。 invokeBeanFactoryPostProcessors\b：实例化并调用所有的BeanFactoryPostProcessor，BeanFactoryPostProcessor就是在bean factory的标准初始化流程结束之后，对它进行一些特殊配置的类。这个接口和后面的一些接口都可以看出Spring设计的\b原则，那就是\b先定义好某个\b\b功能的标准处理流程，但也提供了进行定制化处理的接口，并通过先注册后调用的方式很有秩序的进行处理。 registerBeanPostProcessors：实例化并调用所有已经注册的BeanPostProcessor。BeanPostProcessor和BeanFactoryPostProcessor类似，只不过一个是针对bean factory，一个是针对具体的bean。它定义了两个方法postProcessBeforeInitialization和postProcessAfterInitialization。前者会在某个bean的初始化方法（InitializingBean接口的afterPropertiesSet方法，或自定义的init-method\b）调用之前被调用。后者则是在初始化方法调用之后调用。 initMessageSource方法初始化message source。 initApplicationEventMulticaster方法初始化\b应用事件多播器。应用事件多播器是管理一系列ApplicationListener的，并且发布事件给它们。 onRefresh空方法，留给子类扩展。 registerListeners是获取所有实现了ApplicationListener的类，并注册它们，同时将一些早起的Application event发布出去。 finishBeanFactoryInitialization终于到最重要的一步了，就是完成Context中的bean factory的初始化，并初始化所有的还未初始化的\b单例bean。这个方法首先又对bean factory做了一系列设置，之后调用DefaultListableBeanFactory的preInstantiateSingletons方法对\bbean进行了初始化。 12345678910111213141516171819202122232425262728293031323334353637public void preInstantiateSingletons() throws BeansException &#123; if (this.logger.isDebugEnabled()) &#123; this.logger.debug(\"Pre-instantiating singletons in \" + this); &#125; // Iterate over a copy to allow for init methods which in turn register new bean definitions. // While this may not be part of the regular factory bootstrap, it does otherwise work fine. List&lt;String&gt; beanNames = new ArrayList&lt;String&gt;(this.beanDefinitionNames); // Trigger initialization of all non-lazy singleton beans... for (String beanName : beanNames) &#123; RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName); if (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123; if (isFactoryBean(beanName)) &#123; final FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName); boolean isEagerInit; if (System.getSecurityManager() != null &amp;&amp; factory instanceof SmartFactoryBean) &#123; isEagerInit = AccessController.doPrivileged(new PrivilegedAction&lt;Boolean&gt;() &#123; @Override public Boolean run() &#123; return ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit(); &#125; &#125;, getAccessControlContext()); &#125; else &#123; isEagerInit = (factory instanceof SmartFactoryBean &amp;&amp; ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit()); &#125; if (isEagerInit) &#123; getBean(beanName); &#125; &#125; else &#123; getBean(beanName); &#125; &#125; &#125; 基本过程是就是遍历所有的bean definition，\b判断不是抽象类，同时是单例，并且没有设置lazy-init的就进行处理。处理时又分为是否是工厂类和不是工厂类进行处理。普通bean直接调用getBean进行处理，工厂bean则要进行一些处理，判断是否是立即加载的。 getBean内部直接调用了\bdoGetBean方法，doGetBean中最终调用了createBean方法来创建一个bean，createBean中调用了doCreateBean来实际创建一个bean。 Spring是通过一个BeanWrapper接口来包裹我们实际要创建的类型的bean，这也是一种比较常见的设计模式，就是通过包装类来提供一些额外的功能。BeanWrapper的实现类主要是实现了Bean的属性编辑器的功能。doCreateBean做的事情比较杂，后续有时间再专门分析。 finishRefresh方法主要是完成刷新，主要做了一些善后工作。 通过对ClassPathXmlApplicationContext的启动过程的分析，我们可以总结一些规律。一是Spring的应用上下文的类体系设计得比较复杂，也因此显得\b很强大和完善。二是\b标准流程和扩展流程相分离，给使用者的扩展留出了足够的\b空间。三是采用了很多内部缓存类，比如缓存了\bbean的定义，bean实例，bean的\bname等都\b用了不同的集合做了专门的缓存。特别是\b针对单例bean的三级缓存，可以解决循环依赖的问题。","tags":[]},{"title":"Jdbc对数据库事务隔离级别的验证","date":"2017-11-25T16:00:00.000Z","path":"2017/11/26/Jdbc中对数据库隔离级别的验证/","text":"数据库的事务隔离级别一.读未提交读未提交是指当一个事务在执行过程中，若另一个事务修改了同一条数据，但没有提交，仍然会被当前数据读取到被更改但未提交的新值。此时可能发生脏读。二.读提交读提交是指当一个事务在执行过程中，若另一个事务修改了数据并且提交了修改。此时提交后的数据会被当前数据读取到。此时会发生不可重复读。三.可重复读可重复读是指当一个事务在执行过程中，不管读同一条数据多少次，读到的数据和第一次读取的值保持一致。此时可能发生幻读，即另一个事务插入了新数据，但没有被当前事务读取到。四.可序列化可序列化是指所有事务顺序执行，此时可避免幻读。 通过JDBC对数据库的访问，可验证数据库的事务隔离级别。 建表语句12345678CREATE TABLE Orders( O_id INT AUTO_INCREMENT, OrderPrice DOUBLE(11, 2) NOT NULL, Customer VARCHAR(50) NULL, CONSTRAINT `PRIMARY` PRIMARY KEY (O_id)); 插入一条数据1 1000 Bush 4 程序代码编写两个Java程序，开启两个事务对MySQL数据库进行访问 12345678910111213141516171819202122232425262728293031323334353637383940import java.sql.*;public class JdbcTest &#123; static final String JDBC_DRIVER = \"com.mysql.jdbc.Driver\"; static final String DB_URL = \"jdbc:mysql://localhost/database2\"; static final String USER = \"root\"; static final String PASS = \"1234\"; public static void main(String[] args) &#123; Connection connection = null; Statement statement = null; try &#123; Class.forName(JDBC_DRIVER); System.out.println(\"connecting...\"); connection = DriverManager.getConnection(DB_URL, USER, PASS); connection.setAutoCommit(false); statement = connection.createStatement(); String sql = \"select * from Orders where O_id = ?\"; PreparedStatement ps = connection.prepareStatement(sql); ps.setInt(1,1); ResultSet rs = ps.executeQuery(); while (rs.next()) &#123; System.out.println(rs.getInt(4)); &#125; rs = ps.executeQuery(); while (rs.next()) &#123; System.out.println(rs.getInt(4)); &#125; rs.close(); connection.commit(); connection.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940import java.sql.*;public class JdbcTestTwo &#123; static final String JDBC_DRIVER = \"com.mysql.jdbc.Driver\"; static final String DB_URL = \"jdbc:mysql://localhost/database2?useSSL=false\"; static final String USER = \"root\"; static final String PASS = \"1234\"; public static void main(String[] args) &#123; Connection connection = null; Statement statement = null; try &#123; Class.forName(JDBC_DRIVER); System.out.println(\"connecting...\"); connection = DriverManager.getConnection(DB_URL, USER, PASS); connection.setAutoCommit(false); statement = connection.createStatement(); String sql = \"UPDATE Orders SET col = 2 WHERE O_id = ?\"; PreparedStatement ps = connection.prepareStatement(sql); ps.setInt(1,1);// ResultSet rs = ps.executeQuery();// while (rs.next()) &#123;// System.out.println(rs.getInt(4));// &#125; int count = ps.executeUpdate();// while (rs.next()) &#123;// System.out.println(rs.getInt(4));// &#125;// rs.close(); connection.commit(); connection.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 在JdbcTest中对数据库表的同一条数据进行了两次查询，只需要在两次查询之间加一个断点，当程序暂停时，运行JdbcTest2，就可以观察到数据库中的数据变化是否符合隔离级别的定义。 读未提交将MySQL数据库全局隔离级别设置为读未提交的命令：SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; 1.运行JdbcTest，第一次查询出数据列col为4，暂停程序；2.运行JdbcTest2，执行为update语句之后，暂停，不提交；3.继续运行JdbcTest，第二次查询出数据列已经变为2； 读提交将MySQL数据库全局隔离级别设置为读提交的命令：SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED; 1.运行JdbcTest，第一次查询出数据列col为4，暂停程序；2.运行JdbcTest,第一次查询出数据列为2，暂停程序，不提交；3.继续运行JdbcTest，第二次查询出数据列仍然为4； 若第二步不暂停直接提交，则第三步查询出的数据将为2； 可重复读将MySQL数据库全局隔离级别设置为可重复读的命令：SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ; 1.运行JdbcTest，第一次查询出数据列col为4，暂停；2.运行JdbcTest2，直接提交，将数据修改为2；3.运行JdbcTest，读出数据依然为2。 可序列化将MySQL数据库全局隔离级别设置为可重复读的命令：SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE; 1.运行JdbcTest，第一次查询出数据列col为4，暂停；2.运行JdbcTest2,将一直被阻塞，直到JdbcTest恢复执行完后，它才能完成事务，或者超时抛出异常。 总结数据库的隔离级别是很重要的特性，在不同场合使用不同的隔离级别会有不同的用处。大多数情况下使用的是可重复读。通过编程来验证隔离级别，可以更好地加深对知识的理解。","tags":[]},{"title":"Dubbo服务治理环境的搭建","date":"2017-11-25T16:00:00.000Z","path":"2017/11/26/Dubbo服务治理环境的搭建/","text":"Dubbo是阿里推出的服务治理框架，被国内很多公司广泛使用。关于它的介绍可参考http://http://dubbo.io.本文主要介绍如何通过dubbo搭建服务治理环境，通过在本地搭建环境，有助于学习dubbo的源代码实现，毕竟可以边看源代码边运行调试。 Zookeeper的安装dubbo是一个服务治理服务，那它必然有一个服务注册中心。dubbo的服务注册中心可以采用multicast、zookeeper、redis或simple注册中心。比较常见的是zookeeper注册中心。 首先下载zookeeper，下载之后首先要做的是进入它的子目录conf中，将zoo_sample.cfg文件名修改为zoo.cfg，因为zookeeper启动时会使用它。之后从终端进入它所在目录，运行bin/zkServer.sh start。 之后可输入jps命令，若显示运行的进程中有QuorumPeerMain,则证明zookeeper已启动。 运行bin/zkServer.sh stop停止zookeeper。 安装tomcat下载tomcat 7。为什么是7，因为经试验tomcat 8和9两个版本在部署dubbo时都有问题。下载之后进入子目录conf中，将server.xml中配置的connector的port由8080改成其他数字，注意不要和已经被其他程序使用的端口冲突。 进入tomcat的子目录bin中，运行startup.sh（若是Windows则是startup.bat）。若启动过程不报错，且最后显示tomcat started，则证明启动成功。 运行shutdown.sh停止tomcat。 安装dubbo-admin从http://dubbo.io/或github上下载dubbo项目的源代码。dubbo-admin是dubbo的控制台，可以通过它查看和管理在dubbo上注册的服务。下载dubbo源代码之后，从终端进入dubbo文件夹。输入命令 mvn install -Dmaven.test.skip=true 将会编译整个dubbo项目，也包括dubbo-admin。 之后进入dubbo-admin的子目录target中，会发现多了一个dubbo-admin-2.5.7.war。将这个包拷到tomcat的webapps文件夹中。 按前面介绍的方法先启动zookeeper，再启动tomcat。之后在浏览器中输入localhost:8888/dubbo-admin-2.5.7。会看到如下界面。 可以看到服务提供者和调用者都是0，说明还没有服务注册到zookeeper中。 注册服务生产者和消费者为简化起见，本文采用IDE来构建服务。 首先是用intellij idea导入整个dubbo项目。 可以看到其中就有dubbo-demo项目，它主要有三个子项目构成。 其中远程调用的接口DemoService： 1234567package com.alibaba.dubbo.demo;public interface DemoService &#123; String sayHello(String name);&#125; 这个类之所以是一个单独的项目，是因为它需要被服务端和客户端同时引用。服务端会实现它： 12345678910111213141516package com.alibaba.dubbo.demo.provider;import com.alibaba.dubbo.demo.DemoService;import com.alibaba.dubbo.rpc.RpcContext;import java.text.SimpleDateFormat;import java.util.Date;public class DemoServiceImpl implements DemoService &#123; public String sayHello(String name) &#123; System.out.println(\"[\" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date()) + \"] Hello \" + name + \", request from consumer: \" + RpcContext.getContext().getRemoteAddress()); return \"Hello \" + name + \", response form provider: \" + RpcContext.getContext().getLocalAddress(); &#125;&#125; 客户端则可以通过配置，就像调用本地方法一样调用它。这也是RPC的主要目的之一。 服务端主类： 1234567891011121314151617package com.alibaba.dubbo.demo.provider;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Created by ken.lj on 2017/7/31. */public class Provider &#123; public static void main(String[] args) throws Exception &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;\"META-INF/spring/dubbo-demo-provider.xml\"&#125;); context.start(); System.in.read(); // 按任意键退出 &#125;&#125; 客户端主类： 1234567891011121314151617181920212223package com.alibaba.dubbo.demo.consumer;import com.alibaba.dubbo.demo.DemoService;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Created by ken.lj on 2017/7/31. */public class Consumer &#123; public static void main(String[] args) throws Exception &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;\"META-INF/spring/dubbo-demo-consumer.xml\"&#125;); context.start(); DemoService demoService = (DemoService) context.getBean(\"demoService\"); // 获取远程服务代理 String hello = demoService.sayHello(\"世界\"); // 执行远程方法 System.out.println(hello); // 显示调用结果 System.in.read(); &#125;&#125; 客户端最后一行代码是我加的，为了让客户端和服务端一样执行完调用之后不会退出程序。 此外服务端和客户端还需要在spring配置文件中做一些配置。服务端配置： 12345678910111213141516171819202122&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" xmlns=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\"&gt; &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name=\"demo-provider\"/&gt; &lt;!-- 使用multicast广播注册中心暴露服务地址 --&gt; &lt;dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name=\"dubbo\" port=\"20880\"/&gt; &lt;!-- 和本地bean一样实现服务 --&gt; &lt;bean id=\"demoService\" class=\"com.alibaba.dubbo.demo.provider.DemoServiceImpl\"/&gt; &lt;!-- 声明需要暴露的服务接口 --&gt; &lt;dubbo:service interface=\"com.alibaba.dubbo.demo.DemoService\" ref=\"demoService\"/&gt;&lt;/beans&gt; 客户端配置： 12345678910111213141516&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" xmlns=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\"&gt; &lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt; &lt;dubbo:application name=\"demo-consumer\"/&gt; &lt;!-- 使用multicast广播注册中心暴露发现服务地址 --&gt; &lt;dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/&gt; &lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt; &lt;dubbo:reference id=\"demoService\" check=\"false\" interface=\"com.alibaba.dubbo.demo.DemoService\"/&gt;&lt;/beans&gt; 可见配置文件中就配置了我们之前启动的zookeeper，所以程序启动之后就可以注册到zookeeper中了。 现在先运行服务端的Provider的main方法，再运行Consumer的main方法。可以看到consumer端打印出了如下内容。 可见，客户端通过调用服务端的方法，返回了字符串并打印出来了。 再看dubbo-admin的页面： 可见dubbo-admin中已经能看到注册进来的服务提供者和调用者了。 总结本文采用了比较简单的方式，即从IDE中运行dubbo项目，虽然在实际运用中需要单独部署服务，但这种方式便于学习源代码。比如可以单步跟踪，看整个dubbo执行远程调用的流程。","tags":[]},{"title":"Kotlin的新特性（一）：基本类型","date":"2017-05-29T16:00:00.000Z","path":"2017/05/30/kotlin-new-feature-1/","text":"Kotlin是一门新兴的语言，它可以运行于JVM、JavaScript以及native环境（native正在开发中）。它是由著名软件开发商Jetbrains开发，具备了很多新的特性，能够在开发中提升效率。目前已经成为Android官方支持的开发语言。Kotlin语言中的一切类型都是对象，这与Java不同。虽然Java标榜自己是一门纯粹的面向对象的语言，但由于设计的局限，还是保留了一些非面向对象的元素，最明显的就是在Java中，int、float、double、long、char等基本类型不是类，而是原生类型（primitive types）。为了补救这个缺陷，Java开发了对应的包装类型Integer、Float、Double、Long、Chararater等。Kotlin吸收了C#等语言的设计思想，将上述基本类型内置为类，它们具有自己的成员函数和成员属性。这些基本类型包括：数字类型（numbers），字符类型（characters），布尔类型（booleans）和数组类型（arrays）。 NumberKotlin中的数字类型与Java类似，包括Double、Float、Long、Int、Short、Byte等类型。如上文所述，它们都是类。 字面常量Kotlin中的字面常量（literal constants）与Java类似，Int类型支持十进制，直接用普通十进制表示即可；Long类型则需跟上L后缀，如123L表示一个Long型常数，值是123。十六进制加0x前缀，如0x0F表示十六进制数，值是15。二进制加0b前缀，如0b00001011表示二进制数，值是11。Kotlin中不支持八进制数。Kotlin支持通用的浮点数表示法，默认是Double类型，如123.5，123.5e10，如果是Float类型，需要加f或F后缀，如123.5f。 下划线分隔位数Kotlin支持在数字常量中使用下划线分隔数位。这能使位数较多的数字具有更强的可读性。 12val oneMillion = 1_000_000 val creditCardNumber = 1234_5678_9012_3456L 当Kotlin运行于JVM中时，number类型实际上是存储为JVM原生类型，当被赋值给可以为空（nullable）的引用时，Kotlin的number类型是对原生类型的包装。Kotlin中，当使用一个number型常量（val）去初始化一个不可为空的number型常量时，被初始化的常量都指向内存中同一个地址。而当初始化为一个可以为空的常量时，则会在内存中不同地址创建两个常量，并将值赋给它们。 1234567891011val a: Int = 10000 print(a === a) // Prints 'true' val boxedA: Int = a val anotherBoxedA: Int = a print(boxedA === anotherBoxedA) // !!!Prints true!!!val a: Int = 10000 print(a === a) // Prints 'true' val boxedA: Int? = a val anotherBoxedA: Int? = a print(boxedA === anotherBoxedA) // !!!Prints 'false'!!! 但即使是赋值给可以为空的常量，依然能保证它们的相等性（equality）： 1234val a: Int = 10000 print(a == a) // Prints 'true' val boxedA: Int? = a val anotherBoxedA: Int? = a print(boxedA == anotherBoxedA) // Prints 'true' 宽向扩展Kotlin中不存在隐式的宽向类型扩展，即Byte不能直接转换为Int，Int不能直接转换为Double，等等。 12val b: Byte = 1 // OK, literals are checked statically val i: Int = b // ERROR 每种number类型都能通过内置方法任意转换为另一种number类型。 Characters字符类型用Char类表示。与Java不同，它不能被直接当做数字类型使用。 1234fun check(c: Char) &#123; if (c == 1) &#123; // ERROR: incompatible types // ... &#125; &#125; 与Java一样，字符字面量使用单引号表示。转义字符使用反斜杠。特殊字符使用反斜杠加u加十六进制数表示。字符可以通过toInt()方法显式转换为Int。与number一样，字符被赋值给一个nullable引用时，唯一性（identity，内存中地址相同）是不被保证的。 Booleans用Boolean代表布尔类型，它有两个值：true和false。 布尔类型被赋值给nullable引用时，会被包装。但能保证唯一性。 12345val a: Boolean = trueprintln(a === a) // Prints 'true'val boxedA: Boolean? = aval anotherBoxedA: Boolean? = aprintln(boxedA === anotherBoxedA) // Prints ‘true’ Arrays在Java中，数组其实也是一种对象，只是我们不能显示地获得它的类型表示。在Kotlin中，用Array类来代表数组。它具有get和set方法（通过[]操作符重载了这两个函数），size属性以及其他有用的函数，如迭代器方法iterator()。 创建数组可以使用arrayOf()方法，并传递数组元素给它作为参数。例如arrayOf(1, 2, 3)就创建了一个数组[1, 2, 3]。arrayOfNulls()函数用于创建一个给定长度的数组，并用null元素填充它。 Kotlin也有特定的类代表原生类型的数组，如ByteArray、ShortArray、IntArray等。这些类与Array没有继承关系，但有对应的方法和属性集合。如IntArray有对应的工厂函数。 12val x: IntArray = intArrayOf(1, 2, 3) x[0] = x[1] + x[2] Strings字符串用String类表示。与Java一样，String是不可变类。String的元素是字符，与Java中必须使用charAtIndex()这样一个方法去访问元素不同，Kotlin中可以使用下标运算符[]去访问字符元素。String还能使用for循环很方便地访问。 123for (c in str) &#123; println(c) &#125; 字符串字面量Kotlin有两种字符串字面量：一种是可转义的字符串，它可能含有转义字符，它不能表示在多行，除非使用“+”将不同的字符串连接成一个字符串；另一种是原始（raw）字符串，能在多行表示并能包含任意文本。 转义字符串： 1val s = \"Hello, world!\\n\" 原始字符串： 123val text = \"\"\" for (c in \"foo\") print(c) \"\"\" 可以使用trimMargin()移除字符串开头和中间的空格，但空格的末尾必须跟上一个明确的分隔符，默认是“|”。 123456val text = \"\"\" |Tell me and I forget. |Teach me and I remember. |Involve me and I learn. |(Benjamin Franklin) \"\"\".trimMargin()\"\"\" 也可以显示指定分隔符，如trimMargin(“&gt;”) 字符串模板在Java中，如果我们在字符串中要加入变量，必须使用加号连接，或者使用格式化字符串。而在Kotlin中，可以使用字符串模板，这将使字符串变得更加简洁，看上去也更加舒服。字符串模板以美元符号开头，直接跟上一个变量名。 123val i = 10 val s = \"i = $i\" // evaluates to \"i = 10\"\"\"\" 或者是一个用大括号包裹的任意的表达式。 123val s = \"abc\" val str = \"$s.length is $&#123;s.length&#125;\" // evaluates to \"abc.length is 3\"\"\"\" 模板在原始字符串和转义字符串中都支持。如果你在原始字符串中需要表示美元符号的字面值，可以像下面这样使用。 123val price = \"\"\" $&#123;'$'&#125;9.99 \"\"\"","tags":[]},{"title":"Spring Boot快速搭建Web应用","date":"2017-05-29T16:00:00.000Z","path":"2017/05/30/Spring Boot快速搭建Web应用/","text":"Spring Boot是Spring家族一个新兴的成员，它能用于快速构建基于Spring的独立的生产级的应用程序。我们可以将它与Spring平台的其他项目以及第三方库自由组合。大多数基于Spring Boot的应用只需要非常少量的Spring配置。 Spring Boot的安装与其他Java库类似，Spring Boot也是打包成jar的形式，所以可以在应用中直接将spring-boot-*.jar引入到classpath中。可以像开发其他Java程序那样开发Spring Boot程序。 但是在现代的企业级Java开发中，一般会使用专门的构建工具来管理应用的整个生命周期，例如Maven和Gradle。 当使用Maven时，只需要在pom.xml中配置好相关依赖，就可以在构建过程中自动引用Spring Boot的相关jar。 用Spring Boot开发web应用学习任何新技术，都是从开发Hello world级别的程序开始的。用Spring Boot结合Maven开发Hello world级别的Web应用可谓易如反掌。 创建pom.xml文件在磁盘合适的位置新建一个项目文件夹，比如SpringBootTest。从终端进入该文件夹，创建一个pom.xml文件，输入如下内容并保存。 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 可以看到引入了spring-boot-starter-parent和spring-boot-starter-web两个starter。Spring Boot是用于简化Spring应用开发的，spring-boot-starter-parent的作用是让maven自动引入默认的一些基础依赖，spring-boot-starter-web则会让maven自动引入web应用需要的依赖。试想一下如果我们不使用Spring Boot，而是手工用Spring，Spring MVC来开发web应用，那需要配置应用上下文，Servlet上下文等，在maven中也要手工将相关依赖都引入进来。配置量会成倍增加。而用Spring Boot则非常轻松，会将配置最少化。 有了这个pom文件，就可以用maven来构建程序了，可以用mvn package来测试，会看到maven会下载很多依赖，打印出如下信息，就证明能正常构建程序。Building myproject 0.0.1-SNAPSHOTBuild Success同时，项目文件夹下出现了target文件夹，该文件夹就是构建出来的可执行文件。可以执行maven dependency:tree命令来打印出项目依赖的树形表示。 编写代码使用Maven管理应用必须使文件夹结构符合maven的约定。所以在SpringBootTest文件夹下新建如下目录结构：src/main/java进入该文件夹，创建文件Example.java，输入如下内容： 12345678910111213141516171819import org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;import org.springframework.stereotype.*;import org.springframework.web.bind.annotation.*;@RestController@EnableAutoConfigurationpublic class Example &#123; @RequestMapping(\"/\") String home() &#123; return \"Hello World!\"; &#125; public static void main(String[] args) throws Exception &#123; SpringApplication.run(Example.class, args); &#125;&#125; @RestController注解标志这个类是一个web Controller，并且是REST的访问方式。 @RequestMapping提供了“路由”信息。它告诉Spring任何HTTP请求，如果路径符合“/”就会被路由到home方法。因为是用Rest方式访问的Controller，所以直接返回Hello World！字符串，而不是重定向到一个view。 @EnableAutoConfiguration告诉Spring Boot开发者希望如何配置Spring，依据pom.xml中添加的依赖。因为spring-boot-starter-web依赖会自动添加Tomcat和Spring MVC，自动配置组件就知道开发者在开发一个web应用程序，并据此设置Spring。 main方法这里的main方法就是Java程序中标准的main方法。但该方法代理执行了Spirng Boot的SpringApplication类的run方法，从而启动了Spring去自动配置Tomcat。此处需要将Example.class作为参数传给run方法，告诉SpringApplication它是主要的Spring组件。 运行程序万事俱备只欠东风。用终端进入Spring进入到SpringBootTest（必须是pom.xml所在文件夹），输入如下命令。mvn spring-boot:run 会看到输出如下内容： 12345678910 . ____ _ __ _ _ /\\\\ / ___&apos;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &apos;_ | &apos;_| | &apos;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.3.RELEASE)…… ……… …Started Example in 3.239 seconds (JVM running for 21.929) 打开浏览器，输入localhost:8080，会看到如下输出Hello World! 总结从上文可以看出，Spring Boot可以在Spring框架的基础上快速搭建应用，例如Web应用。它可以有效减少配置量，而且可以使用内嵌的Web容器，可以高效地开发和测试程序。","tags":[]},{"title":"RabbitMQ的Java客户端（一）","date":"2017-05-29T15:50:13.000Z","path":"2017/05/29/RabbitMQ-HelloWorld/","text":"RabbitMQ是一个常用的消息队列中间件，它能接收并转发消息。在消息通信模型中，系统可分为三部分：生产者，消息服务器和消费者。简单地说，生产者程序产生消息，发布到消息服务器；消费者程序连接到消息服务器，订阅到队列中。每当消息到达特定等队列时，RabbitMQ会将其发送给其中一个订阅/监听的消费者。在RabbitMQ中，生产者并不是直接将消息交给某个消息队列的，而是将消息发送给交换器，发送时会指定投递的规则，这些规则称为路由键。交换器中最简单等一种就是direct交换器。它是一个以空白字符串为名称等默认交换器。当声明一个队列时，默认绑定到direct交换器。direct交换器的规则非常简单：如果路由键（队列名）匹配的话，消息就被投递到对应等队列。如下图所示 Java客户端Java是当今流行的服务器应用程序开发语言。RabbitMQ也提供了Java的客户端SDK。用Java实现direct交换器中的生产者示例代码： 123456789101112131415161718192021222324252627282930package com.wts.helloworld;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;/** * Created by weitaosheng on 2017/5/1. */public class Send &#123; private final static String QUEUE_NAME = \"hello\"; public static void main(String[] args) throws Exception &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\"localhost\"); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); String message = \"Hello World!\"; channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes()); System.out.println(\" [x] Sent '\" + message + \"'\"); channel.close(); connection.close(); &#125;&#125; 创建一个消息生产者等步骤： 新建连接工厂； 绑定RabbitMQ服务器地址（默认为localhost，端口5672）； 获取连接； 建立频道（channel）； 声明队列； 发布消息。 关闭频道； 关闭连接。 客户端示例代码： 1234567891011121314151617181920212223242526272829303132import com.rabbitmq.client.*;import java.io.IOException;/** * Created by weitaosheng on 2017/5/1. */public class Recv &#123; private final static String QUEUE_NAME = \"hello\"; public static void main(String[] args) throws Exception &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\"localhost\"); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); System.out.println(\" [*] Waiting for message. To exit press CTRL+C\"); Consumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, \"UTF-8\"); System.out.println(\" [x] Received '\" + message + \"'\"); &#125; &#125;; channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 创建客户端并订阅队列的步骤： 新建连接工厂； 绑定RabbitMQ服务器地址（默认为localhost，端口5672）； 获取连接； 建立频道（channel）； 声明队列； 声明一个消息消费者，本示例中是用一个匿名内部类来扩展了DefaltConsumer类，并重写了handleDelivery方法，该方法定义了接收到消息时进行等处理。 以下是客户端SDK关键的类和方法：ConnectionFactory：连接工厂关键类，是客户端访问RabbitMQ服务器必须要先构造的类。从Connection的源代码可以看出，ConnectionFactory没有显示定义构造函数，因此使用的是编译器自动生成的默认构造函数。获取连接的函数 1234public Connection newConnection() throws IOException, TimeoutException &#123; return newConnection(this.sharedExecutor, Collections.singletonList(new Address(getHost(), getPort())));&#125; 查看源码，sharedExecutor是一个ExecutorService的实例。此处为null，也就是没有使用线程池。连接时还需要地址和端口。1Channel createChannel() throws IOException; createChannel：生成一个Channel类的实例。Connection是一条真实的TCP连接，Channel是Connection内等一条虚拟连接，它在RabbitMQ中会自动生成唯一的ID。通过一条TCP连接内多个虚拟连接的方式，可以提高性能，节约系统资源，因为TCP连接的创建和销毁是非常昂贵的。Queue.DeclareOk queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map arguments) throws IOException;queueDeclare：声明队列。它的几个参数的含义是：队列名，是否持久化，是否是限制性等队列（仅限于此次连接），是否自动删除消息，其他参数1void basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body) throws IOException; basicPublish：发布消息，几个参数是：交换器名，路由键，是否设置了mandatory参数，消息参数，消息体（用byte数组装载） Consumer是代表消费者等接口，DefaultConsumer是Consumer接口的一个默认实现。一般定义消费者只需扩展这个类即可。1234public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) handleDelivery：消费者接收到消息时的回调方法。它的几个参数是：消费者标签，『信封』信息，消息头内容，消息体","tags":[]},{"title":"Java中synchronized关键字的研究","date":"2017-03-01T12:23:47.000Z","path":"2017/03/01/Java-synchronized/","text":"在Java中，每一个线程都有一个内部锁。当我们使用synchronized关键字时，就是利用这个内部锁来实现线程对某个对象的锁定控制。那么，如果某个对象中有两个方法，方法一和方法二都使用了synchronized关键字。如果线程一执行该对象的方法一，线程二执行该对象的方法二。如果线程1一直不释放该对象的内部锁的话，那么线程二应该无法执行该对象的方法二。下面就用代码来验证一下。首先，定义一个Task类1234567891011121314151617181920212223package corejava.chapter14;public class TaskC &#123; public synchronized void method1() throws InterruptedException &#123; while (true) &#123; System.out.println(\"我是方法1\"); Thread.sleep(10000); &#125; &#125; public synchronized void method2() throws InterruptedException &#123; while (true) &#123; System.out.println(\"我是方法2\"); Thread.sleep(10000); &#125; &#125;&#125; method1每隔10秒就会输出一句“我是方法1”。method2每隔10秒就会输出一句“我是方法2”。两个方法都使用了synchronized关键字。 再定义两个执行类ExecutorC1和Executor2。 1234567891011121314151617181920package corejava.chapter14;public class ExecutorC1 implements Runnable &#123; private TaskC taskC; public ExecutorC1(TaskC taskC) &#123; this.taskC = taskC; &#125; @Override public void run() &#123; try &#123; taskC.method1(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 123456789101112131415161718192021package corejava.chapter14;public class ExecutorC2 implements Runnable &#123; private TaskC taskC; public ExecutorC2(TaskC taskC) &#123; this.taskC = taskC; &#125; @Override public void run() &#123; try &#123; taskC.method2(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行对象1和执行对象2都使用同一个taskC去实例化，这样他们之间就会存在竞争。当thread1执行taskC的method1时，会一直持有taskC的内部锁，因此thread2将一直处于阻塞状态。 下面是运行输出结果 可见，确实如我们所料，虽然两个线程要执行的是不同的方法，但因为线程1一直“霸占”着内部锁，所以线程2始终在阻塞状态，得不到执行。 所以，如果我们在对某个类要使用synchronized关键字进行锁定控制时，一定要牢记它使用的是该类的内部锁。它是唯一的。当多个方法都用它来进行控制时，一定要考虑这一点。","tags":[]},{"title":"Java集合中的ArrayList类（一）：构造实例和添加元素","date":"2017-02-28T16:59:03.000Z","path":"2017/03/01/ArrayList/","text":"ArrayList有三个构造器，分别是无参构造器，传入一个整形参数的构造器，以及传入一个Collection实例的构造器。本文主要介绍前两种构造器。 无参构造器示例代码： 123456789public class ArrayListTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; strings = new ArrayList&lt;&gt;(); strings.add(\"abc\"); &#125;&#125; 下面看调用构造器以及添加元素的代码 1234567/** * 用初始的10的容量大小构造一个空的list */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 从上述构造器可以看出，无参构造器只是很简单将常量DEFAULTCAPACITY_EMPTY_ELEMENTDATA赋给成员变量elementData。这个成员变量和常量如下所示： 123456789101112131415/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */transient Object[] elementData; // non-private to simplify nested class access 从注释可以看出，DEFAULTCAPACITY_EMPTY_ELEMENTDATA是一个空的数组实例，用来作为默认大小的空List。它与EMPTY_ELEMENTDATA同时存在，是为了当第一个元素被添加到list中时，能算出要扩展多大的容量。 elementData是ArrayList中用于实际存储元素的数组。一个ArrayList实例的容量就是这个数组的长度。任何调用了默认构造器生成的ArrayList实例，都执行了elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA，当第一个元素被添加到list中时，都会被扩展到默认的容量大小，即DEFAULT_CAPACITY（10）。 末尾添加元素的函数： 12345678910111213/*** Appends the specified element to the end of this list.** @param e element to be appended to this list* @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;)*/public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! // 扩容之后将新增的元素加到末尾，同时将list的size加一。 elementData[size++] = e; return true;&#125; 该方法首先调用了ensureCapacityInternal函数，用于确保容量足以添加一个元素。ensureCapacityInternal方法： 123456789private void ensureCapacityInternal(int minCapacity) &#123; // 插入“abc”时，minCapacity为1 // 当调用无参构造器时，初始存储元素的数组是DEFAULTCAPACITY_EMPTY_ELEMENTDATA if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 比较参数和默认容量大小，取大者作为扩展多容量 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); // minCapacity变为10 &#125; ensureExplicitCapacity(minCapacity);&#125; 之后调用了ensureExplicitCapacity函数，继续扩展容量大操作： 1234567private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // 检查目标容量是否大于当前数组的实际长度 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; 上述方法继续调用grow函数，完成扩容： 1234567891011121314151617181920/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 容量扩充增量为当前数组容量大50% int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 若扩充后仍达不到目标容量，则直接使用目标容量作为新容量 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 若超过最大容量，则调用hugeCapacity函数 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 调用工具函数扩容，末尾用null补全 elementData = Arrays.copyOf(elementData, newCapacity);&#125; 从注释可知，该方法增长容量以确保list至少能保存传入参数大小数量多元素。之后，就可以插入元素“abc”。插入之后，list的size为1，容量为10.","tags":[]},{"title":"Java IO 中的PushbackInputStream类","date":"2017-02-28T16:59:03.000Z","path":"2017/03/01/PushbackInputStream/","text":"PushbackInputstream类是Java IO中的一个较特别的类，因为它可以将读出的字节再推回流中。这也就是它的名字中Pushback的由来。下面首先介绍一下它的基本用法，再分析一下它的源代码。 使用方法首先需要构造一个PushbackInputStream对象，这个对象需要传入一个InputStream实例作为参数。之后从该InputStream绑定的数据源（例如一个文件、或者网络流）读入数据，然后将读出的数据再推回PushBackInputStream中。如下所示 1234567891011121314public class PushbackInputStreamTest &#123; public static void main(String[] args) throws Exception&#123; PushbackInputStream inputStream = new PushbackInputStream( new FileInputStream(\"input.txt\")); int data = inputStream.read(); System.out.println(data); inputStream.unread(data); data = inputStream.read(); System.out.println(data); &#125;&#125; 文件中保存着一个字符串abcdefg。输出如下： Read before push back: 97Read after push back: 97 可见，我们读出了一个字符a（它的ascii码是97），之后又成功推回了流中。 如果我们需要一次推回多个字符，则需要在构造PushbackInputStream实例时传入一个整型参数，用于指定每次推回多最大字节数。如下所示： 12345678910111213141516171819public class PushbackInputStreamTest &#123; public static void main(String[] args) throws Exception&#123; PushbackInputStream input = new PushbackInputStream( new FileInputStream(\"input.txt\"), 10); byte[] bytes = new byte[10]; int r = input.read(bytes); for (byte b : bytes) &#123; System.out.println(b); &#125; input.unread(bytes); r = input.read(bytes); for (byte b : bytes) &#123; System.out.println(b); &#125; &#125;&#125; 输出：Read before push back:979899100101102103000Read after push back:979899100101102103000 可见，我们可以一次读入最多10个字节（因为数据只有7个字节，所以剩余字节为0. 如果推回多字节大于构造函数中指定的最大字节数，则会发生异常： java.io.IOException: Push back buffer is full 下面分析一下PushbackInputStream的源代码 成员变量12345678910/** * 缓冲区，被推回的字节将会保存在这里 */protected byte[] buf;/** * 从缓冲区读取数据时的位置，也就是读取被推回的数据时的下标。当缓冲区为空时，pos为buf.length（即没有推回数据，故不能从缓冲区读取）；当缓冲区所有字节均有数据时，则pos为0 * */protected int pos; 构造函数12345678910111213141516171819/** * 通过指定size的缓冲数组以及一个InputStream实例，来构造一个PushbackInputStream对象 */public PushbackInputStream(InputStream in, int size) &#123; super(in); if (size &lt;= 0) &#123; throw new IllegalArgumentException(\"size &lt;= 0\"); &#125; this.buf = new byte[size]; this.pos = size;&#125;/** * 若不指定缓冲区大小，则默认为1，即每次只能推回一个字节 */public PushbackInputStream(InputStream in) &#123; this(in, 1);&#125; 读取数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 读取数据，若缓冲区有数据，则从缓冲区的pos位置开始读取；若缓冲区无数据，则调用超类的read方法读取数据 */public int read() throws IOException &#123; // 确保流没有关闭 ensureOpen(); if (pos &lt; buf.length) &#123; return buf[pos++] &amp; 0xff; &#125; return super.read();&#125;/** * 将数据读入一个byte数组中，参数off是目标数组中的起始偏移量，参数len是读入数据的最大字节数 */public int read(byte[] b, int off, int len) throws IOException &#123; ensureOpen(); // 校验参数是否合法，b不能为null，off不能为负，且读入的最大字节数不能超过数组所能接受的最大字节数。 if (b == null) &#123; throw new NullPointerException(); &#125; else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) &#123; throw new IndexOutOfBoundsException(); &#125; else if (len == 0) &#123; return 0; &#125; // 计算缓冲数组中的数据字节数 int avail = buf.length - pos; // 从缓冲区中读取数据 if (avail &gt; 0) &#123; if (len &lt; avail) &#123; avail = len; &#125; System.arraycopy(buf, pos, b, off, avail); pos += avail; off += avail; len -= avail; &#125; // 若要读取的数据数超过了缓冲区的数据数，则读完被推回的数据后，继续从包裹的InputStream中读取数据 if (len &gt; 0) &#123; len = super.read(b, off, len); if (len == -1) &#123; // 缓冲区无数据，包裹的InputStream也没有数据 return avail == 0 ? -1 : avail; &#125; return avail + len; &#125; return avail;&#125; 推回数据12345678910111213141516171819202122232425/** * 推回一个字节数据，即将它拷贝到本类的缓冲数组中 */public void unread(int b) throws IOException &#123; ensureOpen(); // pos为0说明缓冲数组已满 if (pos == 0) &#123; throw new IOException(\"Push back buffer is full\"); &#125; // 从后往前赋值 buf[--pos] = (byte)b;&#125;/** * 推回字节数组的一部分到缓冲数组中， */public void unread(byte[] b, int off, int len) throws IOException &#123; ensureOpen(); if (len &gt; pos) &#123; throw new IOException(\"Push back buffer is full\"); &#125; pos -= len; System.arraycopy(b, off, buf, pos, len);&#125; 以上就是这个类的主要方法。我们可以看出，当单个推回数据时，是逆序插入缓冲数组，同时读取数据时，是正序读出。所以是后入先出。","tags":[]},{"title":"《Java核心技术（英文版）》读书笔记：Object类的equals方法","date":"2017-02-28T16:59:03.000Z","path":"2017/03/01/hello-world/","text":"Object类是Java中的一个全局超类——每一个Java类都扩展了它。但是你不必显示地如下声明： 1public class Employee extends Object equals方法引用同一equals方法是Object类中用于判断一个对象和另一个对象是否相等的方法。在Object类中的实现如下： 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 从源代码可知，该实现是检查两个对象的引用是否相等，也即是检查两个对象是否指向Java堆中的同一个对象。这是因为，如果两个对象的引用指向同一个Java堆中的对象，则这两个对象必然是相等的。对极少数类的对象来说，这个实现已经足够了。例如两个PrintStream对象。 状态相等如上文所述，对大多数类来说，Object中的equals实现是不够用的。因为很多时候，我们认为两个对象相等是基于它们具有相同的状态（即对象的属性，field）。例如，两个Employee对象，如果它们具有相同的姓名（name），工资（salary）和雇佣日期（hire day），那它们就是相等的。它的实现如下： 12345678910111213141516public class Employee &#123; ... public boolean equals(Object otherObject) &#123; if (this == otherObject) return true; if (otherObject == null) return false; if (getClass() ！= otherObject.getClass()) return false; Employee other = (Employee) otherObject; return name.equals(other.name) &amp;&amp; salary == other.salary; &amp;&amp; hireDay.equals(other.hireDay); &#125;&#125; 上面的代码中，首先判断两个对象是否同一，其次判断被比较对象是否为null，再次比较两个对象所属的类是否相同（在此处，假定必须类相同才有可能相等），最后比较各个状态是否相等。注意如果状态也是对象的话，则会递归调用它们的equals方法。 这里要注意的是，Employee对象的name和hireDay等状态是有可能为null的，为了确保在这种情况下程序也是正确的，可以使用Objects.equals方法。调用Objects.equals(a, b)，若两个参数都是null返回true，若其中一个为null返回false，以上都不成立则调用a.equals(b)。因此，上面方法的最后一条语句可修改为 123return Objects.equals(name, other.name) &amp;&amp; salary == other.salary; &amp;&amp; Objects.equals(hireDay, other.hireDay); 当在扩展类中定义了equals方法时，须首先调用超类的equals方法，如果返回false，则两个对象不可能相等。若返回true，即是超类定义的状态相等。则继续比较子类定义的状态。","tags":[]}]