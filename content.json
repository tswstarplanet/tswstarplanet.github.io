[{"title":"Kotlin的新特性（一）：基本类型","date":"2017-05-29T16:00:00.000Z","path":"2017/05/30/kotlin-new-feature-1/","text":"Kotlin是一门新兴的语言，它可以运行于JVM、JavaScript以及native环境（native正在开发中）。它是由著名软件开发商Jetbrains开发，具备了很多新的特性，能够在开发中提升效率。目前已经成为Android官方支持的开发语言。Kotlin语言中的一切类型都是对象，这与Java不同。虽然Java标榜自己是一门纯粹的面向对象的语言，但由于设计的局限，还是保留了一些非面向对象的元素，最明显的就是在Java中，int、float、double、long、char等基本类型不是类，而是原生类型（primitive types）。为了补救这个缺陷，Java开发了对应的包装类型Integer、Float、Double、Long、Chararater等。Kotlin吸收了C#等语言的设计思想，将上述基本类型内置为类，它们具有自己的成员函数和成员属性。这些基本类型包括：数字类型（numbers），字符类型（characters），布尔类型（booleans）和数组类型（arrays）。 NumberKotlin中的数字类型与Java类似，包括Double、Float、Long、Int、Short、Byte等类型。如上文所述，它们都是类。 字面常量Kotlin中的字面常量（literal constants）与Java类似，Int类型支持十进制，直接用普通十进制表示即可；Long类型则需跟上L后缀，如123L表示一个Long型常数，值是123。十六进制加0x前缀，如0x0F表示十六进制数，值是15。二进制加0b前缀，如0b00001011表示二进制数，值是11。Kotlin中不支持八进制数。Kotlin支持通用的浮点数表示法，默认是Double类型，如123.5，123.5e10，如果是Float类型，需要加f或F后缀，如123.5f。 下划线分隔位数Kotlin支持在数字常量中使用下划线分隔数位。这能使位数较多的数字具有更强的可读性。 12val oneMillion = 1_000_000 val creditCardNumber = 1234_5678_9012_3456L 当Kotlin运行于JVM中时，number类型实际上是存储为JVM原生类型，当被赋值给可以为空（nullable）的引用时，Kotlin的number类型是对原生类型的包装。Kotlin中，当使用一个number型常量（val）去初始化一个不可为空的number型常量时，被初始化的常量都指向内存中同一个地址。而当初始化为一个可以为空的常量时，则会在内存中不同地址创建两个常量，并将值赋给它们。 1234567891011val a: Int = 10000 print(a === a) // Prints 'true' val boxedA: Int = a val anotherBoxedA: Int = a print(boxedA === anotherBoxedA) // !!!Prints true!!!val a: Int = 10000 print(a === a) // Prints 'true' val boxedA: Int? = a val anotherBoxedA: Int? = a print(boxedA === anotherBoxedA) // !!!Prints 'false'!!! 但即使是赋值给可以为空的常量，依然能保证它们的相等性（equality）： 1234val a: Int = 10000 print(a == a) // Prints 'true' val boxedA: Int? = a val anotherBoxedA: Int? = a print(boxedA == anotherBoxedA) // Prints 'true' 宽向扩展Kotlin中不存在隐式的宽向类型扩展，即Byte不能直接转换为Int，Int不能直接转换为Double，等等。 12val b: Byte = 1 // OK, literals are checked statically val i: Int = b // ERROR 每种number类型都能通过内置方法任意转换为另一种number类型。 Characters字符类型用Char类表示。与Java不同，它不能被直接当做数字类型使用。 1234fun check(c: Char) &#123; if (c == 1) &#123; // ERROR: incompatible types // ... &#125; &#125; 与Java一样，字符字面量使用单引号表示。转义字符使用反斜杠。特殊字符使用反斜杠加u加十六进制数表示。字符可以通过toInt()方法显式转换为Int。与number一样，字符被赋值给一个nullable引用时，唯一性（identity，内存中地址相同）是不被保证的。 Booleans用Boolean代表布尔类型，它有两个值：true和false。 布尔类型被赋值给nullable引用时，会被包装。但能保证唯一性。 12345val a: Boolean = trueprintln(a === a) // Prints 'true'val boxedA: Boolean? = aval anotherBoxedA: Boolean? = aprintln(boxedA === anotherBoxedA) // Prints ‘true’ Arrays在Java中，数组其实也是一种对象，只是我们不能显示地获得它的类型表示。在Kotlin中，用Array类来代表数组。它具有get和set方法（通过[]操作符重载了这两个函数），size属性以及其他有用的函数，如迭代器方法iterator()。 创建数组可以使用arrayOf()方法，并传递数组元素给它作为参数。例如arrayOf(1, 2, 3)就创建了一个数组[1, 2, 3]。arrayOfNulls()函数用于创建一个给定长度的数组，并用null元素填充它。 Kotlin也有特定的类代表原生类型的数组，如ByteArray、ShortArray、IntArray等。这些类与Array没有继承关系，但有对应的方法和属性集合。如IntArray有对应的工厂函数。 12val x: IntArray = intArrayOf(1, 2, 3) x[0] = x[1] + x[2] Strings 字符串用String类表示。与Java一样，String是不可变类。String的元素是字符，与Java中必须使用charAtIndex()这样一个方法去访问元素不同，Kotlin中可以使用下标运算符[]去访问字符元素。String还能使用for循环很方便地访问。 123for (c in str) &#123; println(c) &#125; 字符串字面量Kotlin有两种字符串字面量：一种是可转义的字符串，它可能含有转义字符，它不能表示在多行，除非使用“+”将不同的字符串连接成一个字符串；另一种是原始（raw）字符串，能在多行表示并能包含任意文本。 转义字符串： 1val s = \"Hello, world!\\n\" 原始字符串： 123val text = \"\"\" for (c in \"foo\") print(c) \"\"\" 可以使用trimMargin()移除字符串开头和中间的空格，但空格的末尾必须跟上一个明确的分隔符，默认是“|”。 123456val text = \"\"\" |Tell me and I forget. |Teach me and I remember. |Involve me and I learn. |(Benjamin Franklin) \"\"\".trimMargin()\"\"\" 也可以显示指定分隔符，如trimMargin(“&gt;”) 字符串模板在Java中，如果我们在字符串中要加入变量，必须使用加号连接，或者使用格式化字符串。而在Kotlin中，可以使用字符串模板，这将使字符串变得更加简洁，看上去也更加舒服。字符串模板以美元符号开头，直接跟上一个变量名。 123val i = 10 val s = \"i = $i\" // evaluates to \"i = 10\"\"\"\" 或者是一个用大括号包裹的任意的表达式。 123val s = \"abc\" val str = \"$s.length is $&#123;s.length&#125;\" // evaluates to \"abc.length is 3\"\"\"\" 模板在原始字符串和转义字符串中都支持。如果你在原始字符串中需要表示美元符号的字面值，可以像下面这样使用。 123val price = \"\"\" $&#123;'$'&#125;9.99 \"\"\"","tags":[]},{"title":"RabbitMQ的Java客户端（一）","date":"2017-05-29T15:50:13.000Z","path":"2017/05/29/RabbitMQ-HelloWorld/","text":"RabbitMQ是一个常用的消息队列中间件，它能接收并转发消息。在消息通信模型中，系统可分为三部分：生产者，消息服务器和消费者。简单地说，生产者程序产生消息，发布到消息服务器；消费者程序连接到消息服务器，订阅到队列中。每当消息到达特定等队列时，RabbitMQ会将其发送给其中一个订阅/监听的消费者。在RabbitMQ中，生产者并不是直接将消息交给某个消息队列的，而是将消息发送给交换器，发送时会指定投递的规则，这些规则称为路由键。交换器中最简单等一种就是direct交换器。它是一个以空白字符串为名称等默认交换器。当声明一个队列时，默认绑定到direct交换器。direct交换器的规则非常简单：如果路由键（队列名）匹配的话，消息就被投递到对应等队列。如下图所示 Java客户端Java是当今流行的服务器应用程序开发语言。RabbitMQ也提供了Java的客户端SDK。用Java实现direct交换器中的生产者示例代码： 123456789101112131415161718192021222324252627282930package com.wts.helloworld;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;/** * Created by weitaosheng on 2017/5/1. */public class Send &#123; private final static String QUEUE_NAME = \"hello\"; public static void main(String[] args) throws Exception &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\"localhost\"); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); String message = \"Hello World!\"; channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes()); System.out.println(\" [x] Sent '\" + message + \"'\"); channel.close(); connection.close(); &#125;&#125; 创建一个消息生产者等步骤： 新建连接工厂； 绑定RabbitMQ服务器地址（默认为localhost，端口5672）； 获取连接； 建立频道（channel）； 声明队列； 发布消息。 关闭频道； 关闭连接。 客户端示例代码： 1234567891011121314151617181920212223242526272829303132import com.rabbitmq.client.*;import java.io.IOException;/** * Created by weitaosheng on 2017/5/1. */public class Recv &#123; private final static String QUEUE_NAME = \"hello\"; public static void main(String[] args) throws Exception &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\"localhost\"); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); System.out.println(\" [*] Waiting for message. To exit press CTRL+C\"); Consumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, \"UTF-8\"); System.out.println(\" [x] Received '\" + message + \"'\"); &#125; &#125;; channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 创建客户端并订阅队列的步骤： 新建连接工厂； 绑定RabbitMQ服务器地址（默认为localhost，端口5672）； 获取连接； 建立频道（channel）； 声明队列； 声明一个消息消费者，本示例中是用一个匿名内部类来扩展了DefaltConsumer类，并重写了handleDelivery方法，该方法定义了接收到消息时进行等处理。 以下是客户端SDK关键的类和方法：ConnectionFactory：连接工厂关键类，是客户端访问RabbitMQ服务器必须要先构造的类。从Connection的源代码可以看出，ConnectionFactory没有显示定义构造函数，因此使用的是编译器自动生成的默认构造函数。获取连接的函数 1234public Connection newConnection() throws IOException, TimeoutException &#123; return newConnection(this.sharedExecutor, Collections.singletonList(new Address(getHost(), getPort())));&#125; 查看源码，sharedExecutor是一个ExecutorService的实例。此处为null，也就是没有使用线程池。连接时还需要地址和端口。1Channel createChannel() throws IOException; createChannel：生成一个Channel类的实例。Connection是一条真实的TCP连接，Channel是Connection内等一条虚拟连接，它在RabbitMQ中会自动生成唯一的ID。通过一条TCP连接内多个虚拟连接的方式，可以提高性能，节约系统资源，因为TCP连接的创建和销毁是非常昂贵的。Queue.DeclareOk queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map arguments) throws IOException;queueDeclare：声明队列。它的几个参数的含义是：队列名，是否持久化，是否是限制性等队列（仅限于此次连接），是否自动删除消息，其他参数1void basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body) throws IOException; basicPublish：发布消息，几个参数是：交换器名，路由键，是否设置了mandatory参数，消息参数，消息体（用byte数组装载） Consumer是代表消费者等接口，DefaultConsumer是Consumer接口的一个默认实现。一般定义消费者只需扩展这个类即可。1234public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) handleDelivery：消费者接收到消息时的回调方法。它的几个参数是：消费者标签，『信封』信息，消息头内容，消息体","tags":[]},{"title":"Java中synchronized关键字的研究","date":"2017-03-01T12:23:47.000Z","path":"2017/03/01/Java-synchronized/","text":"在Java中，每一个线程都有一个内部锁。当我们使用synchronized关键字时，就是利用这个内部锁来实现线程对某个对象的锁定控制。那么，如果某个对象中有两个方法，方法一和方法二都使用了synchronized关键字。如果线程一执行该对象的方法一，线程二执行该对象的方法二。如果线程1一直不释放该对象的内部锁的话，那么线程二应该无法执行该对象的方法二。下面就用代码来验证一下。首先，定义一个Task类1234567891011121314151617181920212223package corejava.chapter14;public class TaskC &#123; public synchronized void method1() throws InterruptedException &#123; while (true) &#123; System.out.println(\"我是方法1\"); Thread.sleep(10000); &#125; &#125; public synchronized void method2() throws InterruptedException &#123; while (true) &#123; System.out.println(\"我是方法2\"); Thread.sleep(10000); &#125; &#125;&#125; method1每隔10秒就会输出一句“我是方法1”。method2每隔10秒就会输出一句“我是方法2”。两个方法都使用了synchronized关键字。 再定义两个执行类ExecutorC1和Executor2。 1234567891011121314151617181920package corejava.chapter14;public class ExecutorC1 implements Runnable &#123; private TaskC taskC; public ExecutorC1(TaskC taskC) &#123; this.taskC = taskC; &#125; @Override public void run() &#123; try &#123; taskC.method1(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 123456789101112131415161718192021package corejava.chapter14;public class ExecutorC2 implements Runnable &#123; private TaskC taskC; public ExecutorC2(TaskC taskC) &#123; this.taskC = taskC; &#125; @Override public void run() &#123; try &#123; taskC.method2(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行对象1和执行对象2都使用同一个taskC去实例化，这样他们之间就会存在竞争。当thread1执行taskC的method1时，会一直持有taskC的内部锁，因此thread2将一直处于阻塞状态。 下面是运行输出结果 可见，确实如我们所料，虽然两个线程要执行的是不同的方法，但因为线程1一直“霸占”着内部锁，所以线程2始终在阻塞状态，得不到执行。 所以，如果我们在对某个类要使用synchronized关键字进行锁定控制时，一定要牢记它使用的是该类的内部锁。它是唯一的。当多个方法都用它来进行控制时，一定要考虑这一点。","tags":[]},{"title":"Java集合中的ArrayList类（一）：构造实例和添加元素","date":"2017-02-28T16:59:03.000Z","path":"2017/03/01/ArrayList/","text":"ArrayList有三个构造器，分别是无参构造器，传入一个整形参数的构造器，以及传入一个Collection实例的构造器。本文主要介绍前两种构造器。 无参构造器示例代码： 123456789public class ArrayListTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; strings = new ArrayList&lt;&gt;(); strings.add(\"abc\"); &#125;&#125; 下面看调用构造器以及添加元素的代码 1234567/** * 用初始的10的容量大小构造一个空的list */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 从上述构造器可以看出，无参构造器只是很简单将常量DEFAULTCAPACITY_EMPTY_ELEMENTDATA赋给成员变量elementData。这个成员变量和常量如下所示： 123456789101112131415/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */transient Object[] elementData; // non-private to simplify nested class access 从注释可以看出，DEFAULTCAPACITY_EMPTY_ELEMENTDATA是一个空的数组实例，用来作为默认大小的空List。它与EMPTY_ELEMENTDATA同时存在，是为了当第一个元素被添加到list中时，能算出要扩展多大的容量。 elementData是ArrayList中用于实际存储元素的数组。一个ArrayList实例的容量就是这个数组的长度。任何调用了默认构造器生成的ArrayList实例，都执行了elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA，当第一个元素被添加到list中时，都会被扩展到默认的容量大小，即DEFAULT_CAPACITY（10）。 末尾添加元素的函数： 12345678910111213/*** Appends the specified element to the end of this list.** @param e element to be appended to this list* @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;)*/public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! // 扩容之后将新增的元素加到末尾，同时将list的size加一。 elementData[size++] = e; return true;&#125; 该方法首先调用了ensureCapacityInternal函数，用于确保容量足以添加一个元素。ensureCapacityInternal方法： 123456789private void ensureCapacityInternal(int minCapacity) &#123; // 插入“abc”时，minCapacity为1 // 当调用无参构造器时，初始存储元素的数组是DEFAULTCAPACITY_EMPTY_ELEMENTDATA if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 比较参数和默认容量大小，取大者作为扩展多容量 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); // minCapacity变为10 &#125; ensureExplicitCapacity(minCapacity);&#125; 之后调用了ensureExplicitCapacity函数，继续扩展容量大操作： 1234567private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // 检查目标容量是否大于当前数组的实际长度 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; 上述方法继续调用grow函数，完成扩容： 1234567891011121314151617181920/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 容量扩充增量为当前数组容量大50% int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 若扩充后仍达不到目标容量，则直接使用目标容量作为新容量 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 若超过最大容量，则调用hugeCapacity函数 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 调用工具函数扩容，末尾用null补全 elementData = Arrays.copyOf(elementData, newCapacity);&#125; 从注释可知，该方法增长容量以确保list至少能保存传入参数大小数量多元素。之后，就可以插入元素“abc”。插入之后，list的size为1，容量为10.","tags":[]},{"title":"Java IO 中的PushbackInputStream类","date":"2017-02-28T16:59:03.000Z","path":"2017/03/01/PushbackInputStream/","text":"PushbackInputstream类是Java IO中的一个较特别的类，因为它可以将读出的字节再推回流中。这也就是它的名字中Pushback的由来。下面首先介绍一下它的基本用法，再分析一下它的源代码。 使用方法首先需要构造一个PushbackInputStream对象，这个对象需要传入一个InputStream实例作为参数。之后从该InputStream绑定的数据源（例如一个文件、或者网络流）读入数据，然后将读出的数据再推回PushBackInputStream中。如下所示 1234567891011121314public class PushbackInputStreamTest &#123; public static void main(String[] args) throws Exception&#123; PushbackInputStream inputStream = new PushbackInputStream( new FileInputStream(\"input.txt\")); int data = inputStream.read(); System.out.println(data); inputStream.unread(data); data = inputStream.read(); System.out.println(data); &#125;&#125; 文件中保存着一个字符串abcdefg。输出如下： Read before push back: 97Read after push back: 97 可见，我们读出了一个字符a（它的ascii码是97），之后又成功推回了流中。 如果我们需要一次推回多个字符，则需要在构造PushbackInputStream实例时传入一个整型参数，用于指定每次推回多最大字节数。如下所示： 12345678910111213141516171819public class PushbackInputStreamTest &#123; public static void main(String[] args) throws Exception&#123; PushbackInputStream input = new PushbackInputStream( new FileInputStream(\"input.txt\"), 10); byte[] bytes = new byte[10]; int r = input.read(bytes); for (byte b : bytes) &#123; System.out.println(b); &#125; input.unread(bytes); r = input.read(bytes); for (byte b : bytes) &#123; System.out.println(b); &#125; &#125;&#125; 输出：Read before push back:979899100101102103000Read after push back:979899100101102103000 可见，我们可以一次读入最多10个字节（因为数据只有7个字节，所以剩余字节为0. 如果推回多字节大于构造函数中指定的最大字节数，则会发生异常： java.io.IOException: Push back buffer is full 下面分析一下PushbackInputStream的源代码 成员变量12345678910/** * 缓冲区，被推回的字节将会保存在这里 */protected byte[] buf;/** * 从缓冲区读取数据时的位置，也就是读取被推回的数据时的下标。当缓冲区为空时，pos为buf.length（即没有推回数据，故不能从缓冲区读取）；当缓冲区所有字节均有数据时，则pos为0 * */protected int pos; 构造函数12345678910111213141516171819/** * 通过指定size的缓冲数组以及一个InputStream实例，来构造一个PushbackInputStream对象 */public PushbackInputStream(InputStream in, int size) &#123; super(in); if (size &lt;= 0) &#123; throw new IllegalArgumentException(\"size &lt;= 0\"); &#125; this.buf = new byte[size]; this.pos = size;&#125;/** * 若不指定缓冲区大小，则默认为1，即每次只能推回一个字节 */public PushbackInputStream(InputStream in) &#123; this(in, 1);&#125; 读取数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 读取数据，若缓冲区有数据，则从缓冲区的pos位置开始读取；若缓冲区无数据，则调用超类的read方法读取数据 */public int read() throws IOException &#123; // 确保流没有关闭 ensureOpen(); if (pos &lt; buf.length) &#123; return buf[pos++] &amp; 0xff; &#125; return super.read();&#125;/** * 将数据读入一个byte数组中，参数off是目标数组中的起始偏移量，参数len是读入数据的最大字节数 */public int read(byte[] b, int off, int len) throws IOException &#123; ensureOpen(); // 校验参数是否合法，b不能为null，off不能为负，且读入的最大字节数不能超过数组所能接受的最大字节数。 if (b == null) &#123; throw new NullPointerException(); &#125; else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) &#123; throw new IndexOutOfBoundsException(); &#125; else if (len == 0) &#123; return 0; &#125; // 计算缓冲数组中的数据字节数 int avail = buf.length - pos; // 从缓冲区中读取数据 if (avail &gt; 0) &#123; if (len &lt; avail) &#123; avail = len; &#125; System.arraycopy(buf, pos, b, off, avail); pos += avail; off += avail; len -= avail; &#125; // 若要读取的数据数超过了缓冲区的数据数，则读完被推回的数据后，继续从包裹的InputStream中读取数据 if (len &gt; 0) &#123; len = super.read(b, off, len); if (len == -1) &#123; // 缓冲区无数据，包裹的InputStream也没有数据 return avail == 0 ? -1 : avail; &#125; return avail + len; &#125; return avail;&#125; 推回数据12345678910111213141516171819202122232425/** * 推回一个字节数据，即将它拷贝到本类的缓冲数组中 */public void unread(int b) throws IOException &#123; ensureOpen(); // pos为0说明缓冲数组已满 if (pos == 0) &#123; throw new IOException(\"Push back buffer is full\"); &#125; // 从后往前赋值 buf[--pos] = (byte)b;&#125;/** * 推回字节数组的一部分到缓冲数组中， */public void unread(byte[] b, int off, int len) throws IOException &#123; ensureOpen(); if (len &gt; pos) &#123; throw new IOException(\"Push back buffer is full\"); &#125; pos -= len; System.arraycopy(b, off, buf, pos, len);&#125; 以上就是这个类的主要方法。我们可以看出，当单个推回数据时，是逆序插入缓冲数组，同时读取数据时，是正序读出。所以是后入先出。","tags":[]},{"title":"《Java核心技术（英文版）》读书笔记：Object类的equals方法","date":"2017-02-28T16:59:03.000Z","path":"2017/03/01/hello-world/","text":"Object类是Java中的一个全局超类——每一个Java类都扩展了它。但是你不必显示地如下声明： 1public class Employee extends Object equals方法引用同一equals方法是Object类中用于判断一个对象和另一个对象是否相等的方法。在Object类中的实现如下： 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 从源代码可知，该实现是检查两个对象的引用是否相等，也即是检查两个对象是否指向Java堆中的同一个对象。这是因为，如果两个对象的引用指向同一个Java堆中的对象，则这两个对象必然是相等的。对极少数类的对象来说，这个实现已经足够了。例如两个PrintStream对象。 状态相等如上文所述，对大多数类来说，Object中的equals实现是不够用的。因为很多时候，我们认为两个对象相等是基于它们具有相同的状态（即对象的属性，field）。例如，两个Employee对象，如果它们具有相同的姓名（name），工资（salary）和雇佣日期（hire day），那它们就是相等的。它的实现如下： 12345678910111213141516public class Employee &#123; ... public boolean equals(Object otherObject) &#123; if (this == otherObject) return true; if (otherObject == null) return false; if (getClass() ！= otherObject.getClass()) return false; Employee other = (Employee) otherObject; return name.equals(other.name) &amp;&amp; salary == other.salary; &amp;&amp; hireDay.equals(other.hireDay); &#125;&#125; 上面的代码中，首先判断两个对象是否同一，其次判断被比较对象是否为null，再次比较两个对象所属的类是否相同（在此处，假定必须类相同才有可能相等），最后比较各个状态是否相等。注意如果状态也是对象的话，则会递归调用它们的equals方法。 这里要注意的是，Employee对象的name和hireDay等状态是有可能为null的，为了确保在这种情况下程序也是正确的，可以使用Objects.equals方法。调用Objects.equals(a, b)，若两个参数都是null返回true，若其中一个为null返回false，以上都不成立则调用a.equals(b)。因此，上面方法的最后一条语句可修改为 123return Objects.equals(name, other.name) &amp;&amp; salary == other.salary; &amp;&amp; Objects.equals(hireDay, other.hireDay); 当在扩展类中定义了equals方法时，须首先调用超类的equals方法，如果返回false，则两个对象不可能相等。若返回true，即是超类定义的状态相等。则继续比较子类定义的状态。","tags":[]}]