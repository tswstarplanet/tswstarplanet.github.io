[{"title":"Dubbo服务治理环境的搭建","date":"2017-11-25T16:00:00.000Z","path":"2017/11/26/Dubbo服务治理环境的搭建/","text":"Dubbo是阿里推出的服务治理框架，被国内很多公司广泛使用。关于它的介绍可参考http://http://dubbo.io.本文主要介绍如何通过dubbo搭建服务治理环境，通过在本地搭建环境，有助于学习dubbo的源代码实现，毕竟可以边看源代码边运行调试。 Zookeeper的安装dubbo是一个服务治理服务，那它必然有一个服务注册中心。dubbo的服务注册中心可以采用multicast、zookeeper、redis或simple注册中心。比较常见的是zookeeper注册中心。 首先下载zookeeper，下载之后首先要做的是进入它的子目录conf中，将zoo_sample.cfg文件名修改为zoo.cfg，因为zookeeper启动时会使用它。之后从终端进入它所在目录，运行bin/zkServer.sh start。 之后可输入jps命令，若显示运行的进程中有QuorumPeerMain,则证明zookeeper已启动。 运行bin/zkServer.sh stop停止zookeeper。 安装tomcat下载tomcat 7。为什么是7，因为经试验tomcat 8和9两个版本在部署dubbo时都有问题。下载之后进入子目录conf中，将server.xml中配置的connector的port由8080改成其他数字，注意不要和已经被其他程序使用的端口冲突。 进入tomcat的子目录bin中，运行startup.sh（若是Windows则是startup.bat）。若启动过程不报错，且最后显示tomcat started，则证明启动成功。 运行shutdown.sh停止tomcat。 安装dubbo-admin从http://dubbo.io/或github上下载dubbo项目的源代码。dubbo-admin是dubbo的控制台，可以通过它查看和管理在dubbo上注册的服务。下载dubbo源代码之后，从终端进入dubbo文件夹。输入命令 mvn install -Dmaven.test.skip=true 将会编译整个dubbo项目，也包括dubbo-admin。 之后进入dubbo-admin的子目录target中，会发现多了一个dubbo-admin-2.5.7.war。将这个包拷到tomcat的webapps文件夹中。 按前面介绍的方法先启动zookeeper，再启动tomcat。之后在浏览器中输入localhost:8888/dubbo-admin-2.5.7。会看到如下界面。 可以看到服务提供者和调用者都是0，说明还没有服务注册到zookeeper中。 注册服务生产者和消费者为简化起见，本文采用IDE来构建服务。 首先是用intellij idea导入整个dubbo项目。 可以看到其中就有dubbo-demo项目，它主要有三个子项目构成。 其中远程调用的接口DemoService： 1234567package com.alibaba.dubbo.demo;public interface DemoService &#123; String sayHello(String name);&#125; 这个类之所以是一个单独的项目，是因为它需要被服务端和客户端同时引用。服务端会实现它： 12345678910111213141516package com.alibaba.dubbo.demo.provider;import com.alibaba.dubbo.demo.DemoService;import com.alibaba.dubbo.rpc.RpcContext;import java.text.SimpleDateFormat;import java.util.Date;public class DemoServiceImpl implements DemoService &#123; public String sayHello(String name) &#123; System.out.println(\"[\" + new SimpleDateFormat(\"HH:mm:ss\").format(new Date()) + \"] Hello \" + name + \", request from consumer: \" + RpcContext.getContext().getRemoteAddress()); return \"Hello \" + name + \", response form provider: \" + RpcContext.getContext().getLocalAddress(); &#125;&#125; 客户端则可以通过配置，就像调用本地方法一样调用它。这也是RPC的主要目的之一。 服务端主类： 1234567891011121314151617package com.alibaba.dubbo.demo.provider;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Created by ken.lj on 2017/7/31. */public class Provider &#123; public static void main(String[] args) throws Exception &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;\"META-INF/spring/dubbo-demo-provider.xml\"&#125;); context.start(); System.in.read(); // 按任意键退出 &#125;&#125; 客户端主类： 1234567891011121314151617181920212223package com.alibaba.dubbo.demo.consumer;import com.alibaba.dubbo.demo.DemoService;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Created by ken.lj on 2017/7/31. */public class Consumer &#123; public static void main(String[] args) throws Exception &#123; ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(new String[]&#123;\"META-INF/spring/dubbo-demo-consumer.xml\"&#125;); context.start(); DemoService demoService = (DemoService) context.getBean(\"demoService\"); // 获取远程服务代理 String hello = demoService.sayHello(\"世界\"); // 执行远程方法 System.out.println(hello); // 显示调用结果 System.in.read(); &#125;&#125; 客户端最后一行代码是我加的，为了让客户端和服务端一样执行完调用之后不会退出程序。 此外服务端和客户端还需要在spring配置文件中做一些配置。服务端配置： 12345678910111213141516171819202122&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" xmlns=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\"&gt; &lt;!-- 提供方应用信息，用于计算依赖关系 --&gt; &lt;dubbo:application name=\"demo-provider\"/&gt; &lt;!-- 使用multicast广播注册中心暴露服务地址 --&gt; &lt;dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/&gt; &lt;!-- 用dubbo协议在20880端口暴露服务 --&gt; &lt;dubbo:protocol name=\"dubbo\" port=\"20880\"/&gt; &lt;!-- 和本地bean一样实现服务 --&gt; &lt;bean id=\"demoService\" class=\"com.alibaba.dubbo.demo.provider.DemoServiceImpl\"/&gt; &lt;!-- 声明需要暴露的服务接口 --&gt; &lt;dubbo:service interface=\"com.alibaba.dubbo.demo.DemoService\" ref=\"demoService\"/&gt;&lt;/beans&gt; 客户端配置： 12345678910111213141516&lt;beans xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:dubbo=\"http://code.alibabatech.com/schema/dubbo\" xmlns=\"http://www.springframework.org/schema/beans\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd\"&gt; &lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt; &lt;dubbo:application name=\"demo-consumer\"/&gt; &lt;!-- 使用multicast广播注册中心暴露发现服务地址 --&gt; &lt;dubbo:registry address=\"zookeeper://127.0.0.1:2181\"/&gt; &lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt; &lt;dubbo:reference id=\"demoService\" check=\"false\" interface=\"com.alibaba.dubbo.demo.DemoService\"/&gt;&lt;/beans&gt; 可见配置文件中就配置了我们之前启动的zookeeper，所以程序启动之后就可以注册到zookeeper中了。 现在先运行服务端的Provider的main方法，再运行Consumer的main方法。可以看到consumer端打印出了如下内容。 可见，客户端通过调用服务端的方法，返回了字符串并打印出来了。 再看dubbo-admin的页面： 可见dubbo-admin中已经能看到注册进来的服务提供者和调用者了。 总结本文采用了比较简单的方式，即从IDE中运行dubbo项目，虽然在实际运用中需要单独部署服务，但这种方式便于学习源代码。比如可以单步跟踪，看整个dubbo执行远程调用的流程。","tags":[]},{"title":"Jdbc对数据库事务隔离级别的验证","date":"2017-11-25T16:00:00.000Z","path":"2017/11/26/Jdbc中对数据库隔离级别的验证/","text":"数据库的事务隔离级别一.读未提交读未提交是指当一个事务在执行过程中，若另一个事务修改了同一条数据，但没有提交，仍然会被当前数据读取到被更改但未提交的新值。此时可能发生脏读。二.读提交读提交是指当一个事务在执行过程中，若另一个事务修改了数据并且提交了修改。此时提交后的数据会被当前数据读取到。此时会发生不可重复读。三.可重复读可重复读是指当一个事务在执行过程中，不管读同一条数据多少次，读到的数据和第一次读取的值保持一致。此时可能发生幻读，即另一个事务插入了新数据，但没有被当前事务读取到。四.可序列化可序列化是指所有事务顺序执行，此时可避免幻读。 通过JDBC对数据库的访问，可验证数据库的事务隔离级别。 建表语句12345678CREATE TABLE Orders( O_id INT AUTO_INCREMENT, OrderPrice DOUBLE(11, 2) NOT NULL, Customer VARCHAR(50) NULL, CONSTRAINT `PRIMARY` PRIMARY KEY (O_id)); 插入一条数据1 1000 Bush 4 程序代码编写两个Java程序，开启两个事务对MySQL数据库进行访问 12345678910111213141516171819202122232425262728293031323334353637383940import java.sql.*;public class JdbcTest &#123; static final String JDBC_DRIVER = \"com.mysql.jdbc.Driver\"; static final String DB_URL = \"jdbc:mysql://localhost/database2\"; static final String USER = \"root\"; static final String PASS = \"1234\"; public static void main(String[] args) &#123; Connection connection = null; Statement statement = null; try &#123; Class.forName(JDBC_DRIVER); System.out.println(\"connecting...\"); connection = DriverManager.getConnection(DB_URL, USER, PASS); connection.setAutoCommit(false); statement = connection.createStatement(); String sql = \"select * from Orders where O_id = ?\"; PreparedStatement ps = connection.prepareStatement(sql); ps.setInt(1,1); ResultSet rs = ps.executeQuery(); while (rs.next()) &#123; System.out.println(rs.getInt(4)); &#125; rs = ps.executeQuery(); while (rs.next()) &#123; System.out.println(rs.getInt(4)); &#125; rs.close(); connection.commit(); connection.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940import java.sql.*;public class JdbcTestTwo &#123; static final String JDBC_DRIVER = \"com.mysql.jdbc.Driver\"; static final String DB_URL = \"jdbc:mysql://localhost/database2?useSSL=false\"; static final String USER = \"root\"; static final String PASS = \"1234\"; public static void main(String[] args) &#123; Connection connection = null; Statement statement = null; try &#123; Class.forName(JDBC_DRIVER); System.out.println(\"connecting...\"); connection = DriverManager.getConnection(DB_URL, USER, PASS); connection.setAutoCommit(false); statement = connection.createStatement(); String sql = \"UPDATE Orders SET col = 2 WHERE O_id = ?\"; PreparedStatement ps = connection.prepareStatement(sql); ps.setInt(1,1);// ResultSet rs = ps.executeQuery();// while (rs.next()) &#123;// System.out.println(rs.getInt(4));// &#125; int count = ps.executeUpdate();// while (rs.next()) &#123;// System.out.println(rs.getInt(4));// &#125;// rs.close(); connection.commit(); connection.close(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 在JdbcTest中对数据库表的同一条数据进行了两次查询，只需要在两次查询之间加一个断点，当程序暂停时，运行JdbcTest2，就可以观察到数据库中的数据变化是否符合隔离级别的定义。 读未提交将MySQL数据库全局隔离级别设置为读未提交的命令：SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED; 1.运行JdbcTest，第一次查询出数据列col为4，暂停程序；2.运行JdbcTest2，执行为update语句之后，暂停，不提交；3.继续运行JdbcTest，第二次查询出数据列已经变为2； 读提交将MySQL数据库全局隔离级别设置为读提交的命令：SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED; 1.运行JdbcTest，第一次查询出数据列col为4，暂停程序；2.运行JdbcTest,第一次查询出数据列为2，暂停程序，不提交；3.继续运行JdbcTest，第二次查询出数据列仍然为4； 若第二步不暂停直接提交，则第三步查询出的数据将为2； 可重复读将MySQL数据库全局隔离级别设置为可重复读的命令：SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ; 1.运行JdbcTest，第一次查询出数据列col为4，暂停；2.运行JdbcTest2，直接提交，将数据修改为2；3.运行JdbcTest，读出数据依然为2。 可序列化将MySQL数据库全局隔离级别设置为可重复读的命令：SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE; 1.运行JdbcTest，第一次查询出数据列col为4，暂停；2.运行JdbcTest2,将一直被阻塞，直到JdbcTest恢复执行完后，它才能完成事务，或者超时抛出异常。 总结数据库的隔离级别是很重要的特性，在不同场合使用不同的隔离级别会有不同的用处。大多数情况下使用的是可重复读。通过编程来验证隔离级别，可以更好地加深对知识的理解。","tags":[]},{"title":"Spring Boot快速搭建Web应用","date":"2017-05-29T16:00:00.000Z","path":"2017/05/30/Spring Boot快速搭建Web应用/","text":"Spring Boot是Spring家族一个新兴的成员，它能用于快速构建基于Spring的独立的生产级的应用程序。我们可以将它与Spring平台的其他项目以及第三方库自由组合。大多数基于Spring Boot的应用只需要非常少量的Spring配置。 Spring Boot的安装与其他Java库类似，Spring Boot也是打包成jar的形式，所以可以在应用中直接将spring-boot-*.jar引入到classpath中。可以像开发其他Java程序那样开发Spring Boot程序。 但是在现代的企业级Java开发中，一般会使用专门的构建工具来管理应用的整个生命周期，例如Maven和Gradle。 当使用Maven时，只需要在pom.xml中配置好相关依赖，就可以在构建过程中自动引用Spring Boot的相关jar。 用Spring Boot开发web应用学习任何新技术，都是从开发Hello world级别的程序开始的。用Spring Boot结合Maven开发Hello world级别的Web应用可谓易如反掌。 创建pom.xml文件在磁盘合适的位置新建一个项目文件夹，比如SpringBootTest。从终端进入该文件夹，创建一个pom.xml文件，输入如下内容并保存。 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.example&lt;/groupId&gt; &lt;artifactId&gt;myproject&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.5.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 可以看到引入了spring-boot-starter-parent和spring-boot-starter-web两个starter。Spring Boot是用于简化Spring应用开发的，spring-boot-starter-parent的作用是让maven自动引入默认的一些基础依赖，spring-boot-starter-web则会让maven自动引入web应用需要的依赖。试想一下如果我们不使用Spring Boot，而是手工用Spring，Spring MVC来开发web应用，那需要配置应用上下文，Servlet上下文等，在maven中也要手工将相关依赖都引入进来。配置量会成倍增加。而用Spring Boot则非常轻松，会将配置最少化。 有了这个pom文件，就可以用maven来构建程序了，可以用mvn package来测试，会看到maven会下载很多依赖，打印出如下信息，就证明能正常构建程序。Building myproject 0.0.1-SNAPSHOTBuild Success同时，项目文件夹下出现了target文件夹，该文件夹就是构建出来的可执行文件。可以执行maven dependency:tree命令来打印出项目依赖的树形表示。 编写代码使用Maven管理应用必须使文件夹结构符合maven的约定。所以在SpringBootTest文件夹下新建如下目录结构：src/main/java进入该文件夹，创建文件Example.java，输入如下内容： 12345678910111213141516171819import org.springframework.boot.*;import org.springframework.boot.autoconfigure.*;import org.springframework.stereotype.*;import org.springframework.web.bind.annotation.*;@RestController@EnableAutoConfigurationpublic class Example &#123; @RequestMapping(\"/\") String home() &#123; return \"Hello World!\"; &#125; public static void main(String[] args) throws Exception &#123; SpringApplication.run(Example.class, args); &#125;&#125; @RestController注解标志这个类是一个web Controller，并且是REST的访问方式。 @RequestMapping提供了“路由”信息。它告诉Spring任何HTTP请求，如果路径符合“/”就会被路由到home方法。因为是用Rest方式访问的Controller，所以直接返回Hello World！字符串，而不是重定向到一个view。 @EnableAutoConfiguration告诉Spring Boot开发者希望如何配置Spring，依据pom.xml中添加的依赖。因为spring-boot-starter-web依赖会自动添加Tomcat和Spring MVC，自动配置组件就知道开发者在开发一个web应用程序，并据此设置Spring。 main方法这里的main方法就是Java程序中标准的main方法。但该方法代理执行了Spirng Boot的SpringApplication类的run方法，从而启动了Spring去自动配置Tomcat。此处需要将Example.class作为参数传给run方法，告诉SpringApplication它是主要的Spring组件。 运行程序万事俱备只欠东风。用终端进入Spring进入到SpringBootTest（必须是pom.xml所在文件夹），输入如下命令。mvn spring-boot:run 会看到输出如下内容： 12345678910 . ____ _ __ _ _ /\\\\ / ___&apos;_ __ _ _(_)_ __ __ _ \\ \\ \\ \\( ( )\\___ | &apos;_ | &apos;_| | &apos;_ \\/ _` | \\ \\ \\ \\ \\\\/ ___)| |_)| | | | | || (_| | ) ) ) ) &apos; |____| .__|_| |_|_| |_\\__, | / / / / =========|_|==============|___/=/_/_/_/ :: Spring Boot :: (v1.5.3.RELEASE)…… ……… …Started Example in 3.239 seconds (JVM running for 21.929) 打开浏览器，输入localhost:8080，会看到如下输出Hello World! 总结从上文可以看出，Spring Boot可以在Spring框架的基础上快速搭建应用，例如Web应用。它可以有效减少配置量，而且可以使用内嵌的Web容器，可以高效地开发和测试程序。","tags":[]},{"title":"Kotlin的新特性（一）：基本类型","date":"2017-05-29T16:00:00.000Z","path":"2017/05/30/kotlin-new-feature-1/","text":"Kotlin是一门新兴的语言，它可以运行于JVM、JavaScript以及native环境（native正在开发中）。它是由著名软件开发商Jetbrains开发，具备了很多新的特性，能够在开发中提升效率。目前已经成为Android官方支持的开发语言。Kotlin语言中的一切类型都是对象，这与Java不同。虽然Java标榜自己是一门纯粹的面向对象的语言，但由于设计的局限，还是保留了一些非面向对象的元素，最明显的就是在Java中，int、float、double、long、char等基本类型不是类，而是原生类型（primitive types）。为了补救这个缺陷，Java开发了对应的包装类型Integer、Float、Double、Long、Chararater等。Kotlin吸收了C#等语言的设计思想，将上述基本类型内置为类，它们具有自己的成员函数和成员属性。这些基本类型包括：数字类型（numbers），字符类型（characters），布尔类型（booleans）和数组类型（arrays）。 NumberKotlin中的数字类型与Java类似，包括Double、Float、Long、Int、Short、Byte等类型。如上文所述，它们都是类。 字面常量Kotlin中的字面常量（literal constants）与Java类似，Int类型支持十进制，直接用普通十进制表示即可；Long类型则需跟上L后缀，如123L表示一个Long型常数，值是123。十六进制加0x前缀，如0x0F表示十六进制数，值是15。二进制加0b前缀，如0b00001011表示二进制数，值是11。Kotlin中不支持八进制数。Kotlin支持通用的浮点数表示法，默认是Double类型，如123.5，123.5e10，如果是Float类型，需要加f或F后缀，如123.5f。 下划线分隔位数Kotlin支持在数字常量中使用下划线分隔数位。这能使位数较多的数字具有更强的可读性。 12val oneMillion = 1_000_000 val creditCardNumber = 1234_5678_9012_3456L 当Kotlin运行于JVM中时，number类型实际上是存储为JVM原生类型，当被赋值给可以为空（nullable）的引用时，Kotlin的number类型是对原生类型的包装。Kotlin中，当使用一个number型常量（val）去初始化一个不可为空的number型常量时，被初始化的常量都指向内存中同一个地址。而当初始化为一个可以为空的常量时，则会在内存中不同地址创建两个常量，并将值赋给它们。 1234567891011val a: Int = 10000 print(a === a) // Prints 'true' val boxedA: Int = a val anotherBoxedA: Int = a print(boxedA === anotherBoxedA) // !!!Prints true!!!val a: Int = 10000 print(a === a) // Prints 'true' val boxedA: Int? = a val anotherBoxedA: Int? = a print(boxedA === anotherBoxedA) // !!!Prints 'false'!!! 但即使是赋值给可以为空的常量，依然能保证它们的相等性（equality）： 1234val a: Int = 10000 print(a == a) // Prints 'true' val boxedA: Int? = a val anotherBoxedA: Int? = a print(boxedA == anotherBoxedA) // Prints 'true' 宽向扩展Kotlin中不存在隐式的宽向类型扩展，即Byte不能直接转换为Int，Int不能直接转换为Double，等等。 12val b: Byte = 1 // OK, literals are checked statically val i: Int = b // ERROR 每种number类型都能通过内置方法任意转换为另一种number类型。 Characters字符类型用Char类表示。与Java不同，它不能被直接当做数字类型使用。 1234fun check(c: Char) &#123; if (c == 1) &#123; // ERROR: incompatible types // ... &#125; &#125; 与Java一样，字符字面量使用单引号表示。转义字符使用反斜杠。特殊字符使用反斜杠加u加十六进制数表示。字符可以通过toInt()方法显式转换为Int。与number一样，字符被赋值给一个nullable引用时，唯一性（identity，内存中地址相同）是不被保证的。 Booleans用Boolean代表布尔类型，它有两个值：true和false。 布尔类型被赋值给nullable引用时，会被包装。但能保证唯一性。 12345val a: Boolean = trueprintln(a === a) // Prints 'true'val boxedA: Boolean? = aval anotherBoxedA: Boolean? = aprintln(boxedA === anotherBoxedA) // Prints ‘true’ Arrays在Java中，数组其实也是一种对象，只是我们不能显示地获得它的类型表示。在Kotlin中，用Array类来代表数组。它具有get和set方法（通过[]操作符重载了这两个函数），size属性以及其他有用的函数，如迭代器方法iterator()。 创建数组可以使用arrayOf()方法，并传递数组元素给它作为参数。例如arrayOf(1, 2, 3)就创建了一个数组[1, 2, 3]。arrayOfNulls()函数用于创建一个给定长度的数组，并用null元素填充它。 Kotlin也有特定的类代表原生类型的数组，如ByteArray、ShortArray、IntArray等。这些类与Array没有继承关系，但有对应的方法和属性集合。如IntArray有对应的工厂函数。 12val x: IntArray = intArrayOf(1, 2, 3) x[0] = x[1] + x[2] Strings字符串用String类表示。与Java一样，String是不可变类。String的元素是字符，与Java中必须使用charAtIndex()这样一个方法去访问元素不同，Kotlin中可以使用下标运算符[]去访问字符元素。String还能使用for循环很方便地访问。 123for (c in str) &#123; println(c) &#125; 字符串字面量Kotlin有两种字符串字面量：一种是可转义的字符串，它可能含有转义字符，它不能表示在多行，除非使用“+”将不同的字符串连接成一个字符串；另一种是原始（raw）字符串，能在多行表示并能包含任意文本。 转义字符串： 1val s = \"Hello, world!\\n\" 原始字符串： 123val text = \"\"\" for (c in \"foo\") print(c) \"\"\" 可以使用trimMargin()移除字符串开头和中间的空格，但空格的末尾必须跟上一个明确的分隔符，默认是“|”。 123456val text = \"\"\" |Tell me and I forget. |Teach me and I remember. |Involve me and I learn. |(Benjamin Franklin) \"\"\".trimMargin()\"\"\" 也可以显示指定分隔符，如trimMargin(“&gt;”) 字符串模板在Java中，如果我们在字符串中要加入变量，必须使用加号连接，或者使用格式化字符串。而在Kotlin中，可以使用字符串模板，这将使字符串变得更加简洁，看上去也更加舒服。字符串模板以美元符号开头，直接跟上一个变量名。 123val i = 10 val s = \"i = $i\" // evaluates to \"i = 10\"\"\"\" 或者是一个用大括号包裹的任意的表达式。 123val s = \"abc\" val str = \"$s.length is $&#123;s.length&#125;\" // evaluates to \"abc.length is 3\"\"\"\" 模板在原始字符串和转义字符串中都支持。如果你在原始字符串中需要表示美元符号的字面值，可以像下面这样使用。 123val price = \"\"\" $&#123;'$'&#125;9.99 \"\"\"","tags":[]},{"title":"RabbitMQ的Java客户端（一）","date":"2017-05-29T15:50:13.000Z","path":"2017/05/29/RabbitMQ-HelloWorld/","text":"RabbitMQ是一个常用的消息队列中间件，它能接收并转发消息。在消息通信模型中，系统可分为三部分：生产者，消息服务器和消费者。简单地说，生产者程序产生消息，发布到消息服务器；消费者程序连接到消息服务器，订阅到队列中。每当消息到达特定等队列时，RabbitMQ会将其发送给其中一个订阅/监听的消费者。在RabbitMQ中，生产者并不是直接将消息交给某个消息队列的，而是将消息发送给交换器，发送时会指定投递的规则，这些规则称为路由键。交换器中最简单等一种就是direct交换器。它是一个以空白字符串为名称等默认交换器。当声明一个队列时，默认绑定到direct交换器。direct交换器的规则非常简单：如果路由键（队列名）匹配的话，消息就被投递到对应等队列。如下图所示 Java客户端Java是当今流行的服务器应用程序开发语言。RabbitMQ也提供了Java的客户端SDK。用Java实现direct交换器中的生产者示例代码： 123456789101112131415161718192021222324252627282930package com.wts.helloworld;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;/** * Created by weitaosheng on 2017/5/1. */public class Send &#123; private final static String QUEUE_NAME = \"hello\"; public static void main(String[] args) throws Exception &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\"localhost\"); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); String message = \"Hello World!\"; channel.basicPublish(\"\", QUEUE_NAME, null, message.getBytes()); System.out.println(\" [x] Sent '\" + message + \"'\"); channel.close(); connection.close(); &#125;&#125; 创建一个消息生产者等步骤： 新建连接工厂； 绑定RabbitMQ服务器地址（默认为localhost，端口5672）； 获取连接； 建立频道（channel）； 声明队列； 发布消息。 关闭频道； 关闭连接。 客户端示例代码： 1234567891011121314151617181920212223242526272829303132import com.rabbitmq.client.*;import java.io.IOException;/** * Created by weitaosheng on 2017/5/1. */public class Recv &#123; private final static String QUEUE_NAME = \"hello\"; public static void main(String[] args) throws Exception &#123; ConnectionFactory factory = new ConnectionFactory(); factory.setHost(\"localhost\"); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); System.out.println(\" [*] Waiting for message. To exit press CTRL+C\"); Consumer consumer = new DefaultConsumer(channel) &#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message = new String(body, \"UTF-8\"); System.out.println(\" [x] Received '\" + message + \"'\"); &#125; &#125;; channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 创建客户端并订阅队列的步骤： 新建连接工厂； 绑定RabbitMQ服务器地址（默认为localhost，端口5672）； 获取连接； 建立频道（channel）； 声明队列； 声明一个消息消费者，本示例中是用一个匿名内部类来扩展了DefaltConsumer类，并重写了handleDelivery方法，该方法定义了接收到消息时进行等处理。 以下是客户端SDK关键的类和方法：ConnectionFactory：连接工厂关键类，是客户端访问RabbitMQ服务器必须要先构造的类。从Connection的源代码可以看出，ConnectionFactory没有显示定义构造函数，因此使用的是编译器自动生成的默认构造函数。获取连接的函数 1234public Connection newConnection() throws IOException, TimeoutException &#123; return newConnection(this.sharedExecutor, Collections.singletonList(new Address(getHost(), getPort())));&#125; 查看源码，sharedExecutor是一个ExecutorService的实例。此处为null，也就是没有使用线程池。连接时还需要地址和端口。1Channel createChannel() throws IOException; createChannel：生成一个Channel类的实例。Connection是一条真实的TCP连接，Channel是Connection内等一条虚拟连接，它在RabbitMQ中会自动生成唯一的ID。通过一条TCP连接内多个虚拟连接的方式，可以提高性能，节约系统资源，因为TCP连接的创建和销毁是非常昂贵的。Queue.DeclareOk queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete, Map arguments) throws IOException;queueDeclare：声明队列。它的几个参数的含义是：队列名，是否持久化，是否是限制性等队列（仅限于此次连接），是否自动删除消息，其他参数1void basicPublish(String exchange, String routingKey, BasicProperties props, byte[] body) throws IOException; basicPublish：发布消息，几个参数是：交换器名，路由键，是否设置了mandatory参数，消息参数，消息体（用byte数组装载） Consumer是代表消费者等接口，DefaultConsumer是Consumer接口的一个默认实现。一般定义消费者只需扩展这个类即可。1234public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) handleDelivery：消费者接收到消息时的回调方法。它的几个参数是：消费者标签，『信封』信息，消息头内容，消息体","tags":[]},{"title":"Java中synchronized关键字的研究","date":"2017-03-01T12:23:47.000Z","path":"2017/03/01/Java-synchronized/","text":"在Java中，每一个线程都有一个内部锁。当我们使用synchronized关键字时，就是利用这个内部锁来实现线程对某个对象的锁定控制。那么，如果某个对象中有两个方法，方法一和方法二都使用了synchronized关键字。如果线程一执行该对象的方法一，线程二执行该对象的方法二。如果线程1一直不释放该对象的内部锁的话，那么线程二应该无法执行该对象的方法二。下面就用代码来验证一下。首先，定义一个Task类1234567891011121314151617181920212223package corejava.chapter14;public class TaskC &#123; public synchronized void method1() throws InterruptedException &#123; while (true) &#123; System.out.println(\"我是方法1\"); Thread.sleep(10000); &#125; &#125; public synchronized void method2() throws InterruptedException &#123; while (true) &#123; System.out.println(\"我是方法2\"); Thread.sleep(10000); &#125; &#125;&#125; method1每隔10秒就会输出一句“我是方法1”。method2每隔10秒就会输出一句“我是方法2”。两个方法都使用了synchronized关键字。 再定义两个执行类ExecutorC1和Executor2。 1234567891011121314151617181920package corejava.chapter14;public class ExecutorC1 implements Runnable &#123; private TaskC taskC; public ExecutorC1(TaskC taskC) &#123; this.taskC = taskC; &#125; @Override public void run() &#123; try &#123; taskC.method1(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 123456789101112131415161718192021package corejava.chapter14;public class ExecutorC2 implements Runnable &#123; private TaskC taskC; public ExecutorC2(TaskC taskC) &#123; this.taskC = taskC; &#125; @Override public void run() &#123; try &#123; taskC.method2(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 执行对象1和执行对象2都使用同一个taskC去实例化，这样他们之间就会存在竞争。当thread1执行taskC的method1时，会一直持有taskC的内部锁，因此thread2将一直处于阻塞状态。 下面是运行输出结果 可见，确实如我们所料，虽然两个线程要执行的是不同的方法，但因为线程1一直“霸占”着内部锁，所以线程2始终在阻塞状态，得不到执行。 所以，如果我们在对某个类要使用synchronized关键字进行锁定控制时，一定要牢记它使用的是该类的内部锁。它是唯一的。当多个方法都用它来进行控制时，一定要考虑这一点。","tags":[]},{"title":"Java集合中的ArrayList类（一）：构造实例和添加元素","date":"2017-02-28T16:59:03.000Z","path":"2017/03/01/ArrayList/","text":"ArrayList有三个构造器，分别是无参构造器，传入一个整形参数的构造器，以及传入一个Collection实例的构造器。本文主要介绍前两种构造器。 无参构造器示例代码： 123456789public class ArrayListTest &#123; public static void main(String[] args) &#123; List&lt;String&gt; strings = new ArrayList&lt;&gt;(); strings.add(\"abc\"); &#125;&#125; 下面看调用构造器以及添加元素的代码 1234567/** * 用初始的10的容量大小构造一个空的list */public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125; 从上述构造器可以看出，无参构造器只是很简单将常量DEFAULTCAPACITY_EMPTY_ELEMENTDATA赋给成员变量elementData。这个成员变量和常量如下所示： 123456789101112131415/** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */transient Object[] elementData; // non-private to simplify nested class access 从注释可以看出，DEFAULTCAPACITY_EMPTY_ELEMENTDATA是一个空的数组实例，用来作为默认大小的空List。它与EMPTY_ELEMENTDATA同时存在，是为了当第一个元素被添加到list中时，能算出要扩展多大的容量。 elementData是ArrayList中用于实际存储元素的数组。一个ArrayList实例的容量就是这个数组的长度。任何调用了默认构造器生成的ArrayList实例，都执行了elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA，当第一个元素被添加到list中时，都会被扩展到默认的容量大小，即DEFAULT_CAPACITY（10）。 末尾添加元素的函数： 12345678910111213/*** Appends the specified element to the end of this list.** @param e element to be appended to this list* @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;)*/public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! // 扩容之后将新增的元素加到末尾，同时将list的size加一。 elementData[size++] = e; return true;&#125; 该方法首先调用了ensureCapacityInternal函数，用于确保容量足以添加一个元素。ensureCapacityInternal方法： 123456789private void ensureCapacityInternal(int minCapacity) &#123; // 插入“abc”时，minCapacity为1 // 当调用无参构造器时，初始存储元素的数组是DEFAULTCAPACITY_EMPTY_ELEMENTDATA if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; // 比较参数和默认容量大小，取大者作为扩展多容量 minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); // minCapacity变为10 &#125; ensureExplicitCapacity(minCapacity);&#125; 之后调用了ensureExplicitCapacity函数，继续扩展容量大操作： 1234567private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // 检查目标容量是否大于当前数组的实际长度 if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; 上述方法继续调用grow函数，完成扩容： 1234567891011121314151617181920/** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; // 容量扩充增量为当前数组容量大50% int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); // 若扩充后仍达不到目标容量，则直接使用目标容量作为新容量 if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; // 若超过最大容量，则调用hugeCapacity函数 if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // 调用工具函数扩容，末尾用null补全 elementData = Arrays.copyOf(elementData, newCapacity);&#125; 从注释可知，该方法增长容量以确保list至少能保存传入参数大小数量多元素。之后，就可以插入元素“abc”。插入之后，list的size为1，容量为10.","tags":[]},{"title":"Java IO 中的PushbackInputStream类","date":"2017-02-28T16:59:03.000Z","path":"2017/03/01/PushbackInputStream/","text":"PushbackInputstream类是Java IO中的一个较特别的类，因为它可以将读出的字节再推回流中。这也就是它的名字中Pushback的由来。下面首先介绍一下它的基本用法，再分析一下它的源代码。 使用方法首先需要构造一个PushbackInputStream对象，这个对象需要传入一个InputStream实例作为参数。之后从该InputStream绑定的数据源（例如一个文件、或者网络流）读入数据，然后将读出的数据再推回PushBackInputStream中。如下所示 1234567891011121314public class PushbackInputStreamTest &#123; public static void main(String[] args) throws Exception&#123; PushbackInputStream inputStream = new PushbackInputStream( new FileInputStream(\"input.txt\")); int data = inputStream.read(); System.out.println(data); inputStream.unread(data); data = inputStream.read(); System.out.println(data); &#125;&#125; 文件中保存着一个字符串abcdefg。输出如下： Read before push back: 97Read after push back: 97 可见，我们读出了一个字符a（它的ascii码是97），之后又成功推回了流中。 如果我们需要一次推回多个字符，则需要在构造PushbackInputStream实例时传入一个整型参数，用于指定每次推回多最大字节数。如下所示： 12345678910111213141516171819public class PushbackInputStreamTest &#123; public static void main(String[] args) throws Exception&#123; PushbackInputStream input = new PushbackInputStream( new FileInputStream(\"input.txt\"), 10); byte[] bytes = new byte[10]; int r = input.read(bytes); for (byte b : bytes) &#123; System.out.println(b); &#125; input.unread(bytes); r = input.read(bytes); for (byte b : bytes) &#123; System.out.println(b); &#125; &#125;&#125; 输出：Read before push back:979899100101102103000Read after push back:979899100101102103000 可见，我们可以一次读入最多10个字节（因为数据只有7个字节，所以剩余字节为0. 如果推回多字节大于构造函数中指定的最大字节数，则会发生异常： java.io.IOException: Push back buffer is full 下面分析一下PushbackInputStream的源代码 成员变量12345678910/** * 缓冲区，被推回的字节将会保存在这里 */protected byte[] buf;/** * 从缓冲区读取数据时的位置，也就是读取被推回的数据时的下标。当缓冲区为空时，pos为buf.length（即没有推回数据，故不能从缓冲区读取）；当缓冲区所有字节均有数据时，则pos为0 * */protected int pos; 构造函数12345678910111213141516171819/** * 通过指定size的缓冲数组以及一个InputStream实例，来构造一个PushbackInputStream对象 */public PushbackInputStream(InputStream in, int size) &#123; super(in); if (size &lt;= 0) &#123; throw new IllegalArgumentException(\"size &lt;= 0\"); &#125; this.buf = new byte[size]; this.pos = size;&#125;/** * 若不指定缓冲区大小，则默认为1，即每次只能推回一个字节 */public PushbackInputStream(InputStream in) &#123; this(in, 1);&#125; 读取数据1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 读取数据，若缓冲区有数据，则从缓冲区的pos位置开始读取；若缓冲区无数据，则调用超类的read方法读取数据 */public int read() throws IOException &#123; // 确保流没有关闭 ensureOpen(); if (pos &lt; buf.length) &#123; return buf[pos++] &amp; 0xff; &#125; return super.read();&#125;/** * 将数据读入一个byte数组中，参数off是目标数组中的起始偏移量，参数len是读入数据的最大字节数 */public int read(byte[] b, int off, int len) throws IOException &#123; ensureOpen(); // 校验参数是否合法，b不能为null，off不能为负，且读入的最大字节数不能超过数组所能接受的最大字节数。 if (b == null) &#123; throw new NullPointerException(); &#125; else if (off &lt; 0 || len &lt; 0 || len &gt; b.length - off) &#123; throw new IndexOutOfBoundsException(); &#125; else if (len == 0) &#123; return 0; &#125; // 计算缓冲数组中的数据字节数 int avail = buf.length - pos; // 从缓冲区中读取数据 if (avail &gt; 0) &#123; if (len &lt; avail) &#123; avail = len; &#125; System.arraycopy(buf, pos, b, off, avail); pos += avail; off += avail; len -= avail; &#125; // 若要读取的数据数超过了缓冲区的数据数，则读完被推回的数据后，继续从包裹的InputStream中读取数据 if (len &gt; 0) &#123; len = super.read(b, off, len); if (len == -1) &#123; // 缓冲区无数据，包裹的InputStream也没有数据 return avail == 0 ? -1 : avail; &#125; return avail + len; &#125; return avail;&#125; 推回数据12345678910111213141516171819202122232425/** * 推回一个字节数据，即将它拷贝到本类的缓冲数组中 */public void unread(int b) throws IOException &#123; ensureOpen(); // pos为0说明缓冲数组已满 if (pos == 0) &#123; throw new IOException(\"Push back buffer is full\"); &#125; // 从后往前赋值 buf[--pos] = (byte)b;&#125;/** * 推回字节数组的一部分到缓冲数组中， */public void unread(byte[] b, int off, int len) throws IOException &#123; ensureOpen(); if (len &gt; pos) &#123; throw new IOException(\"Push back buffer is full\"); &#125; pos -= len; System.arraycopy(b, off, buf, pos, len);&#125; 以上就是这个类的主要方法。我们可以看出，当单个推回数据时，是逆序插入缓冲数组，同时读取数据时，是正序读出。所以是后入先出。","tags":[]},{"title":"《Java核心技术（英文版）》读书笔记：Object类的equals方法","date":"2017-02-28T16:59:03.000Z","path":"2017/03/01/hello-world/","text":"Object类是Java中的一个全局超类——每一个Java类都扩展了它。但是你不必显示地如下声明： 1public class Employee extends Object equals方法引用同一equals方法是Object类中用于判断一个对象和另一个对象是否相等的方法。在Object类中的实现如下： 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 从源代码可知，该实现是检查两个对象的引用是否相等，也即是检查两个对象是否指向Java堆中的同一个对象。这是因为，如果两个对象的引用指向同一个Java堆中的对象，则这两个对象必然是相等的。对极少数类的对象来说，这个实现已经足够了。例如两个PrintStream对象。 状态相等如上文所述，对大多数类来说，Object中的equals实现是不够用的。因为很多时候，我们认为两个对象相等是基于它们具有相同的状态（即对象的属性，field）。例如，两个Employee对象，如果它们具有相同的姓名（name），工资（salary）和雇佣日期（hire day），那它们就是相等的。它的实现如下： 12345678910111213141516public class Employee &#123; ... public boolean equals(Object otherObject) &#123; if (this == otherObject) return true; if (otherObject == null) return false; if (getClass() ！= otherObject.getClass()) return false; Employee other = (Employee) otherObject; return name.equals(other.name) &amp;&amp; salary == other.salary; &amp;&amp; hireDay.equals(other.hireDay); &#125;&#125; 上面的代码中，首先判断两个对象是否同一，其次判断被比较对象是否为null，再次比较两个对象所属的类是否相同（在此处，假定必须类相同才有可能相等），最后比较各个状态是否相等。注意如果状态也是对象的话，则会递归调用它们的equals方法。 这里要注意的是，Employee对象的name和hireDay等状态是有可能为null的，为了确保在这种情况下程序也是正确的，可以使用Objects.equals方法。调用Objects.equals(a, b)，若两个参数都是null返回true，若其中一个为null返回false，以上都不成立则调用a.equals(b)。因此，上面方法的最后一条语句可修改为 123return Objects.equals(name, other.name) &amp;&amp; salary == other.salary; &amp;&amp; Objects.equals(hireDay, other.hireDay); 当在扩展类中定义了equals方法时，须首先调用超类的equals方法，如果返回false，则两个对象不可能相等。若返回true，即是超类定义的状态相等。则继续比较子类定义的状态。","tags":[]}]