<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WTS&#39;s Blog</title>
  <subtitle>所有文章都是在学习了相关内容之后写成</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-05-30T15:24:32.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>wts</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring Boot快速搭建Web应用</title>
    <link href="http://yoursite.com/2017/05/30/Spring%20Boot%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAWeb%E5%BA%94%E7%94%A8/"/>
    <id>http://yoursite.com/2017/05/30/Spring Boot快速搭建Web应用/</id>
    <published>2017-05-29T16:00:00.000Z</published>
    <updated>2017-05-30T15:24:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>Spring Boot是Spring家族一个新兴的成员，它能用于快速构建基于Spring的独立的生产级的应用程序。我们可以将它与Spring平台的其他项目以及第三方库自由组合。大多数基于Spring Boot的应用只需要非常少量的Spring配置。</p>
<h2 id="Spring-Boot的安装"><a href="#Spring-Boot的安装" class="headerlink" title="Spring Boot的安装"></a>Spring Boot的安装</h2><p>与其他Java库类似，Spring Boot也是打包成jar的形式，所以可以在应用中直接将spring-boot-*.jar引入到classpath中。可以像开发其他Java程序那样开发Spring Boot程序。</p>
<p>但是在现代的企业级Java开发中，一般会使用专门的构建工具来管理应用的整个生命周期，例如Maven和Gradle。</p>
<p>当使用Maven时，只需要在pom.xml中配置好相关依赖，就可以在构建过程中自动引用Spring Boot的相关jar。</p>
<h2 id="用Spring-Boot开发Hello-world级别的web应用"><a href="#用Spring-Boot开发Hello-world级别的web应用" class="headerlink" title="用Spring Boot开发Hello world级别的web应用"></a>用Spring Boot开发Hello world级别的web应用</h2><p>学习任何新技术，都是从开发Hello world级别的程序开始的。用Spring Boot结合Maven开发Hello world级别的Web应用可谓易如反掌。</p>
<h3 id="创建pom-xml文件"><a href="#创建pom-xml文件" class="headerlink" title="创建pom.xml文件"></a>创建pom.xml文件</h3><p>在磁盘合适的位置新建一个项目文件夹，比如SpringBootTest。从终端进入该文件夹，创建一个pom.xml文件，输入如下内容并保存。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>myproject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<p>可以看到引入了spring-boot-starter-parent和spring-boot-starter-web两个starter。Spring Boot是用于简化Spring应用开发的，spring-boot-starter-parent的作用是让maven自动引入默认的一些基础依赖，spring-boot-starter-web则会让maven自动引入web应用需要的依赖。试想一下如果我们不使用Spring Boot，而是手工用Spring，Spring MVC来开发web应用，那需要配置应用上下文，Servlet上下文等，在maven中也要手工将相关依赖都引入进来。配置量会成倍增加。而用Spring Boot则非常轻松，会将配置最少化。</p>
<p>有了这个pom文件，就可以用maven来构建程序了，可以用mvn package来测试，会看到maven会下载很多依赖，打印出如下信息，就证明能正常构建程序。<br>Building myproject 0.0.1-SNAPSHOT<br>Build Success<br>同时，项目文件夹下出现了target文件夹，该文件夹就是构建出来的可执行文件。<br>可以执行maven dependency:tree命令来打印出项目依赖的树形表示。</p>
<h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><p>使用Maven管理应用必须使文件夹结构符合maven的约定。所以在SpringBootTest文件夹下新建如下目录结构：<br>src/main/java<br>进入该文件夹，创建文件Example.java，输入如下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.boot.*;</div><div class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.*;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.*;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</div><div class="line"></div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@EnableAutoConfiguration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</div><div class="line">    <span class="function">String <span class="title">home</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        SpringApplication.run(Example.class, args);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>@RestController注解标志这个类是一个web Controller，并且是REST的访问方式。</p>
<p>@RequestMapping提供了“路由”信息。它告诉Spring任何HTTP请求，如果路径符合“/”就会被路由到home方法。因为是用Rest方式访问的Controller，所以直接返回Hello World！字符串，而不是重定向到一个view。</p>
<p>@EnableAutoConfiguration告诉Spring Boot开发者希望如何配置Spring，依据pom.xml中添加的依赖。因为spring-boot-starter-web依赖会自动添加Tomcat和Spring MVC，自动配置组件就知道开发者在开发一个web应用程序，并据此设置Spring。</p>
<h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h3><p>这里的main方法就是Java程序中标准的main方法。但该方法代理执行了Spirng Boot的SpringApplication类的run方法，从而启动了Spring去自动配置Tomcat。此处需要将Example.class作为参数传给run方法，告诉SpringApplication它是主要的Spring组件。</p>
<h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><p>万事俱备只欠东风。用终端进入Spring进入到SpringBootTest（必须是pom.xml所在文件夹），输入如下命令。<br>mvn spring-boot:run</p>
<p>会看到输出如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> .   ____          _            __ _ _</div><div class="line"> /\\ / ___&apos;_ __ _ _(_)_ __  __ _ \ \ \ \</div><div class="line">( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \</div><div class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</div><div class="line">  &apos;  |____| .__|_| |_|_| |_\__, | / / / /</div><div class="line"> =========|_|==============|___/=/_/_/_/</div><div class="line"> :: Spring Boot ::        (v1.5.3.RELEASE)</div><div class="line">…… …</div><div class="line">…… …</div><div class="line">Started Example in 3.239 seconds (JVM running for 21.929)</div></pre></td></tr></table></figure>
<p>打开浏览器，输入localhost:8080，会看到如下输出<br>Hello World!</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上文可以看出，Spring Boot可以在Spring框架的基础上快速搭建应用，例如Web应用。它可以有效减少配置量，而且可以使用内嵌的Web容器，可以高效地开发和测试程序。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Spring Boot是Spring家族一个新兴的成员，它能用于快速构建基于Spring的独立的生产级的应用程序。我们可以将它与Spring平台的其他项目以及第三方库自由组合。大多数基于Spring Boot的应用只需要非常少量的Spring配置。&lt;/p&gt;
&lt;h2 id=&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Kotlin的新特性（一）：基本类型</title>
    <link href="http://yoursite.com/2017/05/30/kotlin-new-feature-1/"/>
    <id>http://yoursite.com/2017/05/30/kotlin-new-feature-1/</id>
    <published>2017-05-29T16:00:00.000Z</published>
    <updated>2017-05-30T10:02:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>Kotlin是一门新兴的语言，它可以运行于JVM、JavaScript以及native环境（native正在开发中）。它是由著名软件开发商Jetbrains开发，具备了很多新的特性，能够在开发中提升效率。目前已经成为Android官方支持的开发语言。<br>Kotlin语言中的一切类型都是对象，这与Java不同。虽然Java标榜自己是一门纯粹的面向对象的语言，但由于设计的局限，还是保留了一些非面向对象的元素，最明显的就是在Java中，int、float、double、long、char等基本类型不是类，而是原生类型（primitive types）。为了补救这个缺陷，Java开发了对应的包装类型Integer、Float、Double、Long、Chararater等。<br>Kotlin吸收了C#等语言的设计思想，将上述基本类型内置为类，它们具有自己的成员函数和成员属性。这些基本类型包括：数字类型（numbers），字符类型（characters），布尔类型（booleans）和数组类型（arrays）。</p>
<h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><p>Kotlin中的数字类型与Java类似，包括Double、Float、Long、Int、Short、Byte等类型。如上文所述，它们都是类。</p>
<h3 id="字面常量"><a href="#字面常量" class="headerlink" title="字面常量"></a>字面常量</h3><p>Kotlin中的字面常量（literal constants）与Java类似，Int类型支持十进制，直接用普通十进制表示即可；Long类型则需跟上L后缀，如123L表示一个Long型常数，值是123。十六进制加0x前缀，如0x0F表示十六进制数，值是15。二进制加0b前缀，如0b00001011表示二进制数，值是11。Kotlin中不支持八进制数。<br>Kotlin支持通用的浮点数表示法，默认是Double类型，如123.5，123.5e10，如果是Float类型，需要加f或F后缀，如123.5f。</p>
<h3 id="下划线分隔位数"><a href="#下划线分隔位数" class="headerlink" title="下划线分隔位数"></a>下划线分隔位数</h3><p>Kotlin支持在数字常量中使用下划线分隔数位。这能使位数较多的数字具有更强的可读性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> oneMillion = <span class="number">1</span>_000_000 </div><div class="line"><span class="keyword">val</span> creditCardNumber = <span class="number">1234</span>_5678_9012_3456L</div></pre></td></tr></table></figure>
<p>当Kotlin运行于JVM中时，number类型实际上是存储为JVM原生类型，当被赋值给可以为空（nullable）的引用时，Kotlin的number类型是对原生类型的包装。<br>Kotlin中，当使用一个number型常量（val）去初始化一个不可为空的number型常量时，被初始化的常量都指向内存中同一个地址。而当初始化为一个可以为空的常量时，则会在内存中不同地址创建两个常量，并将值赋给它们。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">10000</span> </div><div class="line">print(a === a) <span class="comment">// Prints 'true' </span></div><div class="line"><span class="keyword">val</span> boxedA: <span class="built_in">Int</span> = a </div><div class="line"><span class="keyword">val</span> anotherBoxedA: <span class="built_in">Int</span> = a </div><div class="line">print(boxedA === anotherBoxedA) <span class="comment">// !!!Prints true!!!</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">10000</span> </div><div class="line">print(a === a) <span class="comment">// Prints 'true' </span></div><div class="line"><span class="keyword">val</span> boxedA: <span class="built_in">Int</span>? = a </div><div class="line"><span class="keyword">val</span> anotherBoxedA: <span class="built_in">Int</span>? = a </div><div class="line">print(boxedA === anotherBoxedA) <span class="comment">// !!!Prints 'false'!!!</span></div></pre></td></tr></table></figure>
<p>但即使是赋值给可以为空的常量，依然能保证它们的相等性（equality）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">10000</span> </div><div class="line">print(a == a) <span class="comment">// Prints 'true' </span></div><div class="line"><span class="keyword">val</span> boxedA: <span class="built_in">Int</span>? = a <span class="keyword">val</span> anotherBoxedA: <span class="built_in">Int</span>? = a </div><div class="line">print(boxedA == anotherBoxedA) <span class="comment">// Prints 'true'</span></div></pre></td></tr></table></figure>
<h3 id="宽向扩展"><a href="#宽向扩展" class="headerlink" title="宽向扩展"></a>宽向扩展</h3><p>Kotlin中不存在隐式的宽向类型扩展，即Byte不能直接转换为Int，Int不能直接转换为Double，等等。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> b: <span class="built_in">Byte</span> = <span class="number">1</span> <span class="comment">// OK, literals are checked statically </span></div><div class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = b <span class="comment">// ERROR</span></div></pre></td></tr></table></figure>
<p>每种number类型都能通过内置方法任意转换为另一种number类型。</p>
<h2 id="Characters"><a href="#Characters" class="headerlink" title="Characters"></a>Characters</h2><p>字符类型用Char类表示。与Java不同，它不能被直接当做数字类型使用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(c: <span class="type">Char</span>)</span></span> &#123; </div><div class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) &#123; <span class="comment">// ERROR: incompatible types // ... </span></div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与Java一样，字符字面量使用单引号表示。转义字符使用反斜杠。特殊字符使用反斜杠加u加十六进制数表示。字符可以通过toInt()方法显式转换为Int。<br>与number一样，字符被赋值给一个nullable引用时，唯一性（identity，内存中地址相同）是不被保证的。</p>
<h2 id="Booleans"><a href="#Booleans" class="headerlink" title="Booleans"></a>Booleans</h2><p>用Boolean代表布尔类型，它有两个值：true和false。</p>
<p>布尔类型被赋值给nullable引用时，会被包装。但能保证唯一性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a: <span class="built_in">Boolean</span> = <span class="literal">true</span></div><div class="line">println(a === a) <span class="comment">// Prints 'true'</span></div><div class="line"><span class="keyword">val</span> boxedA: <span class="built_in">Boolean</span>? = a</div><div class="line"><span class="keyword">val</span> anotherBoxedA: <span class="built_in">Boolean</span>? = a</div><div class="line">println(boxedA === anotherBoxedA) <span class="comment">// Prints ‘true’</span></div></pre></td></tr></table></figure>
<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>在Java中，数组其实也是一种对象，只是我们不能显示地获得它的类型表示。在Kotlin中，用Array类来代表数组。它具有get和set方法（通过[]操作符重载了这两个函数），size属性以及其他有用的函数，如迭代器方法iterator()。</p>
<p>创建数组可以使用arrayOf()方法，并传递数组元素给它作为参数。例如arrayOf(1, 2, 3)就创建了一个数组[1, 2, 3]。arrayOfNulls()函数用于创建一个给定长度的数组，并用null元素填充它。</p>
<p>Kotlin也有特定的类代表原生类型的数组，如ByteArray、ShortArray、IntArray等。这些类与Array没有继承关系，但有对应的方法和属性集合。如IntArray有对应的工厂函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> x: IntArray = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) </div><div class="line">x[<span class="number">0</span>] = x[<span class="number">1</span>] + x[<span class="number">2</span>]</div></pre></td></tr></table></figure>
<h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><p>字符串用String类表示。与Java一样，String是不可变类。String的元素是字符，与Java中必须使用charAtIndex()这样一个方法去访问元素不同，Kotlin中可以使用下标运算符[]去访问字符元素。String还能使用for循环很方便地访问。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (c <span class="keyword">in</span> str) &#123; </div><div class="line">    println(c) </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h3><p>Kotlin有两种字符串字面量：一种是可转义的字符串，它可能含有转义字符，它不能表示在多行，除非使用“+”将不同的字符串连接成一个字符串；另一种是原始（raw）字符串，能在多行表示并能包含任意文本。</p>
<p>转义字符串：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> s = <span class="string">"Hello, world!\n"</span></div></pre></td></tr></table></figure>
<p>原始字符串：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> text = <span class="string">""" </span></div><div class="line">    for (c in "foo") print(c) </div><div class="line">"""</div></pre></td></tr></table></figure>
<p>可以使用trimMargin()移除字符串开头和中间的空格，但空格的末尾必须跟上一个明确的分隔符，默认是“|”。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> text = <span class="string">""" </span></div><div class="line">    |Tell me and I forget. </div><div class="line">    |Teach me and I remember. </div><div class="line">    |Involve me and I learn. </div><div class="line">    |(Benjamin Franklin) """.trimMargin()</div><div class="line"><span class="string">"""</span></div></pre></td></tr></table></figure>
<p>也可以显示指定分隔符，如trimMargin(“&gt;”)</p>
<h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><p>在Java中，如果我们在字符串中要加入变量，必须使用加号连接，或者使用格式化字符串。而在Kotlin中，可以使用字符串模板，这将使字符串变得更加简洁，看上去也更加舒服。字符串模板以美元符号开头，直接跟上一个变量名。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> i = <span class="number">10</span> </div><div class="line"><span class="keyword">val</span> s = <span class="string">"i = <span class="subst">$i</span>"</span> <span class="comment">// evaluates to "i = 10"</span></div><div class="line"><span class="string">"""</span></div></pre></td></tr></table></figure>
<p>或者是一个用大括号包裹的任意的表达式。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> s = <span class="string">"abc"</span> </div><div class="line"><span class="keyword">val</span> str = <span class="string">"<span class="subst">$s</span>.length is <span class="subst">$&#123;s.length&#125;</span>"</span> <span class="comment">// evaluates to "abc.length is 3"</span></div><div class="line"><span class="string">"""</span></div></pre></td></tr></table></figure>
<p>模板在原始字符串和转义字符串中都支持。如果你在原始字符串中需要表示美元符号的字面值，可以像下面这样使用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> price = <span class="string">""" </span></div><div class="line"><span class="subst">$&#123;<span class="string">'$'</span>&#125;</span>9.99 </div><div class="line">"""</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kotlin是一门新兴的语言，它可以运行于JVM、JavaScript以及native环境（native正在开发中）。它是由著名软件开发商Jetbrains开发，具备了很多新的特性，能够在开发中提升效率。目前已经成为Android官方支持的开发语言。&lt;br&gt;Kotlin语言
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RabbitMQ的Java客户端（一）</title>
    <link href="http://yoursite.com/2017/05/29/RabbitMQ-HelloWorld/"/>
    <id>http://yoursite.com/2017/05/29/RabbitMQ-HelloWorld/</id>
    <published>2017-05-29T15:50:13.000Z</published>
    <updated>2017-05-29T15:55:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>RabbitMQ是一个常用的消息队列中间件，它能接收并转发消息。在消息通信模型中，系统可分为三部分：生产者，消息服务器和消费者。简单地说，生产者程序产生消息，发布到消息服务器；消费者程序连接到消息服务器，订阅到队列中。每当消息到达特定等队列时，RabbitMQ会将其发送给其中一个订阅/监听的消费者。<br>在RabbitMQ中，生产者并不是直接将消息交给某个消息队列的，而是将消息发送给交换器，发送时会指定投递的规则，这些规则称为路由键。交换器中最简单等一种就是direct交换器。它是一个以空白字符串为名称等默认交换器。当声明一个队列时，默认绑定到direct交换器。direct交换器的规则非常简单：如果路由键（队列名）匹配的话，消息就被投递到对应等队列。如下图所示</p>
<h2 id="Java客户端"><a href="#Java客户端" class="headerlink" title="Java客户端"></a>Java客户端</h2><p>Java是当今流行的服务器应用程序开发语言。RabbitMQ也提供了Java的客户端SDK。用Java实现direct交换器中的生产者示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> com.wts.helloworld;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</div><div class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</div><div class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by weitaosheng on 2017/5/1.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</div><div class="line">        factory.setHost(<span class="string">"localhost"</span>);</div><div class="line">        Connection connection = factory.newConnection();</div><div class="line">        Channel channel = connection.createChannel();</div><div class="line"></div><div class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</div><div class="line">        String message = <span class="string">"Hello World!"</span>;</div><div class="line">        channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</div><div class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</div><div class="line"></div><div class="line">        channel.close();</div><div class="line">        connection.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建一个消息生产者等步骤：</p>
<ol>
<li>新建连接工厂；</li>
<li>绑定RabbitMQ服务器地址（默认为localhost，端口5672）；</li>
<li>获取连接；</li>
<li>建立频道（channel）；</li>
<li>声明队列；</li>
<li>发布消息。</li>
<li>关闭频道；</li>
<li>关闭连接。</li>
</ol>
<p>客户端示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by weitaosheng on 2017/5/1.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</div><div class="line">        factory.setHost(<span class="string">"localhost"</span>);</div><div class="line">        Connection connection = factory.newConnection();</div><div class="line">        Channel channel = connection.createChannel();</div><div class="line"></div><div class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</div><div class="line">        System.out.println(<span class="string">" [*] Waiting for message. To exit press CTRL+C"</span>);</div><div class="line"></div><div class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</div><div class="line">                System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建客户端并订阅队列的步骤：</p>
<ol>
<li>新建连接工厂；</li>
<li>绑定RabbitMQ服务器地址（默认为localhost，端口5672）；</li>
<li>获取连接；</li>
<li>建立频道（channel）；</li>
<li>声明队列；</li>
<li>声明一个消息消费者，本示例中是用一个匿名内部类来扩展了DefaltConsumer类，并重写了handleDelivery方法，该方法定义了接收到消息时进行等处理。</li>
</ol>
<p>以下是客户端SDK关键的类和方法：<br>ConnectionFactory：连接工厂关键类，是客户端访问RabbitMQ服务器必须要先构造的类。从Connection的源代码可以看出，ConnectionFactory没有显示定义构造函数，因此使用的是编译器自动生成的默认构造函数。<br>获取连接的函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">newConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</div><div class="line">    <span class="keyword">return</span> newConnection(<span class="keyword">this</span>.sharedExecutor, Collections.singletonList(<span class="keyword">new</span> Address(getHost(), getPort())));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查看源码，sharedExecutor是一个ExecutorService的实例。此处为null，也就是没有使用线程池。连接时还需要地址和端口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Channel <span class="title">createChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div></pre></td></tr></table></figure></p>
<p>createChannel：生成一个Channel类的实例。Connection是一条真实的TCP连接，Channel是Connection内等一条虚拟连接，它在RabbitMQ中会自动生成唯一的ID。通过一条TCP连接内多个虚拟连接的方式，可以提高性能，节约系统资源，因为TCP连接的创建和销毁是非常昂贵的。<br>Queue.DeclareOk queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete,<br>                             Map<string, object=""> arguments) throws IOException;<br>queueDeclare：声明队列。它的几个参数的含义是：队列名，是否持久化，是否是限制性等队列（仅限于此次连接），是否自动删除消息，其他参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicPublish</span><span class="params">(String exchange, String routingKey, BasicProperties props, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException</span>;</div></pre></td></tr></table></figure></string,></p>
<p>basicPublish：发布消息，几个参数是：交换器名，路由键，是否设置了mandatory参数，消息参数，消息体（用byte数组装载）</p>
<p>Consumer是代表消费者等接口，DefaultConsumer是Consumer接口的一个默认实现。一般定义消费者只需扩展这个类即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></div><div class="line">                           Envelope envelope,</div><div class="line">                           AMQP.BasicProperties properties,</div><div class="line">                           <span class="keyword">byte</span>[] body)</div></pre></td></tr></table></figure></p>
<p>handleDelivery：消费者接收到消息时的回调方法。它的几个参数是：消费者标签，『信封』信息，消息头内容，消息体</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RabbitMQ是一个常用的消息队列中间件，它能接收并转发消息。在消息通信模型中，系统可分为三部分：生产者，消息服务器和消费者。简单地说，生产者程序产生消息，发布到消息服务器；消费者程序连接到消息服务器，订阅到队列中。每当消息到达特定等队列时，RabbitMQ会将其发送给其
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java中synchronized关键字的研究</title>
    <link href="http://yoursite.com/2017/03/01/Java-synchronized/"/>
    <id>http://yoursite.com/2017/03/01/Java-synchronized/</id>
    <published>2017-03-01T12:23:47.000Z</published>
    <updated>2017-03-01T12:26:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中，每一个线程都有一个内部锁。当我们使用<strong>synchronized</strong>关键字时，就是利用这个内部锁来实现线程对某个对象的锁定控制。<br>那么，如果某个对象中有两个方法，方法一和方法二都使用了synchronized关键字。如果线程一执行该对象的方法一，线程二执行该对象的方法二。如果线程1一直不释放该对象的内部锁的话，那么线程二应该无法执行该对象的方法二。下面就用代码来验证一下。<br>首先，定义一个Task类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> corejava.chapter14;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskC</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            System.out.println(<span class="string">"我是方法1"</span>);</div><div class="line">            Thread.sleep(<span class="number">10000</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            System.out.println(<span class="string">"我是方法2"</span>);</div><div class="line">            Thread.sleep(<span class="number">10000</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>method1每隔10秒就会输出一句“我是方法1”。method2每隔10秒就会输出一句“我是方法2”。两个方法都使用了synchronized关键字。  </p>
<p>再定义两个执行类ExecutorC1和Executor2。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> corejava.chapter14;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorC1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> TaskC taskC;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutorC1</span><span class="params">(TaskC taskC)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.taskC = taskC;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            taskC.method1();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> corejava.chapter14;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorC2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> TaskC taskC;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutorC2</span><span class="params">(TaskC taskC)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.taskC = taskC;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            taskC.method2();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行对象1和执行对象2都使用同一个taskC去实例化，这样他们之间就会存在竞争。当thread1执行taskC的method1时，会一直持有taskC的内部锁，因此thread2将一直处于阻塞状态。  </p>
<p>下面是运行输出结果<br><img src="/images/synchronized.png" alt="">  </p>
<p>可见，确实如我们所料，虽然两个线程要执行的是不同的方法，但因为线程1一直“霸占”着内部锁，所以线程2始终在阻塞状态，得不到执行。  </p>
<p>所以，如果我们在对某个类要使用synchronized关键字进行锁定控制时，一定要牢记它使用的是该类的内部锁。它是唯一的。当多个方法都用它来进行控制时，一定要考虑这一点。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java中，每一个线程都有一个内部锁。当我们使用&lt;strong&gt;synchronized&lt;/strong&gt;关键字时，就是利用这个内部锁来实现线程对某个对象的锁定控制。&lt;br&gt;那么，如果某个对象中有两个方法，方法一和方法二都使用了synchronized关键字。如果线程一执
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java集合中的ArrayList类（一）：构造实例和添加元素</title>
    <link href="http://yoursite.com/2017/03/01/ArrayList/"/>
    <id>http://yoursite.com/2017/03/01/ArrayList/</id>
    <published>2017-02-28T16:59:03.000Z</published>
    <updated>2017-03-12T14:51:15.000Z</updated>
    
    <content type="html"><![CDATA[<p>ArrayList有三个构造器，分别是无参构造器，传入一个整形参数的构造器，以及传入一个Collection实例的构造器。本文主要介绍前两种构造器。</p>
<h2 id="无参构造器"><a href="#无参构造器" class="headerlink" title="无参构造器"></a>无参构造器</h2><p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        strings.add(<span class="string">"abc"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面看调用构造器以及添加元素的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 用初始的10的容量大小构造一个空的list</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上述构造器可以看出，无参构造器只是很简单将常量DEFAULTCAPACITY_EMPTY_ELEMENTDATA赋给成员变量elementData。这个成员变量和常量如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Shared empty array instance used for default sized empty instances. We</div><div class="line"> * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</div><div class="line"> * first element is added.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The array buffer into which the elements of the ArrayList are stored.</div><div class="line"> * The capacity of the ArrayList is the length of this array buffer. Any</div><div class="line"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</div><div class="line"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></div></pre></td></tr></table></figure>
<p>从注释可以看出，DEFAULTCAPACITY_EMPTY_ELEMENTDATA是一个空的数组实例，用来作为默认大小的空List。它与EMPTY_ELEMENTDATA同时存在，是为了当第一个元素被添加到list中时，能算出要扩展多大的容量。</p>
<p>elementData是ArrayList中用于实际存储元素的数组。一个ArrayList实例的容量就是这个数组的长度。任何调用了默认构造器生成的ArrayList实例，都执行了elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA，当第一个元素被添加到list中时，都会被扩展到默认的容量大小，即DEFAULT_CAPACITY（10）。</p>
<p>末尾添加元素的函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* Appends the specified element to the end of this list.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> e element to be appended to this list</div><div class="line">* <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">    <span class="comment">// 扩容之后将新增的元素加到末尾，同时将list的size加一。</span></div><div class="line">    elementData[size++] = e;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法首先调用了ensureCapacityInternal函数，用于确保容量足以添加一个元素。ensureCapacityInternal方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123; <span class="comment">// 插入“abc”时，minCapacity为1</span></div><div class="line">    <span class="comment">// 当调用无参构造器时，初始存储元素的数组是DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></div><div class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</div><div class="line">        <span class="comment">// 比较参数和默认容量大小，取大者作为扩展多容量</span></div><div class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); <span class="comment">// minCapacity变为10</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ensureExplicitCapacity(minCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后调用了ensureExplicitCapacity函数，继续扩展容量大操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line"></div><div class="line">    <span class="comment">// 检查目标容量是否大于当前数组的实际长度</span></div><div class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述方法继续调用grow函数，完成扩容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Increases the capacity to ensure that it can hold at least the</div><div class="line"> * number of elements specified by the minimum capacity argument.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="comment">// 容量扩充增量为当前数组容量大50%</span></div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">    <span class="comment">// 若扩充后仍达不到目标容量，则直接使用目标容量作为新容量</span></div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="comment">// 若超过最大容量，则调用hugeCapacity函数</span></div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">        newCapacity = hugeCapacity(minCapacity);</div><div class="line">    <span class="comment">// 调用工具函数扩容，末尾用null补全</span></div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从注释可知，该方法增长容量以确保list至少能保存传入参数大小数量多元素。之后，就可以插入元素“abc”。插入之后，list的size为1，容量为10.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ArrayList有三个构造器，分别是无参构造器，传入一个整形参数的构造器，以及传入一个Collection实例的构造器。本文主要介绍前两种构造器。&lt;/p&gt;
&lt;h2 id=&quot;无参构造器&quot;&gt;&lt;a href=&quot;#无参构造器&quot; class=&quot;headerlink&quot; title=&quot;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Java IO 中的PushbackInputStream类</title>
    <link href="http://yoursite.com/2017/03/01/PushbackInputStream/"/>
    <id>http://yoursite.com/2017/03/01/PushbackInputStream/</id>
    <published>2017-02-28T16:59:03.000Z</published>
    <updated>2017-03-11T04:57:23.000Z</updated>
    
    <content type="html"><![CDATA[<p>PushbackInputstream类是Java IO中的一个较特别的类，因为它可以将读出的字节再推回流中。这也就是它的名字中Pushback的由来。下面首先介绍一下它的基本用法，再分析一下它的源代码。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>首先需要构造一个PushbackInputStream对象，这个对象需要传入一个InputStream实例作为参数。之后从该InputStream绑定的数据源（例如一个文件、或者网络流）读入数据，然后将读出的数据再推回PushBackInputStream中。<br>如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PushbackInputStreamTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        </div><div class="line">        PushbackInputStream inputStream = <span class="keyword">new</span> PushbackInputStream(</div><div class="line">                                                <span class="keyword">new</span> FileInputStream(<span class="string">"input.txt"</span>));</div><div class="line">        <span class="keyword">int</span> data = inputStream.read();</div><div class="line">        System.out.println(data);</div><div class="line">        inputStream.unread(data);</div><div class="line">        data = inputStream.read();</div><div class="line">        System.out.println(data);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>文件中保存着一个字符串abcdefg。输出如下：</p>
<p>Read before push back: 97<br>Read after push back: 97</p>
<p>可见，我们读出了一个字符a（它的ascii码是97），之后又成功推回了流中。</p>
<p>如果我们需要一次推回多个字符，则需要在构造PushbackInputStream实例时传入一个整型参数，用于指定每次推回多最大字节数。<br>如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PushbackInputStreamTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line"></div><div class="line">        PushbackInputStream input = <span class="keyword">new</span> PushbackInputStream(</div><div class="line">                                            <span class="keyword">new</span> FileInputStream(<span class="string">"input.txt"</span>), <span class="number">10</span>);</div><div class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</div><div class="line">        <span class="keyword">int</span> r = input.read(bytes);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</div><div class="line">            System.out.println(b);</div><div class="line">        &#125;</div><div class="line">        input.unread(bytes);</div><div class="line">        r = input.read(bytes);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</div><div class="line">            System.out.println(b);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br>Read before push back:<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>0<br>0<br>0<br>Read after push back:<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>0<br>0<br>0</p>
<p>可见，我们可以一次读入最多10个字节（因为数据只有7个字节，所以剩余字节为0.</p>
<p>如果推回多字节大于构造函数中指定的最大字节数，则会发生异常：</p>
<p>java.io.IOException: Push back buffer is full</p>
<p>下面分析一下PushbackInputStream的源代码</p>
<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 缓冲区，被推回的字节将会保存在这里</div><div class="line"> */</div><div class="line"><span class="keyword">protected</span> <span class="keyword">byte</span>[] buf;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 从缓冲区读取数据时的位置，也就是读取被推回的数据时的下标。当缓冲区为空时，pos为buf.length（即没有推回数据，故不能从缓冲区读取）；当缓冲区所有字节均有数据时，则pos为0</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">protected</span> <span class="keyword">int</span> pos;</div></pre></td></tr></table></figure>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 通过指定size的缓冲数组以及一个InputStream实例，来构造一个PushbackInputStream对象</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">PushbackInputStream</span><span class="params">(InputStream in, <span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(in);</div><div class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"size &lt;= 0"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</div><div class="line">    <span class="keyword">this</span>.pos = size;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 若不指定缓冲区大小，则默认为1，即每次只能推回一个字节</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">PushbackInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(in, <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 读取数据，若缓冲区有数据，则从缓冲区的pos位置开始读取；若缓冲区无数据，则调用超类的read方法读取数据</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">// 确保流没有关闭</span></div><div class="line">    ensureOpen();</div><div class="line">    <span class="keyword">if</span> (pos &lt; buf.length) &#123;</div><div class="line">        <span class="keyword">return</span> buf[pos++] &amp; <span class="number">0xff</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.read();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 将数据读入一个byte数组中，参数off是目标数组中的起始偏移量，参数len是读入数据的最大字节数</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    ensureOpen();</div><div class="line">    <span class="comment">// 校验参数是否合法，b不能为null，off不能为负，且读入的最大字节数不能超过数组所能接受的最大字节数。</span></div><div class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || len &gt; b.length - off) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 计算缓冲数组中的数据字节数</span></div><div class="line">    <span class="keyword">int</span> avail = buf.length - pos;</div><div class="line">    <span class="comment">// 从缓冲区中读取数据</span></div><div class="line">    <span class="keyword">if</span> (avail &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (len &lt; avail) &#123;</div><div class="line">            avail = len;</div><div class="line">        &#125;</div><div class="line">        System.arraycopy(buf, pos, b, off, avail);</div><div class="line">        pos += avail;</div><div class="line">        off += avail;</div><div class="line">        len -= avail;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 若要读取的数据数超过了缓冲区的数据数，则读完被推回的数据后，继续从包裹的InputStream中读取数据</span></div><div class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</div><div class="line">        len = <span class="keyword">super</span>.read(b, off, len);</div><div class="line">        <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</div><div class="line">            <span class="comment">// 缓冲区无数据，包裹的InputStream也没有数据</span></div><div class="line">            <span class="keyword">return</span> avail == <span class="number">0</span> ? -<span class="number">1</span> : avail;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> avail + len;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> avail;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="推回数据"><a href="#推回数据" class="headerlink" title="推回数据"></a>推回数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 推回一个字节数据，即将它拷贝到本类的缓冲数组中</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unread</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    ensureOpen();</div><div class="line">    <span class="comment">// pos为0说明缓冲数组已满</span></div><div class="line">    <span class="keyword">if</span> (pos == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Push back buffer is full"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 从后往前赋值</span></div><div class="line">    buf[--pos] = (<span class="keyword">byte</span>)b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 推回字节数组的一部分到缓冲数组中，</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unread</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    ensureOpen();</div><div class="line">    <span class="keyword">if</span> (len &gt; pos) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Push back buffer is full"</span>);</div><div class="line">    &#125;</div><div class="line">    pos -= len;</div><div class="line">    System.arraycopy(b, off, buf, pos, len);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上就是这个类的主要方法。我们可以看出，当单个推回数据时，是逆序插入缓冲数组，同时读取数据时，是正序读出。所以是后入先出。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PushbackInputstream类是Java IO中的一个较特别的类，因为它可以将读出的字节再推回流中。这也就是它的名字中Pushback的由来。下面首先介绍一下它的基本用法，再分析一下它的源代码。&lt;/p&gt;
&lt;h2 id=&quot;使用方法&quot;&gt;&lt;a href=&quot;#使用方法&quot; 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>《Java核心技术（英文版）》读书笔记：Object类的equals方法</title>
    <link href="http://yoursite.com/2017/03/01/hello-world/"/>
    <id>http://yoursite.com/2017/03/01/hello-world/</id>
    <published>2017-02-28T16:59:03.000Z</published>
    <updated>2017-03-06T15:33:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>Object类是Java中的一个全局超类——每一个Java类都扩展了它。但是你不必显示地如下声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Object</span></span></div></pre></td></tr></table></figure>
<h2 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h2><h3 id="引用同一"><a href="#引用同一" class="headerlink" title="引用同一"></a>引用同一</h3><p>equals方法是Object类中用于判断一个对象和另一个对象是否相等的方法。在Object类中的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从源代码可知，该实现是检查两个对象的引用是否相等，也即是检查两个对象是否指向Java堆中的同一个对象。这是因为，如果两个对象的引用指向同一个Java堆中的对象，则这两个对象必然是相等的。对极少数类的<br>对象来说，这个实现已经足够了。例如两个PrintStream对象。</p>
<h3 id="状态相等"><a href="#状态相等" class="headerlink" title="状态相等"></a>状态相等</h3><p>如上文所述，对大多数类来说，Object中的equals实现是不够用的。因为很多时候，我们认为两个对象相等是基于它们具有相同的状态（即对象的属性，field）。例如，两个Employee对象，如果它们具有相同的姓名（name），<br>工资（salary）和雇佣日期（hire day），那它们就是相等的。它的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object otherObject)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == otherObject)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (otherObject == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span> (getClass() ！= otherObject.getClass())</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        Employee other = (Employee) otherObject;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> name.equals(other.name)</div><div class="line">            &amp;&amp; salary == other.salary;</div><div class="line">            &amp;&amp; hireDay.equals(other.hireDay);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码中，首先判断两个对象是否同一，其次判断被比较对象是否为null，再次比较两个对象所属的类是否相同（在此处，假定必须类相同才有可能相等），最后比较各个状态是否相等。注意如果状态也是对象的话，<br>则会递归调用它们的equals方法。</p>
<p>这里要注意的是，Employee对象的name和hireDay等状态是有可能为null的，为了确保在这种情况下程序也是正确的，可以使用Objects.equals方法。调用Objects.equals(a, b)，若两个参数都是null返回true，<br>若其中一个为null返回false，以上都不成立则调用a.equals(b)。因此，上面方法的最后一条语句可修改为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> Objects.equals(name, other.name)</div><div class="line">    &amp;&amp; salary == other.salary;</div><div class="line">    &amp;&amp; Objects.equals(hireDay, other.hireDay);</div></pre></td></tr></table></figure>
<p>当在扩展类中定义了equals方法时，须首先调用超类的equals方法，如果返回false，则两个对象不可能相等。若返回true，即是超类定义的状态相等。则继续比较子类定义的状态。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Object类是Java中的一个全局超类——每一个Java类都扩展了它。但是你不必显示地如下声明：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;
    
    </summary>
    
    
  </entry>
  
</feed>
