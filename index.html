
 <!DOCTYPE HTML>
<html >
<head>
  <meta charset="UTF-8">
  
    <title>博浪</title>
    <meta name="viewport" content="width=device-width, initial-scale=1,user-scalable=no">
    
    <meta name="author" content="wts">
    

    
    <meta name="description" content="abcdefg">
<meta property="og:type" content="website">
<meta property="og:title" content="博浪">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="博浪">
<meta property="og:description" content="abcdefg">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="博浪">
<meta name="twitter:description" content="abcdefg">

    
    <link rel="alternative" href="/atom.xml" title="博浪" type="application/atom+xml">
    
    
    <link rel="icon" href="/img/favicon.ico">
    
    
    <link rel="apple-touch-icon" href="/img/jacman.jpg">
    <link rel="apple-touch-icon-precomposed" href="/img/jacman.jpg">
    
    <link rel="stylesheet" href="/css/style.css">
</head>

  <body>
    <header>
      
<div>
		
			<div id="textlogo">
				<h1 class="site-name"><a href="/" title="博浪">博浪</a></h1>
				<h2 class="blog-motto"></h2>
			</div>
			<div class="navbar"><a class="navbutton navmobile" href="#" title="Menu">
			</a></div>
			<nav class="animated">
				<ul>
					<ul>
					 
						<li><a href="/">Home</a></li>
					
						<li><a href="/archives">Archives</a></li>
					
						<li><a href="/about">About</a></li>
					
					<li>
 					
					<form class="search" action="//google.com/search" method="get" accept-charset="utf-8">
						<label>Search</label>
						<input type="search" id="search" name="q" autocomplete="off" maxlength="20" placeholder="Search" />
						<input type="hidden" name="q" value="site:yoursite.com">
					</form>
					
					</li>
				</ul>
			</nav>			
</div>
    </header>
    <div id="container">
      <div id="main">

   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/08/20/dubbo同步调用的实现机制/" title="Dubbo的同步调用在消费者端的实现机制" itemprop="url">Dubbo的同步调用在消费者端的实现机制</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="wts" target="_blank" itemprop="author">wts</a>
		
  <p class="article-time">
    <time datetime="2018-08-19T16:00:00.000Z" itemprop="datePublished"> Published 2018-08-20</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="Dubbo的同步调用"><a href="#Dubbo的同步调用" class="headerlink" title="Dubbo的同步调用"></a>Dubbo的同步调用</h2><p>使用Dubbo很长时间了，基本使用的都是Dubbo的同步调用方式。Dubbo默认使用的是协议格式Dubbo协议，序列化方式是Hessian，传输层使用的是Tcp协议，默认使用netty框架。</p>
<p>Dubbo的同步调用是指，调用一个远程服务时，发起调用这个线程会一直阻塞（至少从使用者的感觉来说是这样的）到远程服务返回结果，或是超时为止。</p>
<p>那么Dubbo是如何实现这种同步调用机制的呢？我们知道RPC的本质是用TCP协议向另一个进程（可能在同一台机器上，也可能不在）发送请求，服务端进程接收到请求后，将请求解析为对本地方法的一个调用，调用之后将结果返回给客户端。客户端接收到返回之后，再将结果反序列化为需要的结果，返回给上层的业务。</p>
<h2 id="Dubbo同步调用在客户端的实现"><a href="#Dubbo同步调用在客户端的实现" class="headerlink" title="Dubbo同步调用在客户端的实现"></a>Dubbo同步调用在客户端的实现</h2><p>Dubbo的整个调用流程是：<br>1.服务提供者导出服务到本机的IP和端口上，即是建立一个TCP服务器；<br>2.服务提供者发布服务到注册中心；<br>3.服务消费者向注册中心订阅服务提供者的信息；<br>4.服务消费者建立远程服务的代理，并建立一个TCP客户端。</p>
<p>以上几步分别是服务提供者和服务消费者启动时做的事情，这之后消费者和提供者之间就建立了TCP长连接，实际调用服务时是无需经过注册中心的，直接通过TCP连接完成。</p>
<p>下面就来看一下消费者是如何发起到提供者的请求，以及如何实现对上层业务而言的同步调用，以及超时机制等。</p>
<p>Dubbo消费者在发起调用之后，经过重重阻隔，经历了各种包装的代理类之后（暂时忽略集群容错和负载均衡等），最终会到达下面这个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DubboInvoker</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractInvoker</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">// 省略大量代码</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> Result <span class="title">doInvoke</span><span class="params">(<span class="keyword">final</span> Invocation invocation)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="comment">//省略大量代码</span></div><div class="line">        <span class="keyword">return</span> (Result) currentClient.request(inv, timeout).get();</div></pre></td></tr></table></figure>
<p>最后这个return语句返回的就是最终调用返回的结果。再进入这个request方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HeaderExchangeChannel</span> <span class="keyword">implements</span> <span class="title">ExchangeChannel</span> </span>&#123;</div><div class="line">    <span class="comment">// 省略大量代码</span></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> ResponseFuture <span class="title">request</span><span class="params">(Object request, <span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (closed) &#123;</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemotingException(<span class="keyword">this</span>.getLocalAddress(), <span class="keyword">null</span>, <span class="string">"Failed to send request "</span> + request + <span class="string">", cause: The channel "</span> + <span class="keyword">this</span> + <span class="string">" is closed!"</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// create request.</span></div><div class="line">        Request req = <span class="keyword">new</span> Request();</div><div class="line">        req.setVersion(Version.getProtocolVersion());</div><div class="line">        req.setTwoWay(<span class="keyword">true</span>);</div><div class="line">        req.setData(request);</div><div class="line">        DefaultFuture future = <span class="keyword">new</span> DefaultFuture(channel, req, timeout);</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            channel.send(req);</div><div class="line">        &#125; <span class="keyword">catch</span> (RemotingException e) &#123;</div><div class="line">            future.cancel();</div><div class="line">            <span class="keyword">throw</span> e;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> future;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>我们看到，在这个方法中，先是创建了发送给提供者服务的请求request，之后创建了一个DefaultFuture的类。最好就调用channel将请求发送出去（此处的channel是dubbo定义的一个类的实例，但内部包装了netty的channel）。</p>
<p>我们看到，调用channel的send方法发送请求，但这个方法并没有返回值。而是在下方直接返回了这个DefaultFuture类的实例。</p>
<p>再回到上面DubboInvoke中，在request返回了DefaultFuture实例之后，就调用get方法去获取调用结果。因此再看get方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> RemotingException </span>&#123;</div><div class="line">        <span class="keyword">return</span> get(timeout);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">get</span><span class="params">(<span class="keyword">int</span> timeout)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</div><div class="line">        <span class="keyword">if</span> (timeout &lt;= <span class="number">0</span>) &#123;</div><div class="line">            timeout = Constants.DEFAULT_TIMEOUT;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!isDone()) &#123;</div><div class="line">            <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">            lock.lock();</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="keyword">while</span> (!isDone()) &#123;</div><div class="line">                    done.await(timeout, TimeUnit.MILLISECONDS);</div><div class="line">                    <span class="keyword">if</span> (isDone() || System.currentTimeMillis() - start &gt; timeout) &#123;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</div><div class="line">            &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                lock.unlock();</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (!isDone()) &#123;</div><div class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(sent &gt; <span class="number">0</span>, channel, getTimeoutMessage(<span class="keyword">false</span>));</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> returnFromResponse();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>到这个方法中就清除了，首先判断一下调用是否有返回结果，如果还没有返回，就先记录一下当前时间，之后用一个可重入锁将代码块加锁。之后在一个while循环条件中判断调用是否有返回。若没有返回就直接将线程进入等待状态，只有另一个线程向它发信号，才能唤醒它继续执行。唤醒之后，再次判断是否有返回，或是已经超时，则跳出循环。之后判断若没有返回，则已经超时。若有返回结果，则正常返回结果。</p>
<p>那么哪里有一个线程会来唤醒这个调用线程呢？</p>
<p>答案就是netty提供的机制，netty客户端在发送请求给服务端，当有结果返回时，会触发事先注册的处理器，将请求通知上层调用。最终会调用到DefaultFuture中的received方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">received</span><span class="params">(Channel channel, Response response)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            DefaultFuture future = FUTURES.remove(response.getId());</div><div class="line">            <span class="keyword">if</span> (future != <span class="keyword">null</span>) &#123;</div><div class="line">                future.doReceived(response);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                logger.warn(<span class="string">"The timeout response finally returned at "</span></div><div class="line">                        + (<span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd HH:mm:ss.SSS"</span>).format(<span class="keyword">new</span> Date()))</div><div class="line">                        + <span class="string">", response "</span> + response</div><div class="line">                        + (channel == <span class="keyword">null</span> ? <span class="string">""</span> : <span class="string">", channel: "</span> + channel.getLocalAddress()</div><div class="line">                        + <span class="string">" -&gt; "</span> + channel.getRemoteAddress()));</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            CHANNELS.remove(response.getId());</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReceived</span><span class="params">(Response res)</span> </span>&#123;</div><div class="line">        lock.lock();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            response = res;</div><div class="line">            <span class="keyword">if</span> (done != <span class="keyword">null</span>) &#123;</div><div class="line">                done.signal();</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            lock.unlock();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</div><div class="line">            invokeCallback(callback);</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure></p>
<p>首先是获取当前调用的DefaultFuture实例，之后调用它的doReceived方法。这个方法先加了锁，之后将返回结果赋给DefaultFuture的response（这个response是DefaultFuture的一个实例属性，也就是上层业务要获取的结果）。之后就是上面说的向线程发信号，唤醒等待中的调用线程。</p>
<p>以上就是Dubbo将底层的netty的异步调用转为同步调用。还有一个问题是dubbo是如何实现接口调用超时的。</p>
<p>答案在下面：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultFuture</span> <span class="keyword">implements</span> <span class="title">ResponseFuture</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Long, DefaultFuture&gt; FUTURES = <span class="keyword">new</span> ConcurrentHashMap&lt;Long, DefaultFuture&gt;();</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">static</span> &#123;</div><div class="line">        Thread th = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RemotingInvocationTimeoutScan(), <span class="string">"DubboResponseTimeoutScanTimer"</span>);</div><div class="line">        th.setDaemon(<span class="keyword">true</span>);</div><div class="line">        th.start();</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>DefaultFuture中用了一个FUTURES的map来保存每个具体调用的DefaultFuture实例。它的key是每次调用的id，这个id就是用来区分不同的调用的，每个请求都不一样。之后在初始化这个类时，启动一个守护线程，它就是用来实现超时的。它的run方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RemotingInvocationTimeoutScan</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    <span class="keyword">for</span> (DefaultFuture future : FUTURES.values()) &#123;</div><div class="line">                        <span class="keyword">if</span> (future == <span class="keyword">null</span> || future.isDone()) &#123;</div><div class="line">                            <span class="keyword">continue</span>;</div><div class="line">                        &#125;</div><div class="line">                        <span class="keyword">if</span> (System.currentTimeMillis() - future.getStartTimestamp() &gt; future.getTimeout()) &#123;</div><div class="line">                            <span class="comment">// create exception response.</span></div><div class="line">                            Response timeoutResponse = <span class="keyword">new</span> Response(future.getId());</div><div class="line">                            <span class="comment">// set timeout status.</span></div><div class="line">                            timeoutResponse.setStatus(future.isSent() ? Response.SERVER_TIMEOUT : Response.CLIENT_TIMEOUT);</div><div class="line">                            timeoutResponse.setErrorMessage(future.getTimeoutMessage(<span class="keyword">true</span>));</div><div class="line">                            <span class="comment">// handle response.</span></div><div class="line">                            DefaultFuture.received(future.getChannel(), timeoutResponse);</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line">                    Thread.sleep(<span class="number">30</span>);</div><div class="line">                &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">                    logger.error(<span class="string">"Exception when scan the timeout invocation of remoting."</span>, e);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>逻辑很简单，就是每30毫秒轮询一次所有的DefaultFuture，若future已经有返回结果，则跳过；若没有返回，则计算一下当前时间是否超时，若超时，则构造一个超时的返回结果，之后调用上面提到的DefaultFuture的received方法。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是Dubbo同步调用在消费者端的大体实现。主要就是用了一个锁来将调用线程阻塞起来，之后netty接收到返回结果之后，会发信号唤醒调用线程。或是超时，也会返回一个超时的结果，并唤醒调用线程。这样就实现了对上层业务来说的同步调用。<br>因为Dubbo的流程非常复杂，因此本篇文章限于篇幅，无法将它的上下游流程勾勒得很清楚。只是提纲挈领地写出关键之处。对于整体流程的把握，还是需要自己去研究代码才行。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/08/12/FutureTask的简单使用和源码解析/" title="FutureTask的简单实用和源码解析" itemprop="url">FutureTask的简单实用和源码解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="wts" target="_blank" itemprop="author">wts</a>
		
  <p class="article-time">
    <time datetime="2018-08-11T16:00:00.000Z" itemprop="datePublished"> Published 2018-08-12</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="从一个问题说起"><a href="#从一个问题说起" class="headerlink" title="从一个问题说起"></a>从一个问题说起</h2><p>假设有4个方法，可以获取四个值，这四个值可以用来构造一个用户的实例。如果要写一个方法，并发获取这4个值。</p>
<p>这个题目应该用Future来做。下面是我模拟的程序。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 服务类，有4个方法</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Service</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get1</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">1000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">1</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get2</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">2000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">2</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get3</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">3000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">3</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">get4</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Thread.sleep(<span class="number">4000</span>);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="number">4</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTaskTest</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Service service = <span class="keyword">new</span> Service();</div><div class="line">        <span class="comment">/** 记录开始执行时间 */</span></div><div class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</div><div class="line">        <span class="comment">/**</span></div><div class="line">         * 用4个FutureTask来并行执行service的4个方法, 执行完之后一并</div><div class="line">         * 获取执行结果</div><div class="line">         */</div><div class="line">        FutureTask&lt;Integer&gt; futureTask1 = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                <span class="keyword">return</span> service.get1();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        Thread thread1 = <span class="keyword">new</span> Thread(futureTask1);</div><div class="line">        thread1.start();</div><div class="line"></div><div class="line">        FutureTask&lt;Integer&gt; futureTask2 = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                <span class="keyword">return</span> service.get2();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        Thread thread2 = <span class="keyword">new</span> Thread(futureTask2);</div><div class="line">        thread2.start();</div><div class="line"></div><div class="line">        FutureTask&lt;Integer&gt; futureTask3 = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                <span class="keyword">return</span> service.get3();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        Thread thread3 = <span class="keyword">new</span> Thread(futureTask3);</div><div class="line">        thread3.start();</div><div class="line"></div><div class="line">        FutureTask&lt;Integer&gt; futureTask4 = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                <span class="keyword">return</span> service.get4();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        Thread thread4 = <span class="keyword">new</span> Thread(futureTask4);</div><div class="line">        thread4.start();</div><div class="line"></div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">int</span> a = futureTask1.get();</div><div class="line">            <span class="keyword">int</span> b = futureTask2.get();</div><div class="line">            <span class="keyword">int</span> c = futureTask3.get();</div><div class="line">            <span class="keyword">int</span> d = futureTask4.get();</div><div class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</div><div class="line">            System.out.println(end - start);</div><div class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>执行结果，打印执行时间为4007毫秒，与预期相同，也就是并行执行4个任务中耗时最长的一个。</p>
<p>下面就来分析FutureTask的原理。</p>
<h2 id="FutureTask的使用"><a href="#FutureTask的使用" class="headerlink" title="FutureTask的使用"></a>FutureTask的使用</h2><p>Java中，使用线程执行任务一般实现Runnable接口。它只有一个run方法，没有返回值。因此当主线程需要用一个子线程去执行某个任务，并返回某个结果时，必须采用其他的方法。比如在Thread中添加一个实例，然后运行run方法时去修改这个值。但这有一个问题，就是主线程并不知道子线程何时执行结束。因此又引出其他的问题。显然仅靠Runnable并不是解决这类问题的好方法。</p>
<p>因此，Java提供了Callable接口，它代表一个能返回执行结果的任务。它的定义如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * Computes a result, or throws an exception if unable to do so.</div><div class="line">     *</div><div class="line">     * <span class="doctag">@return</span> computed result</div><div class="line">     * <span class="doctag">@throws</span> Exception if unable to compute a result</div><div class="line">     */</div><div class="line">    <span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个接口有一个参数类型V，同时只有一个方法call。当call方法执行完之后，会返回一个V类型的实例。</p>
<p>但是我们遍览jdk的类库，发现并没有一个public的类是实现了Callable接口的。因此它是一个完全由用户实现的接口，必须搭配其他的接口和类才能使用。</p>
<p>于是java又提供了Future接口：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 取消任务执行，参数代表如果任务已经开始执行，是否要中断</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 判断任务是否已经取消</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 判断任务是否执行完成</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取线程执行的结果</div><div class="line">     */</div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 获取线程执行结果，并设置一个超时时间，若超过了则抛出异常</div><div class="line">     */</div><div class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></div><div class="line">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这个接口的注释说：这个接口代表了一次异步计算的结果。所谓异步计算，也就是代表一个线程。</p>
<h2 id="FutureTask源码解析"><a href="#FutureTask源码解析" class="headerlink" title="FutureTask源码解析"></a>FutureTask源码解析</h2><p>通过上面的例子，我们可以通过推理和验证的方式来研究FutureTask的源码实现。首先FutureTask能作为参数传递给Thread类来实例化一个线程，说明它实现了Runnable接口。同时它也实现了Future接口，否则我们这篇文章也不会写它了。</p>
<p>于是我们看FutureTask的定义头:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FutureTask</span>&lt;<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; </span>&#123;</div></pre></td></tr></table></figure></p>
<p>而RunnableFuture的定义头：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt;</span></div></pre></td></tr></table></figure></p>
<p>果如所料。</p>
<p>再从上面的例子中可以看出，FutureTask的构造方法的参数是一个Callable接口。那说明它内部就是通过一个Callable实例来执行具体的逻辑的，并且Callable的实现类是由用户提供的。FutureTask的构造方法如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    <span class="keyword">this</span>.callable = callable;</div><div class="line">    <span class="keyword">this</span>.state = NEW;       <span class="comment">// ensure visibility of callable</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从构造方法可以看出，FutureTask还有一个实例属性是state，并且在构造方法中被初始化为NEW。这个属性和可能的值定义如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">     * 任务运行状态，初始化为NEW，这个状态变量只会在set方法、setException和cancel方法中被转化为终态</div><div class="line">     *</div><div class="line">     * Possible state transitions:</div><div class="line">     * NEW -&gt; COMPLETING -&gt; NORMAL</div><div class="line">     * NEW -&gt; COMPLETING -&gt; EXCEPTIONAL</div><div class="line">     * NEW -&gt; CANCELLED</div><div class="line">     * NEW -&gt; INTERRUPTING -&gt; INTERRUPTED</div><div class="line">     */</div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NEW          = <span class="number">0</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COMPLETING   = <span class="number">1</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL       = <span class="number">2</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCEPTIONAL  = <span class="number">3</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED    = <span class="number">4</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTING = <span class="number">5</span>;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> INTERRUPTED  = <span class="number">6</span>;</div></pre></td></tr></table></figure>
<p>详细的状态转化在下面方法中介绍。</p>
<p>构造了FutureTask之后，就需要用一个Thread去执行它。Thread执行它持有的Runnable实例的run方法。那么我们看一下FutureTask的run方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// 若state不为NEW，或者不能将执行此FutureTask的线程赋值给FutureTask的Thread属性，则放弃执行</span></div><div class="line">    <span class="keyword">if</span> (state != NEW ||</div><div class="line">        !UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, runnerOffset,</div><div class="line">                                     <span class="keyword">null</span>, Thread.currentThread()))</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        Callable&lt;V&gt; c = callable;</div><div class="line">        <span class="comment">// 再次判断state必须为NEW才执行</span></div><div class="line">        <span class="keyword">if</span> (c != <span class="keyword">null</span> &amp;&amp; state == NEW) &#123;</div><div class="line">            V result;</div><div class="line">            <span class="keyword">boolean</span> ran;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                <span class="comment">// 执行Callable方法，获取结果</span></div><div class="line">                result = c.call();</div><div class="line">                ran = <span class="keyword">true</span>;</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">                <span class="comment">// 捕获异常时处理异常</span></div><div class="line">                result = <span class="keyword">null</span>;</div><div class="line">                ran = <span class="keyword">false</span>;</div><div class="line">                setException(ex);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 执行正常结束时设置结果</span></div><div class="line">            <span class="keyword">if</span> (ran)</div><div class="line">                set(result);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        <span class="comment">// runner在将state设置为能阻止对run的并发调用前必须保持非null的值</span></div><div class="line">        runner = <span class="keyword">null</span>;</div><div class="line">        <span class="comment">// 再次读取state，若为正在中断中，或已中断，则进行相应处理</span></div><div class="line">        <span class="keyword">int</span> s = state;</div><div class="line">        <span class="keyword">if</span> (s &gt;= INTERRUPTING)</div><div class="line">            handlePossibleCancellationInterrupt(s);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>进入run方法时，用了Oracle的私有api Unsafe的方法compareAndSwapObject来线程安全地将FutureTask持有的Thread实例初始化为当前执行的线程（也就是被主线程开启的子线程本身）。这个方法采用了CAS（Compare and Swap），也就是要修改的参数必须符合预期的值才能给它赋新值。这里是为了确保只有一个子线程能执行FutureTask，以避免并发执行带来的问题。</p>
<p>当执行完之后，无论是正常还是捕获到异常，都需要将runner置为null。而再次读state，则是若runner被中断了，需要进行相应处理。具体处理在后面介绍。</p>
<p>下面我们看get方法。get方法的作用是获取执行的结果。在看代码之前，我们可以设想，虽然FutureTask的执行只能由一个线程来完成。但是应该是允许多个线程来并发获取结果的。那它必然有某种数据结构来保存读取结果的线程。说这么多，其实这种数据结构就是WaitNode：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/** Treiber stack of waiting threads */</span></div><div class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> WaitNode waiters;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 记录等待线程（即是读取执行结果的线程）的简单链表</div><div class="line"> * </div><div class="line"> */</div><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitNode</span> </span>&#123;</div><div class="line">    <span class="keyword">volatile</span> Thread thread;</div><div class="line">    <span class="keyword">volatile</span> WaitNode next;</div><div class="line">    WaitNode() &#123; thread = Thread.currentThread(); &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>get方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</div><div class="line">    <span class="keyword">int</span> s = state;</div><div class="line">    <span class="keyword">if</span> (s &lt;= COMPLETING)</div><div class="line">        s = awaitDone(<span class="keyword">false</span>, <span class="number">0L</span>);</div><div class="line">    <span class="keyword">return</span> report(s);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>首先判断state，若处于完成中，或者NEW。则调用awaitDone。否则直接调用report返回结果。</p>
<p>在我们的例子中看到，当在主线程调用FutureTask的get的时候，会一直等待到子线程将任务执行完成，再将结果返回给主线程。这个等待过程就是通过awaitDone方法来完成的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 等待完成，若已中断或超时则终止</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> timed true if use timed waits</div><div class="line"> * <span class="doctag">@param</span> nanos time to wait, if timed</div><div class="line"> * <span class="doctag">@return</span> state upon completion</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">awaitDone</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></div><div class="line">    <span class="keyword">throws</span> InterruptedException &#123;</div><div class="line">    <span class="keyword">final</span> <span class="keyword">long</span> deadline = timed ? System.nanoTime() + nanos : <span class="number">0L</span>;</div><div class="line">    WaitNode q = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">boolean</span> queued = <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">for</span> (;;) &#123;</div><div class="line">        <span class="comment">// 若线程已中断，则从等待链表中移除当前线程节点</span></div><div class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</div><div class="line">            removeWaiter(q);</div><div class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">int</span> s = state;</div><div class="line">        <span class="comment">// 若非NEW或完成中状态，则将节点的线程置为null，并返回当前状态</span></div><div class="line">        <span class="keyword">if</span> (s &gt; COMPLETING) &#123;</div><div class="line">            <span class="keyword">if</span> (q != <span class="keyword">null</span>)</div><div class="line">                q.thread = <span class="keyword">null</span>;</div><div class="line">            <span class="keyword">return</span> s;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 若为完成中状态，则当前线程让出CPU执行时间，待下次竞争到CPU时再判断是否完成</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s == COMPLETING) <span class="comment">// cannot time out yet</span></div><div class="line">            Thread.yield();</div><div class="line">        <span class="comment">// 若state为NEW，则新建等待队列节点</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (q == <span class="keyword">null</span>)</div><div class="line">            q = <span class="keyword">new</span> WaitNode();</div><div class="line">        <span class="comment">// 若当前线程所属的等待节点还没有插入链表，则插入到链表头</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!queued)</div><div class="line">            queued = UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset,</div><div class="line">                                                 q.next = waiters, q);</div><div class="line">        <span class="comment">// 如果考虑超时时间，则计算时间并进行处理</span></div><div class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (timed) &#123;</div><div class="line">            nanos = deadline - System.nanoTime();</div><div class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0L</span>) &#123;</div><div class="line">                removeWaiter(q);</div><div class="line">                <span class="keyword">return</span> state;</div><div class="line">            &#125;</div><div class="line">            LockSupport.parkNanos(<span class="keyword">this</span>, nanos);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">            LockSupport.park(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从上述代码看出，awaitDone的逻辑也不是很复杂，主要就是根据state的各种状态，进行新建等待节点，节点入等待列表等操作。</p>
<p>report方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 任务完成时返回结果或抛出异常</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> s completed state value</div><div class="line"> */</div><div class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line"><span class="function"><span class="keyword">private</span> V <span class="title">report</span><span class="params">(<span class="keyword">int</span> s)</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</div><div class="line">    Object x = outcome;</div><div class="line">    <span class="keyword">if</span> (s == NORMAL)</div><div class="line">        <span class="keyword">return</span> (V)x;</div><div class="line">    <span class="keyword">if</span> (s &gt;= CANCELLED)</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException();</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException((Throwable)x);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>outcome就是要返回的执行结果。那么它的值是在哪里赋的呢？就是我们前面提到过的set方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> *</div><div class="line"> * 若执行结果还没有赋值，或被取消时，设置执行结果</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> v the value</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(V v)</span> </span>&#123;</div><div class="line">    <span class="comment">// 先将state从NEW转化为完成中</span></div><div class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</div><div class="line">        outcome = v;</div><div class="line">        <span class="comment">// 将state从NEW转化为正常结束</span></div><div class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, NORMAL); <span class="comment">// final state</span></div><div class="line">        finishCompletion();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>当执行Callable的call方法发生异常时，会调用setException方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setException</span><span class="params">(Throwable t)</span> </span>&#123;</div><div class="line">    <span class="comment">// 先将state从NEW转化为完成中</span></div><div class="line">    <span class="keyword">if</span> (UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW, COMPLETING)) &#123;</div><div class="line">        outcome = t;</div><div class="line">        <span class="comment">// 将state从NEW转化为发生异常</span></div><div class="line">        UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, EXCEPTIONAL); <span class="comment">// final state</span></div><div class="line">        finishCompletion();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>finishCompletion主要完成一些扫尾工作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">finishCompletion</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="comment">// assert state &gt; COMPLETING;</span></div><div class="line">    <span class="keyword">for</span> (WaitNode q; (q = waiters) != <span class="keyword">null</span>;) &#123;</div><div class="line">        <span class="keyword">if</span> (UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, waitersOffset, q, <span class="keyword">null</span>)) &#123;</div><div class="line">            <span class="keyword">for</span> (;;) &#123;</div><div class="line">                Thread t = q.thread;</div><div class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</div><div class="line">                    q.thread = <span class="keyword">null</span>;</div><div class="line">                    LockSupport.unpark(t);</div><div class="line">                &#125;</div><div class="line">                WaitNode next = q.next;</div><div class="line">                <span class="keyword">if</span> (next == <span class="keyword">null</span>)</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                q.next = <span class="keyword">null</span>; <span class="comment">// unlink to help gc</span></div><div class="line">                q = next;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    done();</div><div class="line"></div><div class="line">    callable = <span class="keyword">null</span>;        <span class="comment">// to reduce footprint</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>此方法的逻辑也很简单，就是遍历等待列表，将每一个节点都从列表删除，同时将每个等待线程解除阻塞。</p>
<p>以上分析了任务执行完成的情况，还有一种情况是执行被取消。它通过cancel方法来实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</div><div class="line">    <span class="comment">// 此条件等价于: state != NEW || !UNSAFE.compareAndSwapInt(this, stateOffset, NEW,mayInterruptIfRunning ? INTERRUPTING : CANCELLED)</span></div><div class="line">    <span class="keyword">if</span> (!(state == NEW &amp;&amp;</div><div class="line">          UNSAFE.compareAndSwapInt(<span class="keyword">this</span>, stateOffset, NEW,</div><div class="line">              mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    <span class="keyword">try</span> &#123;    <span class="comment">// in case call to interrupt throws exception</span></div><div class="line">        <span class="keyword">if</span> (mayInterruptIfRunning) &#123;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                Thread t = runner;</div><div class="line">                <span class="keyword">if</span> (t != <span class="keyword">null</span>)</div><div class="line">                    t.interrupt();</div><div class="line">            &#125; <span class="keyword">finally</span> &#123; <span class="comment">// final state</span></div><div class="line">                UNSAFE.putOrderedInt(<span class="keyword">this</span>, stateOffset, INTERRUPTED);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">finally</span> &#123;</div><div class="line">        finishCompletion();</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>当state为NEW时，返回fasle。若为NEW，则根据传入的参数，若传入true，则将state转化为正在中断，否则转化为已取消。</p>
<p>若传入参数为true，取消时还需中断执行任务的线程。之后将state设置为已中断。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>以上就是FutureTask的简单使用和源码解析。除了直接使用新建线程来执行FutureTask，还可以使用线程池，本文没有对此进行介绍。</p>
<p>分析FutureTask的源码，发现还是比较简单的。主要就是通过一个内部持有的Thread来执行任务，同时用一个等待列表来存放等待获取结果的线程。当等待线程尝试用get获取结果时，会先判断是否为完成中以后的状态，若是则直接返回结果。否则就一直轮询，等待状态更新。最后执行完成之后，则遍历等待列表，将所有等待线程都解除阻塞。当然还有处理异常等情况，此处不再分析。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/08/05/Dubbo中对线程池的使用/" title="Dubbo中对线程池的使用" itemprop="url">Dubbo中对线程池的使用</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="wts" target="_blank" itemprop="author">wts</a>
		
  <p class="article-time">
    <time datetime="2018-08-04T16:00:00.000Z" itemprop="datePublished"> Published 2018-08-05</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="线程池的概念"><a href="#线程池的概念" class="headerlink" title="线程池的概念"></a>线程池的概念</h2><p>线程池（英语：thread pool）：一种线程使用模式。线程过多会带来调度开销，进而影响缓存局部性和整体性能。而线程池维护着多个线程，等待着监督管理者分配可并发执行的任务。这避免了在处理短时间任务时创建与销毁线程的代价。</p>
<h2 id="Dubbo中的线程池"><a href="#Dubbo中的线程池" class="headerlink" title="Dubbo中的线程池"></a>Dubbo中的线程池</h2><p>Dubbo是一款高性能的分布式服务框架，它实现了透明化的远程调用，只需要通过配置，就能像调用当前jvm内的方法一样调用另一个JVM中的方法，而无需关心底层通信细节。</p>
<p>我们在使用Dubbo时，如果只是发布一个服务供其他java进程调用，或是调用另一个JVM进程中的方法，一般不需要显式地关注多线程的使用。但是我们的一个程序，可以发布多个接口，可以并发处理多个接口的调用。或是并发地调用多个远程接口。这显然是底层框架帮我们处理了多线程的工作。</p>
<h3 id="Dubbo中对Netty线程的使用"><a href="#Dubbo中对Netty线程的使用" class="headerlink" title="Dubbo中对Netty线程的使用"></a>Dubbo中对Netty线程的使用</h3><p>Dubbo在传输层默认使用的是Netty作为通信框架。Dubbo作为服务提供者时使用Netty建立Tcp服务端，作为服务使用者时也使用Netty建立Tcp客户端。</p>
<p>Netty是基于java的NIO技术并结合线程池的通信框架。以下是Dubbo建立服务端的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyServer</span> <span class="keyword">extends</span> <span class="title">AbstractServer</span> <span class="keyword">implements</span> <span class="title">Server</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyServer.class);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Map&lt;String, Channel&gt; channels; <span class="comment">// &lt;ip:port, channel&gt;</span></div><div class="line"></div><div class="line">    <span class="keyword">private</span> ServerBootstrap bootstrap;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> io.netty.channel.Channel channel;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> EventLoopGroup bossGroup;</div><div class="line">    <span class="keyword">private</span> EventLoopGroup workerGroup;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyServer</span><span class="params">(URL url, ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</div><div class="line">        <span class="keyword">super</span>(url, ChannelHandlers.wrap(handler, ExecutorUtil.setThreadName(url, SERVER_THREAD_POOL_NAME)));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        bootstrap = <span class="keyword">new</span> ServerBootstrap();</div><div class="line"></div><div class="line">        bossGroup = <span class="keyword">new</span> NioEventLoopGroup(<span class="number">1</span>, <span class="keyword">new</span> DefaultThreadFactory(<span class="string">"NettyServerBoss"</span>, <span class="keyword">true</span>));</div><div class="line">        workerGroup = <span class="keyword">new</span> NioEventLoopGroup(getUrl().getPositiveParameter(Constants.IO_THREADS_KEY, Constants.DEFAULT_IO_THREADS),</div><div class="line">                <span class="keyword">new</span> DefaultThreadFactory(<span class="string">"NettyServerWorker"</span>, <span class="keyword">true</span>));</div><div class="line"></div><div class="line">        <span class="keyword">final</span> NettyServerHandler nettyServerHandler = <span class="keyword">new</span> NettyServerHandler(getUrl(), <span class="keyword">this</span>);</div><div class="line">        channels = nettyServerHandler.getChannels();</div><div class="line"></div><div class="line">        bootstrap.group(bossGroup, workerGroup)</div><div class="line">                .channel(NioServerSocketChannel.class)</div><div class="line">                .childOption(ChannelOption.TCP_NODELAY, Boolean.TRUE)</div><div class="line">                .childOption(ChannelOption.SO_REUSEADDR, Boolean.TRUE)</div><div class="line">                .childOption(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)</div><div class="line">                .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;NioSocketChannel&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(NioSocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                        NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyServer.<span class="keyword">this</span>);</div><div class="line">                        ch.pipeline()<span class="comment">//.addLast("logging",new LoggingHandler(LogLevel.INFO))//for debug</span></div><div class="line">                                .addLast(<span class="string">"decoder"</span>, adapter.getDecoder())</div><div class="line">                                .addLast(<span class="string">"encoder"</span>, adapter.getEncoder())</div><div class="line">                                .addLast(<span class="string">"handler"</span>, nettyServerHandler);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div><div class="line">        <span class="comment">// bind</span></div><div class="line">        ChannelFuture channelFuture = bootstrap.bind(getBindAddress());</div><div class="line">        channelFuture.syncUninterruptibly();</div><div class="line">        channel = channelFuture.channel();</div><div class="line"></div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 省略若干代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>ServerBootstrap是Netty的一个类，用于建立服务端的功能。它使用了两组线程池，一个是父线程池，用于处理接受客户端的连接请求，因为Dubbo协议只需要监听一个端口，所以这个线程池只需要一个线程即可。另一个是子线程池，每当和一个客户端建立连接之后，就会从此线程池中选择一个线程进行IO操作。</p>
<p>Dubbo中建立tcp客户端也使用了Netty，下面是实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NettyClient</span> <span class="keyword">extends</span> <span class="title">AbstractClient</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(NettyClient.class);</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> NioEventLoopGroup nioEventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup(Constants.DEFAULT_IO_THREADS, <span class="keyword">new</span> DefaultThreadFactory(<span class="string">"NettyClientWorker"</span>, <span class="keyword">true</span>));</div><div class="line"></div><div class="line">    <span class="keyword">private</span> Bootstrap bootstrap;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> Channel channel; <span class="comment">// volatile, please copy reference to use</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NettyClient</span><span class="params">(<span class="keyword">final</span> URL url, <span class="keyword">final</span> ChannelHandler handler)</span> <span class="keyword">throws</span> RemotingException </span>&#123;</div><div class="line">        <span class="keyword">super</span>(url, wrapChannelHandler(url, handler));</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doOpen</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line">        <span class="keyword">final</span> NettyClientHandler nettyClientHandler = <span class="keyword">new</span> NettyClientHandler(getUrl(), <span class="keyword">this</span>);</div><div class="line">        bootstrap = <span class="keyword">new</span> Bootstrap();</div><div class="line">        bootstrap.group(nioEventLoopGroup)</div><div class="line">                .option(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>)</div><div class="line">                .option(ChannelOption.TCP_NODELAY, <span class="keyword">true</span>)</div><div class="line">                .option(ChannelOption.ALLOCATOR, PooledByteBufAllocator.DEFAULT)</div><div class="line">                <span class="comment">//.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, getTimeout())</span></div><div class="line">                .channel(NioSocketChannel.class);</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (getTimeout() &lt; <span class="number">3000</span>) &#123;</div><div class="line">            bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, <span class="number">3000</span>);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            bootstrap.option(ChannelOption.CONNECT_TIMEOUT_MILLIS, getTimeout());</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        bootstrap.handler(<span class="keyword">new</span> ChannelInitializer() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">                NettyCodecAdapter adapter = <span class="keyword">new</span> NettyCodecAdapter(getCodec(), getUrl(), NettyClient.<span class="keyword">this</span>);</div><div class="line">                ch.pipeline()<span class="comment">//.addLast("logging",new LoggingHandler(LogLevel.INFO))//for debug</span></div><div class="line">                        .addLast(<span class="string">"decoder"</span>, adapter.getDecoder())</div><div class="line">                        .addLast(<span class="string">"encoder"</span>, adapter.getEncoder())</div><div class="line">                        .addLast(<span class="string">"handler"</span>, nettyClientHandler);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>Netty客户端只需要一个线程池就可以。</p>
<p>以上是Dubbo中对于IO线程池的使用。此外，Dubbo发送请求和处理请求也使用了线程池。</p>
<h3 id="Dubbo业务线程池的使用"><a href="#Dubbo业务线程池的使用" class="headerlink" title="Dubbo业务线程池的使用"></a>Dubbo业务线程池的使用</h3><h3 id="Dubbo中线程池的种类"><a href="#Dubbo中线程池的种类" class="headerlink" title="Dubbo中线程池的种类"></a>Dubbo中线程池的种类</h3><p>Dubbo中使用的线程池都是基于Java提供的ThreadPoolExecutor类。它基于不同的策略提供了创建不同的ThreadPoolExecutor的线程池工厂。包括以下几种：</p>
<p><b>CachedThreadPool</b> : 缓存线程池，它创建的是一个可以扩展的线程池，可以配置核心线程数量，最大线程数量，任务队列长度，空闲线程保活时间。这个线程池默认的队列长度是java中int类型的最大值。</p>
<p><b>EagerThreadPool</b> : 这个线程池工厂提供的是一个Dubbo提供自定义的线程池类EagerThreadPoolExecutor，这个线程池扩展了java中的ThreadPoolExecutor。当所有的核心线程都处于忙碌状态时，若有新任务到来，将会直接创建新线程，而不是放到任务队列中。</p>
<p><b>FixedThreadPool</b> : 固定线程池，它创建的是一个拥有固定线程数量的线程池。用户可配置相关参数。这个线程池是默认选项。</p>
<p><b>LimitedThreadPool</b> : 可伸缩线程池。它提供的线程池的特色是，线程池设定的线程保活时间是Long类型的最大值。因此它的线程不会减少，只会增加。</p>
<p>Dubbo中对业务线程池的配置是在下面这个类中实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WrappedChannelHandler</span> <span class="keyword">implements</span> <span class="title">ChannelHandlerDelegate</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger logger = LoggerFactory.getLogger(WrappedChannelHandler.class);</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> ExecutorService SHARED_EXECUTOR = Executors.newCachedThreadPool(<span class="keyword">new</span> NamedThreadFactory(<span class="string">"DubboSharedHandler"</span>, <span class="keyword">true</span>));</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ExecutorService executor;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ChannelHandler handler;</div><div class="line"></div><div class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> URL url;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WrappedChannelHandler</span><span class="params">(ChannelHandler handler, URL url)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.handler = handler;</div><div class="line">        <span class="keyword">this</span>.url = url;</div><div class="line">        executor = (ExecutorService) ExtensionLoader.getExtensionLoader(ThreadPool.class).getAdaptiveExtension().getExecutor(url);</div><div class="line"></div><div class="line">        String componentKey = Constants.EXECUTOR_SERVICE_COMPONENT_KEY;</div><div class="line">        <span class="keyword">if</span> (Constants.CONSUMER_SIDE.equalsIgnoreCase(url.getParameter(Constants.SIDE_KEY))) &#123;</div><div class="line">            componentKey = Constants.CONSUMER_SIDE;</div><div class="line">        &#125;</div><div class="line">        DataStore dataStore = ExtensionLoader.getExtensionLoader(DataStore.class).getDefaultExtension();</div><div class="line">        dataStore.put(componentKey, Integer.toString(url.getPort()), executor);</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>这个类持有了一个线程池接口ExecutorService executor。当实例化这个类时，会根据URL的参数获取对应的线程池，也就是上面说的四种线程池中的一种。</p>
<p>以上是对Dubbo中线程池使用的简要介绍，还有很多地方没有深入。后续有机会再分析。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2018/05/27/Spring容器ClasspathXmlApplicationContext启动过程解析/" title="Spring容器ClassPathXmlApplicationContext启动过程解析" itemprop="url">Spring容器ClassPathXmlApplicationContext启动过程解析</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="wts" target="_blank" itemprop="author">wts</a>
		
  <p class="article-time">
    <time datetime="2018-05-26T16:00:00.000Z" itemprop="datePublished"> Published 2018-05-27</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Spring是企业级Java开发中应用最广泛的编程框架。在EJB日渐式微的情况下，Spring已成为企业级Java开发的事实标准。经过十多年的发展，不仅传统的配置方式仍然在广泛使用，同时也诞生了Spring Boot，Spring Cloud等基于Spring的新的框架，在方兴未艾的微服务领域继续引领着潮流。</p>
<p>在使用Spring的过程中，相信我们都很容易感受到Spring给我们带来的便利，这不禁就会引发我们对Spring本身的设计和实现的兴趣。通过阅读文档和代码，我们会发现Spring堪称Java项目设计与实现的典范，它的设计非常地优雅，是我们学习Java开发，乃至面向对象设计与开放的很好的教材。</p>
<p>在Spring的体系中，依赖注入（Dependency Injection，简称DI）是一个基础设施级的功能。一般说使用Spring，默认都会认为必然会使用DI的功能。所以学习Spring的源代码，一般也会从DI入手。</p>
<p>Spring的依赖注入主要是靠应用上下文（ApplicationContext）来实现的。顾名思义，应用上下文就是持有了应用启动必须的各种信息的对象。在多种ApplicationContext中，ClassPathXmlApplicationContext是比较简单的一个，从它的名字可以看出，它是基于Java的Classpath的，同时是基于Xml配置的。</p>
<p>下面先分析一下ClassPathXmlApplicationContext的类关系<br><img src="/images/ClassPathXmlApplicationContext-class-relationship.png" alt=""><br>我们首先关注一下ClassPathXmlApplicationContext到ApplicationContext的继承和实现关系。从顶向下各个接口和实现类的功能如下：</p>
<p>ApplicationContext：这个接口是提供了应用程序配置的核心接口，当程序运行时它是只读的，不能修改状态，但是可以重新加载（reload），只要具体的实现类支持。</p>
<p>ConfigurableApplicationContext：这是一个支持SPI加载的接口，绝大多数应用上下文都实现了它。它内部定义了一些默认的基础常量，同时提供了ApplicationContext之外的配置应用程序的方法。</p>
<p>AbstractApplicationContext：应用上下文的抽象实现类。这个类可以说是应用上下文的骨架实现类。它不关心用到的配置的存储方式；实现了通用的应用上下文功能；采用了模板设计模式，具体的实现类需要实现它定义的抽象方法。</p>
<p>Base class for {@link org.springframework.context.ApplicationContext}</p>
<ul>
<li>implementations which are supposed to support multiple calls to {@link #refresh()},</li>
<li>creating a new internal bean factory instance every time.</li>
<li>Typically (but not necessarily), such a context will be driven by</li>
<li>a set of config locations to load bean definitions from.</li>
</ul>
<p>AbstractRefreshableApplicationContext：这个类支持多次刷新上下文。每次刷新时，它会创建一个新的内部Bean Factory（Bean工厂，通过它实际持有创建的bean）。</p>
<p>AbstractRefreshableConfigApplicationContext：提供了对某种形式的存储配置文件路径的支持，包括类路径（ClassPath），文件系统等。</p>
<p>AbstractXmlApplicationContext：这个类提供了从XML文件中提取bean定义的功能（通过XmlBeanDefinitionReader实现）</p>
<p>ClassPathXmlApplicationContext：这个类从Class path获取Context配置文件。</p>
<p>下面就以dubbo源代码中提供的demo来跟踪一下ClassPathXmlApplicationContext这个应用上下文的启动过程。它主要通过下面这一行代码来启动：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[]&#123;<span class="string">"META-INF/spring/dubbo-demo-provider.xml"</span>&#125;);</div></pre></td></tr></table></figure>
<p>这行代码很简单，就是调用了构造方法，参数是一个字符串数组，只有一个元素，指出了配置文件的路径。</p>
<p>进入这个构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * Create a new ClassPathXmlApplicationContext, loading the definitions</div><div class="line">	 * from the given XML files and automatically refreshing the context.</div><div class="line">	 * <span class="doctag">@param</span> configLocations array of resource locations</div><div class="line">	 * <span class="doctag">@throws</span> BeansException if context creation failed</div><div class="line">	 */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String... configLocations)</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">		<span class="keyword">this</span>(configLocations, <span class="keyword">true</span>, <span class="keyword">null</span>);</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>它又调用了自己的另一个构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * Create a new ClassPathXmlApplicationContext with the given parent,</div><div class="line">	 * loading the definitions from the given XML files.</div><div class="line">	 * <span class="doctag">@param</span> configLocations array of resource locations</div><div class="line">	 * <span class="doctag">@param</span> refresh whether to automatically refresh the context,</div><div class="line">	 * loading all bean definitions and creating all singletons.</div><div class="line">	 * Alternatively, call refresh manually after further configuring the context.</div><div class="line">	 * <span class="doctag">@param</span> parent the parent context</div><div class="line">	 * <span class="doctag">@throws</span> BeansException if context creation failed</div><div class="line">	 * <span class="doctag">@see</span> #refresh()</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String[] configLocations, <span class="keyword">boolean</span> refresh, ApplicationContext parent)</span></span></div><div class="line">			<span class="keyword">throws</span> BeansException &#123;</div><div class="line"></div><div class="line">		<span class="keyword">super</span>(parent);</div><div class="line">		setConfigLocations(configLocations);</div><div class="line">		<span class="keyword">if</span> (refresh) &#123;</div><div class="line">			refresh();</div><div class="line">		&#125;</div><div class="line">	&#125;</div></pre></td></tr></table></figure></p>
<p>这个构造函数先调用了超类的构造函数，之后判断传入的是否刷新的布尔值，如果为true，则调用refresh方法。</p>
<p>超类的构造方法基本什么也没做，除了每个超类定义的在构造函数之前就需要初始化的field的初始化之外，只是在AbstractApplicationContext的构造函数中设置了一下parent context（Spring支持有层级的应用上下文，但本例中不涉及）。</p>
<p>由此可见，所有的启动和刷新上下文的功能都是refresh这个方法完成的。这个方法是在ConfigurableApplicationContext中定义，在AbstractApplicationContext中定义的，子类没有覆盖它，这也说明Spring不同的上下文启动和刷新的流程是通用的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div></pre></td><td class="code"><pre><div class="line">   <span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</div><div class="line">	<span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</div><div class="line">		<span class="comment">// Prepare this context for refreshing.</span></div><div class="line">		prepareRefresh();</div><div class="line"></div><div class="line">		<span class="comment">// Tell the subclass to refresh the internal bean factory.</span></div><div class="line">		ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</div><div class="line"></div><div class="line">		<span class="comment">// Prepare the bean factory for use in this context.</span></div><div class="line">		prepareBeanFactory(beanFactory);</div><div class="line"></div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			<span class="comment">// Allows post-processing of the bean factory in context subclasses.</span></div><div class="line">			postProcessBeanFactory(beanFactory);</div><div class="line"></div><div class="line">			<span class="comment">// Invoke factory processors registered as beans in the context.</span></div><div class="line">			invokeBeanFactoryPostProcessors(beanFactory);</div><div class="line"></div><div class="line">			<span class="comment">// Register bean processors that intercept bean creation.</span></div><div class="line">			registerBeanPostProcessors(beanFactory);</div><div class="line"></div><div class="line">			<span class="comment">// Initialize message source for this context.</span></div><div class="line">			initMessageSource();</div><div class="line"></div><div class="line">			<span class="comment">// Initialize event multicaster for this context.</span></div><div class="line">			initApplicationEventMulticaster();</div><div class="line"></div><div class="line">			<span class="comment">// Initialize other special beans in specific context subclasses.</span></div><div class="line">			onRefresh();</div><div class="line"></div><div class="line">			<span class="comment">// Check for listener beans and register them.</span></div><div class="line">			registerListeners();</div><div class="line"></div><div class="line">			<span class="comment">// Instantiate all remaining (non-lazy-init) singletons.</span></div><div class="line">			finishBeanFactoryInitialization(beanFactory);</div><div class="line"></div><div class="line">			<span class="comment">// Last step: publish corresponding event.</span></div><div class="line">			finishRefresh();</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">catch</span> (BeansException ex) &#123;</div><div class="line">			<span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</div><div class="line">				logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</div><div class="line">						<span class="string">"cancelling refresh attempt: "</span> + ex);</div><div class="line">			&#125;</div><div class="line"></div><div class="line">			<span class="comment">// Destroy already created singletons to avoid dangling resources.</span></div><div class="line">			destroyBeans();</div><div class="line"></div><div class="line">			<span class="comment">// Reset 'active' flag.</span></div><div class="line">			cancelRefresh(ex);</div><div class="line"></div><div class="line">			<span class="comment">// Propagate exception to caller.</span></div><div class="line">			<span class="keyword">throw</span> ex;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="keyword">finally</span> &#123;</div><div class="line">			<span class="comment">// Reset common introspection caches in Spring's core, since we</span></div><div class="line">			<span class="comment">// might not ever need metadata for singleton beans anymore...</span></div><div class="line">			resetCommonCaches();</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">   &#125;</div></pre></td></tr></table></figure>
<p>prepareFresh方法主要做了一些准备工作，如设置启动时间，设置关闭状态为false，活动状态为true，初始化属性源等。</p>
<p>obtainFreshBeanFactory方法内部通过AbstractRefreshableApplicationContext中的refreshBeanFactory方法刷新bean工厂，它先判断内部的bean factory是否已存在，若存在则销毁它们保存的bean，并关闭之。之后这个方法的核心工作是调用了createBeanFactory方法创建内部的bean factory。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * Create an internal bean factory for this context.</div><div class="line">	 * Called for each &#123;<span class="doctag">@link</span> #refresh()&#125; attempt.</div><div class="line">	 * &lt;p&gt;The default implementation creates a</div><div class="line">	 * &#123;<span class="doctag">@link</span> org.springframework.beans.factory.support.DefaultListableBeanFactory&#125;</div><div class="line">	 * with the &#123;<span class="doctag">@linkplain</span> #getInternalParentBeanFactory() internal bean factory&#125; of this</div><div class="line">	 * context's parent as parent bean factory. Can be overridden in subclasses,</div><div class="line">	 * for example to customize DefaultListableBeanFactory's settings.</div><div class="line">	 * <span class="doctag">@return</span> the bean factory for this context</div><div class="line">	 * <span class="doctag">@see</span> org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowBeanDefinitionOverriding</div><div class="line">	 * <span class="doctag">@see</span> org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowEagerClassLoading</div><div class="line">	 * <span class="doctag">@see</span> org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowCircularReferences</div><div class="line">	 * <span class="doctag">@see</span> org.springframework.beans.factory.support.DefaultListableBeanFactory#setAllowRawInjectionDespiteWrapping</div><div class="line">	 */</div><div class="line">	<span class="function"><span class="keyword">protected</span> DefaultListableBeanFactory <span class="title">createBeanFactory</span><span class="params">()</span> </span>&#123;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">new</span> DefaultListableBeanFactory(getInternalParentBeanFactory());</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>可见是新建了一个DefaultListableBeanFactory。这个类的类关系如下图：<br><img src="/images/DefaultListableBeanFactory-class-relationship.png" alt=""></p>
<p>关注一下BeanFactory这个接口，它是访问Spring bean容器的根接口，提供了访问bean容器的基本功能。</p>
<p>Extension of the {@link BeanFactory} interface to be implemented by bean factories</p>
<ul>
<li>that can enumerate all their bean instances, rather than attempting bean lookup</li>
<li>by name one by one as requested by clients. BeanFactory implementations that</li>
<li>preload all their bean definitions (such as XML-based factories) may implement</li>
<li>this interface.</li>
</ul>
<p>ListableBeanFactory提供了枚举bean实例的功能，它会预加载bean的定义</p>
<p>BeanDefinitionRegistry：持有bean定义，例如root bean definition和child bean definition实例通常被bean factory实现。</p>
<p>DefaultListableBeanFactory：ListableBeanFactory和BeanDefinitionRegistry的默认实现。常用于在访问bean之前，保存所有bean的definition。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">	 * This implementation performs an actual refresh of this context's underlying</div><div class="line">	 * bean factory, shutting down the previous bean factory (if any) and</div><div class="line">	 * initializing a fresh bean factory for the next phase of the context's lifecycle.</div><div class="line">	 */</div><div class="line">	<span class="meta">@Override</span></div><div class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">refreshBeanFactory</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">		<span class="keyword">if</span> (hasBeanFactory()) &#123;</div><div class="line">			destroyBeans();</div><div class="line">			closeBeanFactory();</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">try</span> &#123;</div><div class="line">			DefaultListableBeanFactory beanFactory = createBeanFactory();</div><div class="line">			beanFactory.setSerializationId(getId());</div><div class="line">			customizeBeanFactory(beanFactory);</div><div class="line">			loadBeanDefinitions(beanFactory);</div><div class="line">			<span class="keyword">synchronized</span> (<span class="keyword">this</span>.beanFactoryMonitor) &#123;</div><div class="line">				<span class="keyword">this</span>.beanFactory = beanFactory;</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">catch</span> (IOException ex) &#123;</div><div class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> ApplicationContextException(<span class="string">"I/O error parsing bean definition source for "</span> + getDisplayName(), ex);</div><div class="line">		&#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>通过loadBeanDefinition加载定义到beanFactory中。这个方法是通过XmlBeanDefinitionReader去加载配置文件中的bean定义。具体过程比较繁琐，这里就不展开了，后续有时间再专门介绍。加载完之后，会将beanDefinition保存在DefaultListableBeanFactory的一个field中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/** Map of bean definition objects, keyed by bean name */</span></div><div class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, BeanDefinition&gt; beanDefinitionMap = <span class="keyword">new</span> ConcurrentHashMap&lt;String, BeanDefinition&gt;(<span class="number">256</span>);</div></pre></td></tr></table></figure>
<p>至此，Spring容器启动过程中的第一大步骤就算基本完成了，就是将bean定义从配置文件中读取出来，并解析为BeanDefinition保存在应用上下文的内置bean factory的内部的一个map钟，key为配置文件中定义的bean的name。</p>
<p>之后回到refresh方法，下面是prepareBeanFactory方法，这个方法就是对内部的bean factory做各种设置，以方便后面使用。具体就不介绍了。感兴趣可以自行研究代码。</p>
<p>postProcessBeanFactory是一个空方法，可以自定义一些对bean factory的定制化处理。由此以及后续的过程可以看出，Spring非常注重扩展性，留出了很多供使用者灵活扩展的地方，充分体现了“对修改关闭，对扩展开放”的面向对象设计原则。</p>
<p>invokeBeanFactoryPostProcessors：实例化并调用所有的BeanFactoryPostProcessor，BeanFactoryPostProcessor就是在bean factory的标准初始化流程结束之后，对它进行一些特殊配置的类。这个接口和后面的一些接口都可以看出Spring设计的原则，那就是先定义好某个功能的标准处理流程，但也提供了进行定制化处理的接口，并通过先注册后调用的方式很有秩序的进行处理。</p>
<p>registerBeanPostProcessors：实例化并调用所有已经注册的BeanPostProcessor。BeanPostProcessor和BeanFactoryPostProcessor类似，只不过一个是针对bean factory，一个是针对具体的bean。它定义了两个方法postProcessBeforeInitialization和postProcessAfterInitialization。前者会在某个bean的初始化方法（InitializingBean接口的afterPropertiesSet方法，或自定义的init-method）调用之前被调用。后者则是在初始化方法调用之后调用。</p>
<p>initMessageSource方法初始化message source。</p>
<p>initApplicationEventMulticaster方法初始化应用事件多播器。应用事件多播器是管理一系列ApplicationListener的，并且发布事件给它们。</p>
<p>onRefresh空方法，留给子类扩展。</p>
<p>registerListeners是获取所有实现了ApplicationListener的类，并注册它们，同时将一些早起的Application event发布出去。</p>
<p>finishBeanFactoryInitialization终于到最重要的一步了，就是完成Context中的bean factory的初始化，并初始化所有的还未初始化的单例bean。这个方法首先又对bean factory做了一系列设置，之后调用DefaultListableBeanFactory的preInstantiateSingletons方法对bean进行了初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">preInstantiateSingletons</span><span class="params">()</span> <span class="keyword">throws</span> BeansException </span>&#123;</div><div class="line">		<span class="keyword">if</span> (<span class="keyword">this</span>.logger.isDebugEnabled()) &#123;</div><div class="line">			<span class="keyword">this</span>.logger.debug(<span class="string">"Pre-instantiating singletons in "</span> + <span class="keyword">this</span>);</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		<span class="comment">// Iterate over a copy to allow for init methods which in turn register new bean definitions.</span></div><div class="line">		<span class="comment">// While this may not be part of the regular factory bootstrap, it does otherwise work fine.</span></div><div class="line">		List&lt;String&gt; beanNames = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="keyword">this</span>.beanDefinitionNames);</div><div class="line"></div><div class="line">		<span class="comment">// Trigger initialization of all non-lazy singleton beans...</span></div><div class="line">		<span class="keyword">for</span> (String beanName : beanNames) &#123;</div><div class="line">			RootBeanDefinition bd = getMergedLocalBeanDefinition(beanName);</div><div class="line">			<span class="keyword">if</span> (!bd.isAbstract() &amp;&amp; bd.isSingleton() &amp;&amp; !bd.isLazyInit()) &#123;</div><div class="line">				<span class="keyword">if</span> (isFactoryBean(beanName)) &#123;</div><div class="line">					<span class="keyword">final</span> FactoryBean&lt;?&gt; factory = (FactoryBean&lt;?&gt;) getBean(FACTORY_BEAN_PREFIX + beanName);</div><div class="line">					<span class="keyword">boolean</span> isEagerInit;</div><div class="line">					<span class="keyword">if</span> (System.getSecurityManager() != <span class="keyword">null</span> &amp;&amp; factory <span class="keyword">instanceof</span> SmartFactoryBean) &#123;</div><div class="line">						isEagerInit = AccessController.doPrivileged(<span class="keyword">new</span> PrivilegedAction&lt;Boolean&gt;() &#123;</div><div class="line">							<span class="meta">@Override</span></div><div class="line">							<span class="function"><span class="keyword">public</span> Boolean <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">								<span class="keyword">return</span> ((SmartFactoryBean&lt;?&gt;) factory).isEagerInit();</div><div class="line">							&#125;</div><div class="line">						&#125;, getAccessControlContext());</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">else</span> &#123;</div><div class="line">						isEagerInit = (factory <span class="keyword">instanceof</span> SmartFactoryBean &amp;&amp;</div><div class="line">								((SmartFactoryBean&lt;?&gt;) factory).isEagerInit());</div><div class="line">					&#125;</div><div class="line">					<span class="keyword">if</span> (isEagerInit) &#123;</div><div class="line">						getBean(beanName);</div><div class="line">					&#125;</div><div class="line">				&#125;</div><div class="line">				<span class="keyword">else</span> &#123;</div><div class="line">					getBean(beanName);</div><div class="line">				&#125;</div><div class="line">			&#125;</div><div class="line">        &#125;</div></pre></td></tr></table></figure>
<p>基本过程是就是遍历所有的bean definition，判断不是抽象类，同时是单例，并且没有设置lazy-init的就进行处理。处理时又分为是否是工厂类和不是工厂类进行处理。普通bean直接调用getBean进行处理，工厂bean则要进行一些处理，判断是否是立即加载的。</p>
<p>getBean内部直接调用了doGetBean方法，doGetBean中最终调用了createBean方法来创建一个bean，createBean中调用了doCreateBean来实际创建一个bean。</p>
<p>Spring是通过一个BeanWrapper接口来包裹我们实际要创建的类型的bean，这也是一种比较常见的设计模式，就是通过包装类来提供一些额外的功能。BeanWrapper的实现类主要是实现了Bean的属性编辑器的功能。doCreateBean做的事情比较杂，后续有时间再专门分析。</p>
<p>finishRefresh方法主要是完成刷新，主要做了一些善后工作。</p>
<p>通过对ClassPathXmlApplicationContext的启动过程的分析，我们可以总结一些规律。一是Spring的应用上下文的类体系设计得比较复杂，也因此显得很强大和完善。二是标准流程和扩展流程相分离，给使用者的扩展留出了足够的空间。三是采用了很多内部缓存类，比如缓存了bean的定义，bean实例，bean的name等都用了不同的集合做了专门的缓存。特别是针对单例bean的三级缓存，可以解决循环依赖的问题。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/11/26/Jdbc中对数据库隔离级别的验证/" title="Jdbc对数据库事务隔离级别的验证" itemprop="url">Jdbc对数据库事务隔离级别的验证</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="wts" target="_blank" itemprop="author">wts</a>
		
  <p class="article-time">
    <time datetime="2017-11-25T16:00:00.000Z" itemprop="datePublished"> Published 2017-11-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        <h2 id="数据库的事务隔离级别"><a href="#数据库的事务隔离级别" class="headerlink" title="数据库的事务隔离级别"></a>数据库的事务隔离级别</h2><p>一.读未提交<br>读未提交是指当一个事务在执行过程中，若另一个事务修改了同一条数据，但没有提交，仍然会被当前数据读取到被更改但未提交的新值。此时可能发生脏读。<br>二.读提交<br>读提交是指当一个事务在执行过程中，若另一个事务修改了数据并且提交了修改。此时提交后的数据会被当前数据读取到。此时会发生不可重复读。<br>三.可重复读<br>可重复读是指当一个事务在执行过程中，不管读同一条数据多少次，读到的数据和第一次读取的值保持一致。此时可能发生幻读，即另一个事务插入了新数据，但没有被当前事务读取到。<br>四.可序列化<br>可序列化是指所有事务顺序执行，此时可避免幻读。</p>
<p>通过JDBC对数据库的访问，可验证数据库的事务隔离级别。</p>
<h2 id="建表语句"><a href="#建表语句" class="headerlink" title="建表语句"></a>建表语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Orders</div><div class="line">(</div><div class="line">  O_id       <span class="built_in">INT</span> AUTO_INCREMENT,</div><div class="line">  OrderPrice <span class="keyword">DOUBLE</span>(<span class="number">11</span>, <span class="number">2</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</div><div class="line">  Customer   <span class="built_in">VARCHAR</span>(<span class="number">50</span>)   <span class="literal">NULL</span>,</div><div class="line">  <span class="keyword">CONSTRAINT</span> <span class="string">`PRIMARY`</span></div><div class="line">  PRIMARY <span class="keyword">KEY</span> (O_id)</div><div class="line">);</div></pre></td></tr></table></figure>
<p>插入一条数据<br>1    1000    Bush    4</p>
<h2 id="程序代码"><a href="#程序代码" class="headerlink" title="程序代码"></a>程序代码</h2><p>编写两个Java程序，开启两个事务对MySQL数据库进行访问</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> java.sql.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">"com.mysql.jdbc.Driver"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">"jdbc:mysql://localhost/database2"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">"root"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String PASS = <span class="string">"1234"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Connection connection = <span class="keyword">null</span>;</div><div class="line">        Statement statement = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Class.forName(JDBC_DRIVER);</div><div class="line">            System.out.println(<span class="string">"connecting..."</span>);</div><div class="line">            connection = DriverManager.getConnection(DB_URL, USER, PASS);</div><div class="line">            connection.setAutoCommit(<span class="keyword">false</span>);</div><div class="line">            statement = connection.createStatement();</div><div class="line">            String sql = <span class="string">"select * from Orders where O_id = ?"</span>;</div><div class="line">            PreparedStatement ps = connection.prepareStatement(sql);</div><div class="line">            ps.setInt(<span class="number">1</span>,<span class="number">1</span>);</div><div class="line">            ResultSet rs = ps.executeQuery();</div><div class="line">            <span class="keyword">while</span> (rs.next()) &#123;</div><div class="line">                System.out.println(rs.getInt(<span class="number">4</span>));</div><div class="line">            &#125;</div><div class="line">            rs = ps.executeQuery();</div><div class="line">            <span class="keyword">while</span> (rs.next()) &#123;</div><div class="line">                System.out.println(rs.getInt(<span class="number">4</span>));</div><div class="line">            &#125;</div><div class="line">            rs.close();</div><div class="line">            connection.commit();</div><div class="line">            connection.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> java.sql.*;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTestTwo</span> </span>&#123;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">"com.mysql.jdbc.Driver"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">"jdbc:mysql://localhost/database2?useSSL=false"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">"root"</span>;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String PASS = <span class="string">"1234"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        Connection connection = <span class="keyword">null</span>;</div><div class="line">        Statement statement = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Class.forName(JDBC_DRIVER);</div><div class="line">            System.out.println(<span class="string">"connecting..."</span>);</div><div class="line">            connection = DriverManager.getConnection(DB_URL, USER, PASS);</div><div class="line">            connection.setAutoCommit(<span class="keyword">false</span>);</div><div class="line">            statement = connection.createStatement();</div><div class="line">            String sql = <span class="string">"UPDATE Orders SET col = 2 WHERE O_id = ?"</span>;</div><div class="line">            PreparedStatement ps = connection.prepareStatement(sql);</div><div class="line">            ps.setInt(<span class="number">1</span>,<span class="number">1</span>);</div><div class="line"><span class="comment">//            ResultSet rs = ps.executeQuery();</span></div><div class="line"><span class="comment">//            while (rs.next()) &#123;</span></div><div class="line"><span class="comment">//                System.out.println(rs.getInt(4));</span></div><div class="line"><span class="comment">//            &#125;</span></div><div class="line">            <span class="keyword">int</span> count = ps.executeUpdate();</div><div class="line"><span class="comment">//            while (rs.next()) &#123;</span></div><div class="line"><span class="comment">//                System.out.println(rs.getInt(4));</span></div><div class="line"><span class="comment">//            &#125;</span></div><div class="line"><span class="comment">//            rs.close();</span></div><div class="line">            connection.commit();</div><div class="line">            connection.close();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在JdbcTest中对数据库表的同一条数据进行了两次查询，只需要在两次查询之间加一个断点，当程序暂停时，运行JdbcTest2，就可以观察到数据库中的数据变化是否符合隔离级别的定义。</p>
<h2 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h2><p>将MySQL数据库全局隔离级别设置为读未提交的命令：<br>SET GLOBAL TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;</p>
<p>1.运行JdbcTest，第一次查询出数据列col为4，暂停程序；<br>2.运行JdbcTest2，执行为update语句之后，暂停，不提交；<br>3.继续运行JdbcTest，第二次查询出数据列已经变为2；</p>
<h2 id="读提交"><a href="#读提交" class="headerlink" title="读提交"></a>读提交</h2><p>将MySQL数据库全局隔离级别设置为读提交的命令：<br>SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;</p>
<p>1.运行JdbcTest，第一次查询出数据列col为4，暂停程序；<br>2.运行JdbcTest,第一次查询出数据列为2，暂停程序，不提交；<br>3.继续运行JdbcTest，第二次查询出数据列仍然为4；</p>
<p>若第二步不暂停直接提交，则第三步查询出的数据将为2；</p>
<h2 id="可重复读"><a href="#可重复读" class="headerlink" title="可重复读"></a>可重复读</h2><p>将MySQL数据库全局隔离级别设置为可重复读的命令：<br>SET GLOBAL TRANSACTION ISOLATION LEVEL REPEATABLE READ;</p>
<p>1.运行JdbcTest，第一次查询出数据列col为4，暂停；<br>2.运行JdbcTest2，直接提交，将数据修改为2；<br>3.运行JdbcTest，读出数据依然为2。</p>
<h2 id="可序列化"><a href="#可序列化" class="headerlink" title="可序列化"></a>可序列化</h2><p>将MySQL数据库全局隔离级别设置为可重复读的命令：<br>SET GLOBAL TRANSACTION ISOLATION LEVEL SERIALIZABLE;</p>
<p>1.运行JdbcTest，第一次查询出数据列col为4，暂停；<br>2.运行JdbcTest2,将一直被阻塞，直到JdbcTest恢复执行完后，它才能完成事务，或者超时抛出异常。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>数据库的隔离级别是很重要的特性，在不同场合使用不同的隔离级别会有不同的用处。大多数情况下使用的是可重复读。通过编程来验证隔离级别，可以更好地加深对知识的理解。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/11/26/Dubbo服务治理环境的搭建/" title="Dubbo服务治理环境的搭建" itemprop="url">Dubbo服务治理环境的搭建</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="wts" target="_blank" itemprop="author">wts</a>
		
  <p class="article-time">
    <time datetime="2017-11-25T16:00:00.000Z" itemprop="datePublished"> Published 2017-11-26</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Dubbo是阿里推出的服务治理框架，被国内很多公司广泛使用。关于它的介绍可参考<a href="http://http://dubbo.io" target="_blank" rel="external">http://http://dubbo.io</a>.<br>本文主要介绍如何通过dubbo搭建服务治理环境，通过在本地搭建环境，有助于学习dubbo的源代码实现，毕竟可以边看源代码边运行调试。</p>
<h2 id="Zookeeper的安装"><a href="#Zookeeper的安装" class="headerlink" title="Zookeeper的安装"></a>Zookeeper的安装</h2><p>dubbo是一个服务治理服务，那它必然有一个服务注册中心。dubbo的服务注册中心可以采用multicast、zookeeper、redis或simple注册中心。比较常见的是zookeeper注册中心。</p>
<p>首先下载zookeeper，下载之后首先要做的是进入它的子目录conf中，将zoo_sample.cfg文件名修改为zoo.cfg，因为zookeeper启动时会使用它。之后从终端进入它所在目录，运行<br>bin/zkServer.sh start。</p>
<p>之后可输入jps命令，若显示运行的进程中有<br>QuorumPeerMain,则证明zookeeper已启动。</p>
<p>运行bin/zkServer.sh stop停止zookeeper。</p>
<h2 id="安装tomcat"><a href="#安装tomcat" class="headerlink" title="安装tomcat"></a>安装tomcat</h2><p>下载tomcat 7。为什么是7，因为经试验tomcat 8和9两个版本在部署dubbo时都有问题。下载之后进入子目录conf中，将server.xml中配置的connector的port由8080改成其他数字，注意不要和已经被其他程序使用的端口冲突。</p>
<p>进入tomcat的子目录bin中，运行startup.sh（若是Windows则是startup.bat）。若启动过程不报错，且最后显示tomcat started，则证明启动成功。</p>
<p>运行shutdown.sh停止tomcat。</p>
<h2 id="安装dubbo-admin"><a href="#安装dubbo-admin" class="headerlink" title="安装dubbo-admin"></a>安装dubbo-admin</h2><p>从<a href="http://dubbo.io/" target="_blank" rel="external">http://dubbo.io/</a><br>或github上下载dubbo项目的源代码。dubbo-admin是dubbo的控制台，可以通过它查看和管理在dubbo上注册的服务。下载dubbo源代码之后，从终端进入dubbo文件夹。输入命令</p>
<p>mvn install -Dmaven.test.skip=true</p>
<p>将会编译整个dubbo项目，也包括dubbo-admin。</p>
<p><img src="/images/dubbo_install.png" alt="">   </p>
<p>之后进入dubbo-admin的子目录target中，会发现多了一个dubbo-admin-2.5.7.war。将这个包拷到tomcat的webapps文件夹中。</p>
<p>按前面介绍的方法先启动zookeeper，再启动tomcat。之后在浏览器中输入localhost:8888/dubbo-admin-2.5.7。会看到如下界面。</p>
<p><img src="/images/dubbo-admin-interface.png" alt="">  </p>
<p>可以看到服务提供者和调用者都是0，说明还没有服务注册到zookeeper中。</p>
<h2 id="注册服务生产者和消费者"><a href="#注册服务生产者和消费者" class="headerlink" title="注册服务生产者和消费者"></a>注册服务生产者和消费者</h2><p>为简化起见，本文采用IDE来构建服务。</p>
<p>首先是用intellij idea导入整个dubbo项目。</p>
<p><img src="/images/dubbo-project.png" alt="">  </p>
<p>可以看到其中就有dubbo-demo项目，它主要有三个子项目构成。</p>
<p><img src="/images/dubbo-demo.png" alt="">  </p>
<p>其中远程调用的接口DemoService：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DemoService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function">String <span class="title">sayHello</span><span class="params">(String name)</span></span>;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这个类之所以是一个单独的项目，是因为它需要被服务端和客户端同时引用。服务端会实现它：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.provider;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.DemoService;</div><div class="line"><span class="keyword">import</span> com.alibaba.dubbo.rpc.RpcContext;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</div><div class="line"><span class="keyword">import</span> java.util.Date;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoServiceImpl</span> <span class="keyword">implements</span> <span class="title">DemoService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"["</span> + <span class="keyword">new</span> SimpleDateFormat(<span class="string">"HH:mm:ss"</span>).format(<span class="keyword">new</span> Date()) + <span class="string">"] Hello "</span> + name + <span class="string">", request from consumer: "</span> + RpcContext.getContext().getRemoteAddress());</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello "</span> + name + <span class="string">", response form provider: "</span> + RpcContext.getContext().getLocalAddress();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>客户端则可以通过配置，就像调用本地方法一样调用它。这也是RPC的主要目的之一。</p>
<p>服务端主类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.provider;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by ken.lj on 2017/7/31.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Provider</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[]&#123;<span class="string">"META-INF/spring/dubbo-demo-provider.xml"</span>&#125;);</div><div class="line">        context.start();</div><div class="line"></div><div class="line">        System.in.read(); <span class="comment">// 按任意键退出</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>客户端主类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> com.alibaba.dubbo.demo.consumer;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.alibaba.dubbo.demo.DemoService;</div><div class="line"></div><div class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by ken.lj on 2017/7/31.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ClassPathXmlApplicationContext context = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> String[]&#123;<span class="string">"META-INF/spring/dubbo-demo-consumer.xml"</span>&#125;);</div><div class="line">        context.start();</div><div class="line"></div><div class="line">        DemoService demoService = (DemoService) context.getBean(<span class="string">"demoService"</span>); <span class="comment">// 获取远程服务代理</span></div><div class="line">        String hello = demoService.sayHello(<span class="string">"世界"</span>); <span class="comment">// 执行远程方法</span></div><div class="line"></div><div class="line">        System.out.println(hello); <span class="comment">// 显示调用结果</span></div><div class="line"></div><div class="line">        System.in.read();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>客户端最后一行代码是我加的，为了让客户端和服务端一样执行完调用之后不会退出程序。</p>
<p>此外服务端和客户端还需要在spring配置文件中做一些配置。服务端配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></div><div class="line">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></div><div class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></div><div class="line">	http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 提供方应用信息，用于计算依赖关系 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-provider"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 使用multicast广播注册中心暴露服务地址 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 用dubbo协议在20880端口暴露服务 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:protocol</span> <span class="attr">name</span>=<span class="string">"dubbo"</span> <span class="attr">port</span>=<span class="string">"20880"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 和本地bean一样实现服务 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.dubbo.demo.provider.DemoServiceImpl"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 声明需要暴露的服务接口 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:service</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span> <span class="attr">ref</span>=<span class="string">"demoService"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>客户端配置：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line">       <span class="attr">xmlns:dubbo</span>=<span class="string">"http://code.alibabatech.com/schema/dubbo"</span></div><div class="line">       <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></div><div class="line">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span></div><div class="line">	http://code.alibabatech.com/schema/dubbo http://code.alibabatech.com/schema/dubbo/dubbo.xsd"&gt;</div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 消费方应用名，用于计算依赖关系，不是匹配条件，不要与提供方一样 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:application</span> <span class="attr">name</span>=<span class="string">"demo-consumer"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 使用multicast广播注册中心暴露发现服务地址 --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:registry</span> <span class="attr">address</span>=<span class="string">"zookeeper://127.0.0.1:2181"</span>/&gt;</span></div><div class="line"></div><div class="line">    <span class="comment">&lt;!-- 生成远程服务代理，可以和本地bean一样使用demoService --&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">dubbo:reference</span> <span class="attr">id</span>=<span class="string">"demoService"</span> <span class="attr">check</span>=<span class="string">"false"</span> <span class="attr">interface</span>=<span class="string">"com.alibaba.dubbo.demo.DemoService"</span>/&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></div></pre></td></tr></table></figure>
<p>可见配置文件中就配置了我们之前启动的zookeeper，所以程序启动之后就可以注册到zookeeper中了。</p>
<p>现在先运行服务端的Provider的main方法，再运行Consumer的main方法。可以看到consumer端打印出了如下内容。</p>
<p><img src="/images/dubbo-consumer-client-output.png" alt="">  </p>
<p>可见，客户端通过调用服务端的方法，返回了字符串并打印出来了。</p>
<p>再看dubbo-admin的页面：</p>
<p><img src="/images/dubbo-admin-output.png" alt=""> </p>
<p>可见dubbo-admin中已经能看到注册进来的服务提供者和调用者了。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>本文采用了比较简单的方式，即从IDE中运行dubbo项目，虽然在实际运用中需要单独部署服务，但这种方式便于学习源代码。比如可以单步跟踪，看整个dubbo执行远程调用的流程。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/30/Spring Boot快速搭建Web应用/" title="Spring Boot快速搭建Web应用" itemprop="url">Spring Boot快速搭建Web应用</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="wts" target="_blank" itemprop="author">wts</a>
		
  <p class="article-time">
    <time datetime="2017-05-29T16:00:00.000Z" itemprop="datePublished"> Published 2017-05-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Spring Boot是Spring家族一个新兴的成员，它能用于快速构建基于Spring的独立的生产级的应用程序。我们可以将它与Spring平台的其他项目以及第三方库自由组合。大多数基于Spring Boot的应用只需要非常少量的Spring配置。</p>
<h2 id="Spring-Boot的安装"><a href="#Spring-Boot的安装" class="headerlink" title="Spring Boot的安装"></a>Spring Boot的安装</h2><p>与其他Java库类似，Spring Boot也是打包成jar的形式，所以可以在应用中直接将spring-boot-*.jar引入到classpath中。可以像开发其他Java程序那样开发Spring Boot程序。</p>
<p>但是在现代的企业级Java开发中，一般会使用专门的构建工具来管理应用的整个生命周期，例如Maven和Gradle。</p>
<p>当使用Maven时，只需要在pom.xml中配置好相关依赖，就可以在构建过程中自动引用Spring Boot的相关jar。</p>
<h2 id="用Spring-Boot开发web应用"><a href="#用Spring-Boot开发web应用" class="headerlink" title="用Spring Boot开发web应用"></a>用Spring Boot开发web应用</h2><p>学习任何新技术，都是从开发Hello world级别的程序开始的。用Spring Boot结合Maven开发Hello world级别的Web应用可谓易如反掌。</p>
<h3 id="创建pom-xml文件"><a href="#创建pom-xml文件" class="headerlink" title="创建pom.xml文件"></a>创建pom.xml文件</h3><p>在磁盘合适的位置新建一个项目文件夹，比如SpringBootTest。从终端进入该文件夹，创建一个pom.xml文件，输入如下内容并保存。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</div><div class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></div><div class="line">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</div><div class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.example<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>myproject<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.0.1-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.5.3.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span> </div><div class="line"></div><div class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></div><div class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></div><div class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></div></pre></td></tr></table></figure>
<p>可以看到引入了spring-boot-starter-parent和spring-boot-starter-web两个starter。Spring Boot是用于简化Spring应用开发的，spring-boot-starter-parent的作用是让maven自动引入默认的一些基础依赖，spring-boot-starter-web则会让maven自动引入web应用需要的依赖。试想一下如果我们不使用Spring Boot，而是手工用Spring，Spring MVC来开发web应用，那需要配置应用上下文，Servlet上下文等，在maven中也要手工将相关依赖都引入进来。配置量会成倍增加。而用Spring Boot则非常轻松，会将配置最少化。</p>
<p>有了这个pom文件，就可以用maven来构建程序了，可以用mvn package来测试，会看到maven会下载很多依赖，打印出如下信息，就证明能正常构建程序。<br>Building myproject 0.0.1-SNAPSHOT<br>Build Success<br>同时，项目文件夹下出现了target文件夹，该文件夹就是构建出来的可执行文件。<br>可以执行maven dependency:tree命令来打印出项目依赖的树形表示。</p>
<h3 id="编写代码"><a href="#编写代码" class="headerlink" title="编写代码"></a>编写代码</h3><p>使用Maven管理应用必须使文件夹结构符合maven的约定。所以在SpringBootTest文件夹下新建如下目录结构：<br>src/main/java<br>进入该文件夹，创建文件Example.java，输入如下内容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> org.springframework.boot.*;</div><div class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.*;</div><div class="line"><span class="keyword">import</span> org.springframework.stereotype.*;</div><div class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.*;</div><div class="line"></div><div class="line"><span class="meta">@RestController</span></div><div class="line"><span class="meta">@EnableAutoConfiguration</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/"</span>)</div><div class="line">    <span class="function">String <span class="title">home</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello World!"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        SpringApplication.run(Example.class, args);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>@RestController注解标志这个类是一个web Controller，并且是REST的访问方式。</p>
<p>@RequestMapping提供了“路由”信息。它告诉Spring任何HTTP请求，如果路径符合“/”就会被路由到home方法。因为是用Rest方式访问的Controller，所以直接返回Hello World！字符串，而不是重定向到一个view。</p>
<p>@EnableAutoConfiguration告诉Spring Boot开发者希望如何配置Spring，依据pom.xml中添加的依赖。因为spring-boot-starter-web依赖会自动添加Tomcat和Spring MVC，自动配置组件就知道开发者在开发一个web应用程序，并据此设置Spring。</p>
<h3 id="main方法"><a href="#main方法" class="headerlink" title="main方法"></a>main方法</h3><p>这里的main方法就是Java程序中标准的main方法。但该方法代理执行了Spirng Boot的SpringApplication类的run方法，从而启动了Spring去自动配置Tomcat。此处需要将Example.class作为参数传给run方法，告诉SpringApplication它是主要的Spring组件。</p>
<h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><p>万事俱备只欠东风。用终端进入Spring进入到SpringBootTest（必须是pom.xml所在文件夹），输入如下命令。<br>mvn spring-boot:run</p>
<p>会看到输出如下内容：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"> .   ____          _            __ _ _</div><div class="line"> /\\ / ___&apos;_ __ _ _(_)_ __  __ _ \ \ \ \</div><div class="line">( ( )\___ | &apos;_ | &apos;_| | &apos;_ \/ _` | \ \ \ \</div><div class="line"> \\/  ___)| |_)| | | | | || (_| |  ) ) ) )</div><div class="line">  &apos;  |____| .__|_| |_|_| |_\__, | / / / /</div><div class="line"> =========|_|==============|___/=/_/_/_/</div><div class="line"> :: Spring Boot ::        (v1.5.3.RELEASE)</div><div class="line">…… …</div><div class="line">…… …</div><div class="line">Started Example in 3.239 seconds (JVM running for 21.929)</div></pre></td></tr></table></figure>
<p>打开浏览器，输入localhost:8080，会看到如下输出<br>Hello World!</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>从上文可以看出，Spring Boot可以在Spring框架的基础上快速搭建应用，例如Web应用。它可以有效减少配置量，而且可以使用内嵌的Web容器，可以高效地开发和测试程序。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/30/kotlin-new-feature-1/" title="Kotlin的新特性（一）：基本类型" itemprop="url">Kotlin的新特性（一）：基本类型</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="wts" target="_blank" itemprop="author">wts</a>
		
  <p class="article-time">
    <time datetime="2017-05-29T16:00:00.000Z" itemprop="datePublished"> Published 2017-05-30</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>Kotlin是一门新兴的语言，它可以运行于JVM、JavaScript以及native环境（native正在开发中）。它是由著名软件开发商Jetbrains开发，具备了很多新的特性，能够在开发中提升效率。目前已经成为Android官方支持的开发语言。<br>Kotlin语言中的一切类型都是对象，这与Java不同。虽然Java标榜自己是一门纯粹的面向对象的语言，但由于设计的局限，还是保留了一些非面向对象的元素，最明显的就是在Java中，int、float、double、long、char等基本类型不是类，而是原生类型（primitive types）。为了补救这个缺陷，Java开发了对应的包装类型Integer、Float、Double、Long、Chararater等。<br>Kotlin吸收了C#等语言的设计思想，将上述基本类型内置为类，它们具有自己的成员函数和成员属性。这些基本类型包括：数字类型（numbers），字符类型（characters），布尔类型（booleans）和数组类型（arrays）。</p>
<h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><p>Kotlin中的数字类型与Java类似，包括Double、Float、Long、Int、Short、Byte等类型。如上文所述，它们都是类。</p>
<h3 id="字面常量"><a href="#字面常量" class="headerlink" title="字面常量"></a>字面常量</h3><p>Kotlin中的字面常量（literal constants）与Java类似，Int类型支持十进制，直接用普通十进制表示即可；Long类型则需跟上L后缀，如123L表示一个Long型常数，值是123。十六进制加0x前缀，如0x0F表示十六进制数，值是15。二进制加0b前缀，如0b00001011表示二进制数，值是11。Kotlin中不支持八进制数。<br>Kotlin支持通用的浮点数表示法，默认是Double类型，如123.5，123.5e10，如果是Float类型，需要加f或F后缀，如123.5f。</p>
<h3 id="下划线分隔位数"><a href="#下划线分隔位数" class="headerlink" title="下划线分隔位数"></a>下划线分隔位数</h3><p>Kotlin支持在数字常量中使用下划线分隔数位。这能使位数较多的数字具有更强的可读性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> oneMillion = <span class="number">1</span>_000_000 </div><div class="line"><span class="keyword">val</span> creditCardNumber = <span class="number">1234</span>_5678_9012_3456L</div></pre></td></tr></table></figure>
<p>当Kotlin运行于JVM中时，number类型实际上是存储为JVM原生类型，当被赋值给可以为空（nullable）的引用时，Kotlin的number类型是对原生类型的包装。<br>Kotlin中，当使用一个number型常量（val）去初始化一个不可为空的number型常量时，被初始化的常量都指向内存中同一个地址。而当初始化为一个可以为空的常量时，则会在内存中不同地址创建两个常量，并将值赋给它们。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">10000</span> </div><div class="line">print(a === a) <span class="comment">// Prints 'true' </span></div><div class="line"><span class="keyword">val</span> boxedA: <span class="built_in">Int</span> = a </div><div class="line"><span class="keyword">val</span> anotherBoxedA: <span class="built_in">Int</span> = a </div><div class="line">print(boxedA === anotherBoxedA) <span class="comment">// !!!Prints true!!!</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">10000</span> </div><div class="line">print(a === a) <span class="comment">// Prints 'true' </span></div><div class="line"><span class="keyword">val</span> boxedA: <span class="built_in">Int</span>? = a </div><div class="line"><span class="keyword">val</span> anotherBoxedA: <span class="built_in">Int</span>? = a </div><div class="line">print(boxedA === anotherBoxedA) <span class="comment">// !!!Prints 'false'!!!</span></div></pre></td></tr></table></figure>
<p>但即使是赋值给可以为空的常量，依然能保证它们的相等性（equality）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">10000</span> </div><div class="line">print(a == a) <span class="comment">// Prints 'true' </span></div><div class="line"><span class="keyword">val</span> boxedA: <span class="built_in">Int</span>? = a <span class="keyword">val</span> anotherBoxedA: <span class="built_in">Int</span>? = a </div><div class="line">print(boxedA == anotherBoxedA) <span class="comment">// Prints 'true'</span></div></pre></td></tr></table></figure>
<h3 id="宽向扩展"><a href="#宽向扩展" class="headerlink" title="宽向扩展"></a>宽向扩展</h3><p>Kotlin中不存在隐式的宽向类型扩展，即Byte不能直接转换为Int，Int不能直接转换为Double，等等。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> b: <span class="built_in">Byte</span> = <span class="number">1</span> <span class="comment">// OK, literals are checked statically </span></div><div class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = b <span class="comment">// ERROR</span></div></pre></td></tr></table></figure>
<p>每种number类型都能通过内置方法任意转换为另一种number类型。</p>
<h2 id="Characters"><a href="#Characters" class="headerlink" title="Characters"></a>Characters</h2><p>字符类型用Char类表示。与Java不同，它不能被直接当做数字类型使用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(c: <span class="type">Char</span>)</span></span> &#123; </div><div class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) &#123; <span class="comment">// ERROR: incompatible types // ... </span></div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与Java一样，字符字面量使用单引号表示。转义字符使用反斜杠。特殊字符使用反斜杠加u加十六进制数表示。字符可以通过toInt()方法显式转换为Int。<br>与number一样，字符被赋值给一个nullable引用时，唯一性（identity，内存中地址相同）是不被保证的。</p>
<h2 id="Booleans"><a href="#Booleans" class="headerlink" title="Booleans"></a>Booleans</h2><p>用Boolean代表布尔类型，它有两个值：true和false。</p>
<p>布尔类型被赋值给nullable引用时，会被包装。但能保证唯一性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a: <span class="built_in">Boolean</span> = <span class="literal">true</span></div><div class="line">println(a === a) <span class="comment">// Prints 'true'</span></div><div class="line"><span class="keyword">val</span> boxedA: <span class="built_in">Boolean</span>? = a</div><div class="line"><span class="keyword">val</span> anotherBoxedA: <span class="built_in">Boolean</span>? = a</div><div class="line">println(boxedA === anotherBoxedA) <span class="comment">// Prints ‘true’</span></div></pre></td></tr></table></figure>
<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>在Java中，数组其实也是一种对象，只是我们不能显示地获得它的类型表示。在Kotlin中，用Array类来代表数组。它具有get和set方法（通过[]操作符重载了这两个函数），size属性以及其他有用的函数，如迭代器方法iterator()。</p>
<p>创建数组可以使用arrayOf()方法，并传递数组元素给它作为参数。例如arrayOf(1, 2, 3)就创建了一个数组[1, 2, 3]。arrayOfNulls()函数用于创建一个给定长度的数组，并用null元素填充它。</p>
<p>Kotlin也有特定的类代表原生类型的数组，如ByteArray、ShortArray、IntArray等。这些类与Array没有继承关系，但有对应的方法和属性集合。如IntArray有对应的工厂函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> x: IntArray = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) </div><div class="line">x[<span class="number">0</span>] = x[<span class="number">1</span>] + x[<span class="number">2</span>]</div></pre></td></tr></table></figure>
<h2 id="Strings"><a href="#Strings" class="headerlink" title="Strings"></a>Strings</h2><p>字符串用String类表示。与Java一样，String是不可变类。String的元素是字符，与Java中必须使用charAtIndex()这样一个方法去访问元素不同，Kotlin中可以使用下标运算符[]去访问字符元素。String还能使用for循环很方便地访问。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (c <span class="keyword">in</span> str) &#123; </div><div class="line">    println(c) </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h3><p>Kotlin有两种字符串字面量：一种是可转义的字符串，它可能含有转义字符，它不能表示在多行，除非使用“+”将不同的字符串连接成一个字符串；另一种是原始（raw）字符串，能在多行表示并能包含任意文本。</p>
<p>转义字符串：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> s = <span class="string">"Hello, world!\n"</span></div></pre></td></tr></table></figure>
<p>原始字符串：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> text = <span class="string">""" </span></div><div class="line">    for (c in "foo") print(c) </div><div class="line">"""</div></pre></td></tr></table></figure>
<p>可以使用trimMargin()移除字符串开头和中间的空格，但空格的末尾必须跟上一个明确的分隔符，默认是“|”。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> text = <span class="string">""" </span></div><div class="line">    |Tell me and I forget. </div><div class="line">    |Teach me and I remember. </div><div class="line">    |Involve me and I learn. </div><div class="line">    |(Benjamin Franklin) """.trimMargin()</div><div class="line"><span class="string">"""</span></div></pre></td></tr></table></figure>
<p>也可以显示指定分隔符，如trimMargin(“&gt;”)</p>
<h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><p>在Java中，如果我们在字符串中要加入变量，必须使用加号连接，或者使用格式化字符串。而在Kotlin中，可以使用字符串模板，这将使字符串变得更加简洁，看上去也更加舒服。字符串模板以美元符号开头，直接跟上一个变量名。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> i = <span class="number">10</span> </div><div class="line"><span class="keyword">val</span> s = <span class="string">"i = <span class="subst">$i</span>"</span> <span class="comment">// evaluates to "i = 10"</span></div><div class="line"><span class="string">"""</span></div></pre></td></tr></table></figure>
<p>或者是一个用大括号包裹的任意的表达式。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> s = <span class="string">"abc"</span> </div><div class="line"><span class="keyword">val</span> str = <span class="string">"<span class="subst">$s</span>.length is <span class="subst">$&#123;s.length&#125;</span>"</span> <span class="comment">// evaluates to "abc.length is 3"</span></div><div class="line"><span class="string">"""</span></div></pre></td></tr></table></figure>
<p>模板在原始字符串和转义字符串中都支持。如果你在原始字符串中需要表示美元符号的字面值，可以像下面这样使用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> price = <span class="string">""" </span></div><div class="line"><span class="subst">$&#123;<span class="string">'$'</span>&#125;</span>9.99 </div><div class="line">"""</div></pre></td></tr></table></figure>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/05/29/RabbitMQ-HelloWorld/" title="RabbitMQ的Java客户端（一）" itemprop="url">RabbitMQ的Java客户端（一）</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="wts" target="_blank" itemprop="author">wts</a>
		
  <p class="article-time">
    <time datetime="2017-05-29T15:50:13.000Z" itemprop="datePublished"> Published 2017-05-29</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>RabbitMQ是一个常用的消息队列中间件，它能接收并转发消息。在消息通信模型中，系统可分为三部分：生产者，消息服务器和消费者。简单地说，生产者程序产生消息，发布到消息服务器；消费者程序连接到消息服务器，订阅到队列中。每当消息到达特定等队列时，RabbitMQ会将其发送给其中一个订阅/监听的消费者。<br>在RabbitMQ中，生产者并不是直接将消息交给某个消息队列的，而是将消息发送给交换器，发送时会指定投递的规则，这些规则称为路由键。交换器中最简单等一种就是direct交换器。它是一个以空白字符串为名称等默认交换器。当声明一个队列时，默认绑定到direct交换器。direct交换器的规则非常简单：如果路由键（队列名）匹配的话，消息就被投递到对应等队列。如下图所示</p>
<h2 id="Java客户端"><a href="#Java客户端" class="headerlink" title="Java客户端"></a>Java客户端</h2><p>Java是当今流行的服务器应用程序开发语言。RabbitMQ也提供了Java的客户端SDK。用Java实现direct交换器中的生产者示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> com.wts.helloworld;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</div><div class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</div><div class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by weitaosheng on 2017/5/1.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</div><div class="line">        factory.setHost(<span class="string">"localhost"</span>);</div><div class="line">        Connection connection = factory.newConnection();</div><div class="line">        Channel channel = connection.createChannel();</div><div class="line"></div><div class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</div><div class="line">        String message = <span class="string">"Hello World!"</span>;</div><div class="line">        channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</div><div class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</div><div class="line"></div><div class="line">        channel.close();</div><div class="line">        connection.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建一个消息生产者等步骤：</p>
<ol>
<li>新建连接工厂；</li>
<li>绑定RabbitMQ服务器地址（默认为localhost，端口5672）；</li>
<li>获取连接；</li>
<li>建立频道（channel）；</li>
<li>声明队列；</li>
<li>发布消息。</li>
<li>关闭频道；</li>
<li>关闭连接。</li>
</ol>
<p>客户端示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by weitaosheng on 2017/5/1.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</div><div class="line">        factory.setHost(<span class="string">"localhost"</span>);</div><div class="line">        Connection connection = factory.newConnection();</div><div class="line">        Channel channel = connection.createChannel();</div><div class="line"></div><div class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</div><div class="line">        System.out.println(<span class="string">" [*] Waiting for message. To exit press CTRL+C"</span>);</div><div class="line"></div><div class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</div><div class="line">                System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建客户端并订阅队列的步骤：</p>
<ol>
<li>新建连接工厂；</li>
<li>绑定RabbitMQ服务器地址（默认为localhost，端口5672）；</li>
<li>获取连接；</li>
<li>建立频道（channel）；</li>
<li>声明队列；</li>
<li>声明一个消息消费者，本示例中是用一个匿名内部类来扩展了DefaltConsumer类，并重写了handleDelivery方法，该方法定义了接收到消息时进行等处理。</li>
</ol>
<p>以下是客户端SDK关键的类和方法：<br>ConnectionFactory：连接工厂关键类，是客户端访问RabbitMQ服务器必须要先构造的类。从Connection的源代码可以看出，ConnectionFactory没有显示定义构造函数，因此使用的是编译器自动生成的默认构造函数。<br>获取连接的函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">newConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</div><div class="line">    <span class="keyword">return</span> newConnection(<span class="keyword">this</span>.sharedExecutor, Collections.singletonList(<span class="keyword">new</span> Address(getHost(), getPort())));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查看源码，sharedExecutor是一个ExecutorService的实例。此处为null，也就是没有使用线程池。连接时还需要地址和端口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Channel <span class="title">createChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div></pre></td></tr></table></figure></p>
<p>createChannel：生成一个Channel类的实例。Connection是一条真实的TCP连接，Channel是Connection内等一条虚拟连接，它在RabbitMQ中会自动生成唯一的ID。通过一条TCP连接内多个虚拟连接的方式，可以提高性能，节约系统资源，因为TCP连接的创建和销毁是非常昂贵的。<br>Queue.DeclareOk queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete,<br>                             Map<string, object=""> arguments) throws IOException;<br>queueDeclare：声明队列。它的几个参数的含义是：队列名，是否持久化，是否是限制性等队列（仅限于此次连接），是否自动删除消息，其他参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicPublish</span><span class="params">(String exchange, String routingKey, BasicProperties props, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException</span>;</div></pre></td></tr></table></figure></string,></p>
<p>basicPublish：发布消息，几个参数是：交换器名，路由键，是否设置了mandatory参数，消息参数，消息体（用byte数组装载）</p>
<p>Consumer是代表消费者等接口，DefaultConsumer是Consumer接口的一个默认实现。一般定义消费者只需扩展这个类即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></div><div class="line">                           Envelope envelope,</div><div class="line">                           AMQP.BasicProperties properties,</div><div class="line">                           <span class="keyword">byte</span>[] body)</div></pre></td></tr></table></figure></p>
<p>handleDelivery：消费者接收到消息时的回调方法。它的几个参数是：消费者标签，『信封』信息，消息头内容，消息体</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>






   
    
    <article class="post-expand post" itemprop="articleBody"> 
        <header class="article-info clearfix">
  <h1 itemprop="name">
    
      <a href="/2017/03/01/Java-synchronized/" title="Java中synchronized关键字的研究" itemprop="url">Java中synchronized关键字的研究</a>
  </h1>
  <p class="article-author">By
       
		<a href="/about" title="wts" target="_blank" itemprop="author">wts</a>
		
  <p class="article-time">
    <time datetime="2017-03-01T12:23:47.000Z" itemprop="datePublished"> Published 2017-03-01</time>
    
  </p>
</header>
    <div class="article-content">
        
        <p>在Java中，每一个线程都有一个内部锁。当我们使用<strong>synchronized</strong>关键字时，就是利用这个内部锁来实现线程对某个对象的锁定控制。<br>那么，如果某个对象中有两个方法，方法一和方法二都使用了synchronized关键字。如果线程一执行该对象的方法一，线程二执行该对象的方法二。如果线程1一直不释放该对象的内部锁的话，那么线程二应该无法执行该对象的方法二。下面就用代码来验证一下。<br>首先，定义一个Task类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> corejava.chapter14;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskC</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            System.out.println(<span class="string">"我是方法1"</span>);</div><div class="line">            Thread.sleep(<span class="number">10000</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            System.out.println(<span class="string">"我是方法2"</span>);</div><div class="line">            Thread.sleep(<span class="number">10000</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>method1每隔10秒就会输出一句“我是方法1”。method2每隔10秒就会输出一句“我是方法2”。两个方法都使用了synchronized关键字。  </p>
<p>再定义两个执行类ExecutorC1和Executor2。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> corejava.chapter14;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorC1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> TaskC taskC;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutorC1</span><span class="params">(TaskC taskC)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.taskC = taskC;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            taskC.method1();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> corejava.chapter14;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorC2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> TaskC taskC;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutorC2</span><span class="params">(TaskC taskC)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.taskC = taskC;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            taskC.method2();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行对象1和执行对象2都使用同一个taskC去实例化，这样他们之间就会存在竞争。当thread1执行taskC的method1时，会一直持有taskC的内部锁，因此thread2将一直处于阻塞状态。  </p>
<p>下面是运行输出结果<br><img src="/images/synchronized.png" alt="">  </p>
<p>可见，确实如我们所料，虽然两个线程要执行的是不同的方法，但因为线程1一直“霸占”着内部锁，所以线程2始终在阻塞状态，得不到执行。  </p>
<p>所以，如果我们在对某个类要使用synchronized关键字进行锁定控制时，一定要牢记它使用的是该类的内部锁。它是唯一的。当多个方法都用它来进行控制时，一定要考虑这一点。</p>

        
        
        <p class="article-more-link">
          
       </p>
    </div>
    <footer class="article-footer clearfix">
<div class="article-catetags">


</div>




<div class="comments-count">
	
</div>

</footer>


    </article>







  <nav id="page-nav" class="clearfix">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next<span></span></a>
  </nav>

</div>
      <div class="openaside"><a class="navbutton" href="#" title="Show Sidebar"></a></div>

<div id="asidepart">
<div class="closeaside"><a class="closebutton" href="#" title="Hide Sidebar"></a></div>
<aside class="clearfix">

  


  

  

  <div class="linkslist">
  <p class="asidetitle">Links</p>
    <ul>
        
          <li>
            
            	<a href="https://github.com/tswstarplanet" target="_blank" title="我的github">我的github</a>
            
          </li>
        
    </ul>
</div>

</aside>
</div>
    </div>
    <footer><div id="footer" >
	
	
	<div class="social-font" class="clearfix">
		
		
		
		
		
		
		
		
		
		
	</div>
			
		

		<p class="copyright">
		Powered by <a href="http://hexo.io" target="_blank" title="hexo">hexo</a> and Theme by <a href="https://github.com/wuchong/jacman" target="_blank" title="Jacman">Jacman</a> © 2018 
		
		<a href="/about" target="_blank" title="wts">wts</a>
		
		
		</p>
</div>
</footer>
    <script src="/js/jquery-2.0.3.min.js"></script>
<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/jquery.qrcode-0.12.0.min.js"></script>

<script type="text/javascript">
$(document).ready(function(){ 
  $('.navbar').click(function(){
    $('header nav').toggleClass('shownav');
  });
  var myWidth = 0;
  function getSize(){
    if( typeof( window.innerWidth ) == 'number' ) {
      myWidth = window.innerWidth;
    } else if( document.documentElement && document.documentElement.clientWidth) {
      myWidth = document.documentElement.clientWidth;
    };
  };
  var m = $('#main'),
      a = $('#asidepart'),
      c = $('.closeaside'),
      o = $('.openaside');
  c.click(function(){
    a.addClass('fadeOut').css('display', 'none');
    o.css('display', 'block').addClass('fadeIn');
    m.addClass('moveMain');
  });
  o.click(function(){
    o.css('display', 'none').removeClass('beforeFadeIn');
    a.css('display', 'block').removeClass('fadeOut').addClass('fadeIn');      
    m.removeClass('moveMain');
  });
  $(window).scroll(function(){
    o.css("top",Math.max(80,260-$(this).scrollTop()));
  });
  
  $(window).resize(function(){
    getSize(); 
    if (myWidth >= 1024) {
      $('header nav').removeClass('shownav');
    }else{
      m.removeClass('moveMain');
      a.css('display', 'block').removeClass('fadeOut');
      o.css('display', 'none');
        
    }
  });
});
</script>










<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
$(document).ready(function(){ 
  $('.article-content').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox')) return;
      var alt = this.alt;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'article' + i);
    });
  });
  if($.fancybox){
    $('.fancybox').fancybox();
  }
}); 
</script>



<!-- Analytics Begin -->



<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?e6d1f421bbc9962127a50488f9ed37d1";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>



<!-- Analytics End -->

<!-- Totop Begin -->

	<div id="totop">
	<a title="Back to Top"><img src="/img/scrollup.png"/></a>
	</div>
	<script src="/js/totop.js"></script>

<!-- Totop End -->

<!-- MathJax Begin -->
<!-- mathjax config similar to math.stackexchange -->


<!-- MathJax End -->

<!-- Tiny_search Begin -->

<!-- Tiny_search End -->

  </body>
 </html>
