<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>My Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="nothing">
<meta property="og:type" content="website">
<meta property="og:title" content="My Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="My Blog">
<meta property="og:description" content="nothing">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="My Blog">
<meta name="twitter:description" content="nothing">
  
    <link rel="alternate" href="/atom.xml" title="My Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">My Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">Programmer Article</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="Flux RSS"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Rechercher"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-RabbitMQ-HelloWorld" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/05/29/RabbitMQ-HelloWorld/" class="article-date">
  <time datetime="2017-05-29T15:50:13.000Z" itemprop="datePublished">2017-05-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/29/RabbitMQ-HelloWorld/">RabbitMQ的Java客户端（一）</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>RabbitMQ是一个常用的消息队列中间件，它能接收并转发消息。在消息通信模型中，系统可分为三部分：生产者，消息服务器和消费者。简单地说，生产者程序产生消息，发布到消息服务器；消费者程序连接到消息服务器，订阅到队列中。每当消息到达特定等队列时，RabbitMQ会将其发送给其中一个订阅/监听的消费者。<br>在RabbitMQ中，生产者并不是直接将消息交给某个消息队列的，而是将消息发送给交换器，发送时会指定投递的规则，这些规则称为路由键。交换器中最简单等一种就是direct交换器。它是一个以空白字符串为名称等默认交换器。当声明一个队列时，默认绑定到direct交换器。direct交换器的规则非常简单：如果路由键（队列名）匹配的话，消息就被投递到对应等队列。如下图所示</p>
<h2 id="Java客户端"><a href="#Java客户端" class="headerlink" title="Java客户端"></a>Java客户端</h2><p>Java是当今流行的服务器应用程序开发语言。RabbitMQ也提供了Java的客户端SDK。用Java实现direct交换器中的生产者示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">package</span> com.wts.helloworld;</div><div class="line"></div><div class="line"><span class="keyword">import</span> com.rabbitmq.client.Channel;</div><div class="line"><span class="keyword">import</span> com.rabbitmq.client.Connection;</div><div class="line"><span class="keyword">import</span> com.rabbitmq.client.ConnectionFactory;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by weitaosheng on 2017/5/1.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Send</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</div><div class="line">        factory.setHost(<span class="string">"localhost"</span>);</div><div class="line">        Connection connection = factory.newConnection();</div><div class="line">        Channel channel = connection.createChannel();</div><div class="line"></div><div class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</div><div class="line">        String message = <span class="string">"Hello World!"</span>;</div><div class="line">        channel.basicPublish(<span class="string">""</span>, QUEUE_NAME, <span class="keyword">null</span>, message.getBytes());</div><div class="line">        System.out.println(<span class="string">" [x] Sent '"</span> + message + <span class="string">"'"</span>);</div><div class="line"></div><div class="line">        channel.close();</div><div class="line">        connection.close();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建一个消息生产者等步骤：</p>
<ol>
<li>新建连接工厂；</li>
<li>绑定RabbitMQ服务器地址（默认为localhost，端口5672）；</li>
<li>获取连接；</li>
<li>建立频道（channel）；</li>
<li>声明队列；</li>
<li>发布消息。</li>
<li>关闭频道；</li>
<li>关闭连接。</li>
</ol>
<p>客户端示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">import</span> com.rabbitmq.client.*;</div><div class="line"></div><div class="line"><span class="keyword">import</span> java.io.IOException;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Created by weitaosheng on 2017/5/1.</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Recv</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> String QUEUE_NAME = <span class="string">"hello"</span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</div><div class="line">        ConnectionFactory factory = <span class="keyword">new</span> ConnectionFactory();</div><div class="line">        factory.setHost(<span class="string">"localhost"</span>);</div><div class="line">        Connection connection = factory.newConnection();</div><div class="line">        Channel channel = connection.createChannel();</div><div class="line"></div><div class="line">        channel.queueDeclare(QUEUE_NAME, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">null</span>);</div><div class="line">        System.out.println(<span class="string">" [*] Waiting for message. To exit press CTRL+C"</span>);</div><div class="line"></div><div class="line">        Consumer consumer = <span class="keyword">new</span> DefaultConsumer(channel) &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">                String message = <span class="keyword">new</span> String(body, <span class="string">"UTF-8"</span>);</div><div class="line">                System.out.println(<span class="string">" [x] Received '"</span> + message + <span class="string">"'"</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;;</div><div class="line">        channel.basicConsume(QUEUE_NAME, <span class="keyword">true</span>, consumer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>创建客户端并订阅队列的步骤：</p>
<ol>
<li>新建连接工厂；</li>
<li>绑定RabbitMQ服务器地址（默认为localhost，端口5672）；</li>
<li>获取连接；</li>
<li>建立频道（channel）；</li>
<li>声明队列；</li>
<li>声明一个消息消费者，本示例中是用一个匿名内部类来扩展了DefaltConsumer类，并重写了handleDelivery方法，该方法定义了接收到消息时进行等处理。</li>
</ol>
<p>以下是客户端SDK关键的类和方法：<br>ConnectionFactory：连接工厂关键类，是客户端访问RabbitMQ服务器必须要先构造的类。从Connection的源代码可以看出，ConnectionFactory没有显示定义构造函数，因此使用的是编译器自动生成的默认构造函数。<br>获取连接的函数</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> Connection <span class="title">newConnection</span><span class="params">()</span> <span class="keyword">throws</span> IOException, TimeoutException </span>&#123;</div><div class="line">    <span class="keyword">return</span> newConnection(<span class="keyword">this</span>.sharedExecutor, Collections.singletonList(<span class="keyword">new</span> Address(getHost(), getPort())));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>查看源码，sharedExecutor是一个ExecutorService的实例。此处为null，也就是没有使用线程池。连接时还需要地址和端口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function">Channel <span class="title">createChannel</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</div></pre></td></tr></table></figure></p>
<p>createChannel：生成一个Channel类的实例。Connection是一条真实的TCP连接，Channel是Connection内等一条虚拟连接，它在RabbitMQ中会自动生成唯一的ID。通过一条TCP连接内多个虚拟连接的方式，可以提高性能，节约系统资源，因为TCP连接的创建和销毁是非常昂贵的。<br>Queue.DeclareOk queueDeclare(String queue, boolean durable, boolean exclusive, boolean autoDelete,<br>                             Map<string, object=""> arguments) throws IOException;<br>queueDeclare：声明队列。它的几个参数的含义是：队列名，是否持久化，是否是限制性等队列（仅限于此次连接），是否自动删除消息，其他参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">basicPublish</span><span class="params">(String exchange, String routingKey, BasicProperties props, <span class="keyword">byte</span>[] body)</span> <span class="keyword">throws</span> IOException</span>;</div></pre></td></tr></table></figure></string,></p>
<p>basicPublish：发布消息，几个参数是：交换器名，路由键，是否设置了mandatory参数，消息参数，消息体（用byte数组装载）</p>
<p>Consumer是代表消费者等接口，DefaultConsumer是Consumer接口的一个默认实现。一般定义消费者只需扩展这个类即可。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDelivery</span><span class="params">(String consumerTag,</span></span></div><div class="line">                           Envelope envelope,</div><div class="line">                           AMQP.BasicProperties properties,</div><div class="line">                           <span class="keyword">byte</span>[] body)</div></pre></td></tr></table></figure></p>
<p>handleDelivery：消费者接收到消息时的回调方法。它的几个参数是：消费者标签，『信封』信息，消息头内容，消息体</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/05/29/RabbitMQ-HelloWorld/" data-id="cj3b1vxuk0004i8isi9wmfykt" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-kotlin-new-feature-1" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/01/kotlin-new-feature-1/" class="article-date">
  <time datetime="2017-03-01T12:23:47.000Z" itemprop="datePublished">2017-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/01/kotlin-new-feature-1/">Kotlin的新特性（一）：基本类型</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Kotlin是一门新兴的语言，它可以运行于JVM、JavaScript以及native环境（native正在开发中）。它是由著名软件开发商Jetbrains开发，具备了很多新的特性，能够在开发中提升效率。目前已经成为Android官方支持的开发语言。<br>Kotlin语言中的一切类型都是对象，这与Java不同。虽然Java标榜自己是一门纯粹的面向对象的语言，但由于设计的局限，还是保留了一些非面向对象的元素，最明显的就是在Java中，int、float、double、long、char等基本类型不是类，而是原生类型（primitive types）。为了补救这个缺陷，Java开发了对应的包装类型Integer、Float、Double、Long、Chararater等。<br>Kotlin吸收了C#等语言的设计思想，将上述基本类型内置为类，它们具有自己的成员函数和成员属性。这些基本类型包括：数字类型（numbers），字符类型（characters），布尔类型（booleans）和数组类型（arrays）。</p>
<h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><p>Kotlin中的数字类型与Java类似，包括Double、Float、Long、Int、Short、Byte等类型。如上文所述，它们都是类。</p>
<h3 id="字面常量"><a href="#字面常量" class="headerlink" title="字面常量"></a>字面常量</h3><p>Kotlin中的字面常量（literal constants）与Java类似，Int类型支持十进制，直接用普通十进制表示即可；Long类型则需跟上L后缀，如123L表示一个Long型常数，值是123。十六进制加0x前缀，如0x0F表示十六进制数，值是15。二进制加0b前缀，如0b00001011表示二进制数，值是11。Kotlin中不支持八进制数。<br>Kotlin支持通用的浮点数表示法，默认是Double类型，如123.5，123.5e10，如果是Float类型，需要加f或F后缀，如123.5f。</p>
<h3 id="下划线分隔位数"><a href="#下划线分隔位数" class="headerlink" title="下划线分隔位数"></a>下划线分隔位数</h3><p>Kotlin支持在数字常量中使用下划线分隔数位。这能使位数较多的数字具有更强的可读性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> oneMillion = <span class="number">1</span>_000_000 </div><div class="line"><span class="keyword">val</span> creditCardNumber = <span class="number">1234</span>_5678_9012_3456L</div></pre></td></tr></table></figure>
<p>当Kotlin运行于JVM中时，number类型实际上是存储为JVM原生类型，当被赋值给可以为空（nullable）的引用时，Kotlin的number类型是对原生类型的包装。<br>Kotlin中，当使用一个number型常量（val）去初始化一个不可为空的number型常量时，被初始化的常量都指向内存中同一个地址。而当初始化为一个可以为空的常量时，则会在内存中不同地址创建两个常量，并将值赋给它们。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">10000</span> </div><div class="line">print(a === a) <span class="comment">// Prints 'true' </span></div><div class="line"><span class="keyword">val</span> boxedA: <span class="built_in">Int</span> = a </div><div class="line"><span class="keyword">val</span> anotherBoxedA: <span class="built_in">Int</span> = a </div><div class="line">print(boxedA === anotherBoxedA) <span class="comment">// !!!Prints true!!!</span></div><div class="line"></div><div class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">10000</span> </div><div class="line">print(a === a) <span class="comment">// Prints 'true' </span></div><div class="line"><span class="keyword">val</span> boxedA: <span class="built_in">Int</span>? = a </div><div class="line"><span class="keyword">val</span> anotherBoxedA: <span class="built_in">Int</span>? = a </div><div class="line">print(boxedA === anotherBoxedA) <span class="comment">// !!!Prints 'false'!!!</span></div></pre></td></tr></table></figure>
<p>但即使是赋值给可以为空的常量，依然能保证它们的相等性（equality）：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a: <span class="built_in">Int</span> = <span class="number">10000</span> </div><div class="line">print(a == a) <span class="comment">// Prints 'true' </span></div><div class="line"><span class="keyword">val</span> boxedA: <span class="built_in">Int</span>? = a <span class="keyword">val</span> anotherBoxedA: <span class="built_in">Int</span>? = a </div><div class="line">print(boxedA == anotherBoxedA) <span class="comment">// Prints 'true'</span></div></pre></td></tr></table></figure>
<h3 id="宽向扩展"><a href="#宽向扩展" class="headerlink" title="宽向扩展"></a>宽向扩展</h3><p>Kotlin中不存在隐式的宽向类型扩展，即Byte不能直接转换为Int，Int不能直接转换为Double，等等。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> b: <span class="built_in">Byte</span> = <span class="number">1</span> <span class="comment">// OK, literals are checked statically </span></div><div class="line"><span class="keyword">val</span> i: <span class="built_in">Int</span> = b <span class="comment">// ERROR</span></div></pre></td></tr></table></figure>
<p>每种number类型都能通过内置方法任意转换为另一种number类型。</p>
<h2 id="Characters"><a href="#Characters" class="headerlink" title="Characters"></a>Characters</h2><p>字符类型用Char类表示。与Java不同，它不能被直接当做数字类型使用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">fun</span> <span class="title">check</span><span class="params">(c: <span class="type">Char</span>)</span></span> &#123; </div><div class="line">    <span class="keyword">if</span> (c == <span class="number">1</span>) &#123; <span class="comment">// ERROR: incompatible types // ... </span></div><div class="line">    &#125; </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>与Java一样，字符字面量使用单引号表示。转义字符使用反斜杠。特殊字符使用反斜杠加u加十六进制数表示。字符可以通过toInt()方法显式转换为Int。<br>与number一样，字符被赋值给一个nullable引用时，唯一性（identity，内存中地址相同）是不被保证的。</p>
<h2 id="Booleans"><a href="#Booleans" class="headerlink" title="Booleans"></a>Booleans</h2><p>用Boolean代表布尔类型，它有两个值：true和false。</p>
<p>布尔类型被赋值给nullable引用时，会被包装。但能保证唯一性。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> a: <span class="built_in">Boolean</span> = <span class="literal">true</span></div><div class="line">println(a === a) <span class="comment">// Prints 'true'</span></div><div class="line"><span class="keyword">val</span> boxedA: <span class="built_in">Boolean</span>? = a</div><div class="line"><span class="keyword">val</span> anotherBoxedA: <span class="built_in">Boolean</span>? = a</div><div class="line">println(boxedA === anotherBoxedA) <span class="comment">// Prints ‘true’</span></div></pre></td></tr></table></figure>
<h2 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h2><p>在Java中，数组其实也是一种对象，只是我们不能显示地获得它的类型表示。在Kotlin中，用Array类来代表数组。它具有get和set方法（通过[]操作符重载了这两个函数），size属性以及其他有用的函数，如迭代器方法iterator()。</p>
<p>创建数组可以使用arrayOf()方法，并传递数组元素给它作为参数。例如arrayOf(1, 2, 3)就创建了一个数组[1, 2, 3]。arrayOfNulls()函数用于创建一个给定长度的数组，并用null元素填充它。</p>
<p>Kotlin也有特定的类代表原生类型的数组，如ByteArray、ShortArray、IntArray等。这些类与Array没有继承关系，但有对应的方法和属性集合。如IntArray有对应的工厂函数。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> x: IntArray = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>) </div><div class="line">x[<span class="number">0</span>] = x[<span class="number">1</span>] + x[<span class="number">2</span>]</div></pre></td></tr></table></figure>
<p>Strings</p>
<p>字符串用String类表示。与Java一样，String是不可变类。String的元素是字符，与Java中必须使用charAtIndex()这样一个方法去访问元素不同，Kotlin中可以使用下标运算符[]去访问字符元素。String还能使用for循环很方便地访问。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (c <span class="keyword">in</span> str) &#123; </div><div class="line">    println(c) </div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="字符串字面量"><a href="#字符串字面量" class="headerlink" title="字符串字面量"></a>字符串字面量</h3><p>Kotlin有两种字符串字面量：一种是可转义的字符串，它可能含有转义字符，它不能表示在多行，除非使用“+”将不同的字符串连接成一个字符串；另一种是原始（raw）字符串，能在多行表示并能包含任意文本。</p>
<p>转义字符串：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> s = <span class="string">"Hello, world!\n"</span></div></pre></td></tr></table></figure>
<p>原始字符串：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> text = <span class="string">""" </span></div><div class="line">    for (c in "foo") print(c) </div><div class="line">"""</div></pre></td></tr></table></figure>
<p>可以使用trimMargin()移除字符串开头和中间的空格，但空格的末尾必须跟上一个明确的分隔符，默认是“|”。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> text = <span class="string">""" </span></div><div class="line">    |Tell me and I forget. </div><div class="line">    |Teach me and I remember. </div><div class="line">    |Involve me and I learn. </div><div class="line">    |(Benjamin Franklin) """.trimMargin()</div><div class="line"><span class="string">"""</span></div></pre></td></tr></table></figure>
<p>也可以显示指定分隔符，如trimMargin(“&gt;”)</p>
<h3 id="字符串模板"><a href="#字符串模板" class="headerlink" title="字符串模板"></a>字符串模板</h3><p>在Java中，如果我们在字符串中要加入变量，必须使用加号连接，或者使用格式化字符串。而在Kotlin中，可以使用字符串模板，这将使字符串变得更加简洁，看上去也更加舒服。字符串模板以美元符号开头，直接跟上一个变量名。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> i = <span class="number">10</span> </div><div class="line"><span class="keyword">val</span> s = <span class="string">"i = <span class="subst">$i</span>"</span> <span class="comment">// evaluates to "i = 10"</span></div><div class="line"><span class="string">"""</span></div></pre></td></tr></table></figure>
<p>或者是一个用大括号包裹的任意的表达式。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> s = <span class="string">"abc"</span> </div><div class="line"><span class="keyword">val</span> str = <span class="string">"<span class="subst">$s</span>.length is <span class="subst">$&#123;s.length&#125;</span>"</span> <span class="comment">// evaluates to "abc.length is 3"</span></div><div class="line"><span class="string">"""</span></div></pre></td></tr></table></figure>
<p>模板在原始字符串和转义字符串中都支持。如果你在原始字符串中需要表示美元符号的字面值，可以像下面这样使用。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">val</span> price = <span class="string">""" </span></div><div class="line"><span class="subst">$&#123;<span class="string">'$'</span>&#125;</span>9.99 </div><div class="line">"""</div></pre></td></tr></table></figure>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/01/kotlin-new-feature-1/" data-id="cj3b1vxui0002i8isw4kpt6dk" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java-synchronized" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/01/Java-synchronized/" class="article-date">
  <time datetime="2017-03-01T12:23:47.000Z" itemprop="datePublished">2017-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/01/Java-synchronized/">Java中synchronized关键字的研究</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>在Java中，每一个线程都有一个内部锁。当我们使用<strong>synchronized</strong>关键字时，就是利用这个内部锁来实现线程对某个对象的锁定控制。<br>那么，如果某个对象中有两个方法，方法一和方法二都使用了synchronized关键字。如果线程一执行该对象的方法一，线程二执行该对象的方法二。如果线程1一直不释放该对象的内部锁的话，那么线程二应该无法执行该对象的方法二。下面就用代码来验证一下。<br>首先，定义一个Task类<br><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> corejava.chapter14;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TaskC</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            System.out.println(<span class="string">"我是方法1"</span>);</div><div class="line">            Thread.sleep(<span class="number">10000</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</div><div class="line">            System.out.println(<span class="string">"我是方法2"</span>);</div><div class="line">            Thread.sleep(<span class="number">10000</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>method1每隔10秒就会输出一句“我是方法1”。method2每隔10秒就会输出一句“我是方法2”。两个方法都使用了synchronized关键字。  </p>
<p>再定义两个执行类ExecutorC1和Executor2。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> corejava.chapter14;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorC1</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> TaskC taskC;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutorC1</span><span class="params">(TaskC taskC)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.taskC = taskC;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            taskC.method1();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">package</span> corejava.chapter14;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorC2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> TaskC taskC;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutorC2</span><span class="params">(TaskC taskC)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.taskC = taskC;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            taskC.method2();</div><div class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</div><div class="line">            e.printStackTrace();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行对象1和执行对象2都使用同一个taskC去实例化，这样他们之间就会存在竞争。当thread1执行taskC的method1时，会一直持有taskC的内部锁，因此thread2将一直处于阻塞状态。  </p>
<p>下面是运行输出结果<br><img src="/images/synchronized.png" alt="">  </p>
<p>可见，确实如我们所料，虽然两个线程要执行的是不同的方法，但因为线程1一直“霸占”着内部锁，所以线程2始终在阻塞状态，得不到执行。  </p>
<p>所以，如果我们在对某个类要使用synchronized关键字进行锁定控制时，一定要牢记它使用的是该类的内部锁。它是唯一的。当多个方法都用它来进行控制时，一定要考虑这一点。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/01/Java-synchronized/" data-id="cj3b1vxuj0003i8isw35yiag8" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-PushbackInputStream" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/01/PushbackInputStream/" class="article-date">
  <time datetime="2017-02-28T16:59:03.000Z" itemprop="datePublished">2017-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/01/PushbackInputStream/">Java IO 中的PushbackInputStream类</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>PushbackInputstream类是Java IO中的一个较特别的类，因为它可以将读出的字节再推回流中。这也就是它的名字中Pushback的由来。下面首先介绍一下它的基本用法，再分析一下它的源代码。</p>
<h2 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h2><p>首先需要构造一个PushbackInputStream对象，这个对象需要传入一个InputStream实例作为参数。之后从该InputStream绑定的数据源（例如一个文件、或者网络流）读入数据，然后将读出的数据再推回PushBackInputStream中。<br>如下所示</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PushbackInputStreamTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line">        </div><div class="line">        PushbackInputStream inputStream = <span class="keyword">new</span> PushbackInputStream(</div><div class="line">                                                <span class="keyword">new</span> FileInputStream(<span class="string">"input.txt"</span>));</div><div class="line">        <span class="keyword">int</span> data = inputStream.read();</div><div class="line">        System.out.println(data);</div><div class="line">        inputStream.unread(data);</div><div class="line">        data = inputStream.read();</div><div class="line">        System.out.println(data);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>文件中保存着一个字符串abcdefg。输出如下：</p>
<p>Read before push back: 97<br>Read after push back: 97</p>
<p>可见，我们读出了一个字符a（它的ascii码是97），之后又成功推回了流中。</p>
<p>如果我们需要一次推回多个字符，则需要在构造PushbackInputStream实例时传入一个整型参数，用于指定每次推回多最大字节数。<br>如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PushbackInputStreamTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</div><div class="line"></div><div class="line">        PushbackInputStream input = <span class="keyword">new</span> PushbackInputStream(</div><div class="line">                                            <span class="keyword">new</span> FileInputStream(<span class="string">"input.txt"</span>), <span class="number">10</span>);</div><div class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10</span>];</div><div class="line">        <span class="keyword">int</span> r = input.read(bytes);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</div><div class="line">            System.out.println(b);</div><div class="line">        &#125;</div><div class="line">        input.unread(bytes);</div><div class="line">        r = input.read(bytes);</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">byte</span> b : bytes) &#123;</div><div class="line">            System.out.println(b);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出：<br>Read before push back:<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>0<br>0<br>0<br>Read after push back:<br>97<br>98<br>99<br>100<br>101<br>102<br>103<br>0<br>0<br>0</p>
<p>可见，我们可以一次读入最多10个字节（因为数据只有7个字节，所以剩余字节为0.</p>
<p>如果推回多字节大于构造函数中指定的最大字节数，则会发生异常：</p>
<p>java.io.IOException: Push back buffer is full</p>
<p>下面分析一下PushbackInputStream的源代码</p>
<h2 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 缓冲区，被推回的字节将会保存在这里</div><div class="line"> */</div><div class="line"><span class="keyword">protected</span> <span class="keyword">byte</span>[] buf;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 从缓冲区读取数据时的位置，也就是读取被推回的数据时的下标。当缓冲区为空时，pos为buf.length（即没有推回数据，故不能从缓冲区读取）；当缓冲区所有字节均有数据时，则pos为0</div><div class="line"> *</div><div class="line"> */</div><div class="line"><span class="keyword">protected</span> <span class="keyword">int</span> pos;</div></pre></td></tr></table></figure>
<h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 通过指定size的缓冲数组以及一个InputStream实例，来构造一个PushbackInputStream对象</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">PushbackInputStream</span><span class="params">(InputStream in, <span class="keyword">int</span> size)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>(in);</div><div class="line">    <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"size &lt;= 0"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">this</span>.buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</div><div class="line">    <span class="keyword">this</span>.pos = size;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 若不指定缓冲区大小，则默认为1，即每次只能推回一个字节</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">PushbackInputStream</span><span class="params">(InputStream in)</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>(in, <span class="number">1</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 读取数据，若缓冲区有数据，则从缓冲区的pos位置开始读取；若缓冲区无数据，则调用超类的read方法读取数据</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    <span class="comment">// 确保流没有关闭</span></div><div class="line">    ensureOpen();</div><div class="line">    <span class="keyword">if</span> (pos &lt; buf.length) &#123;</div><div class="line">        <span class="keyword">return</span> buf[pos++] &amp; <span class="number">0xff</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.read();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 将数据读入一个byte数组中，参数off是目标数组中的起始偏移量，参数len是读入数据的最大字节数</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    ensureOpen();</div><div class="line">    <span class="comment">// 校验参数是否合法，b不能为null，off不能为负，且读入的最大字节数不能超过数组所能接受的最大字节数。</span></div><div class="line">    <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || len &gt; b.length - off) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// 计算缓冲数组中的数据字节数</span></div><div class="line">    <span class="keyword">int</span> avail = buf.length - pos;</div><div class="line">    <span class="comment">// 从缓冲区中读取数据</span></div><div class="line">    <span class="keyword">if</span> (avail &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (len &lt; avail) &#123;</div><div class="line">            avail = len;</div><div class="line">        &#125;</div><div class="line">        System.arraycopy(buf, pos, b, off, avail);</div><div class="line">        pos += avail;</div><div class="line">        off += avail;</div><div class="line">        len -= avail;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 若要读取的数据数超过了缓冲区的数据数，则读完被推回的数据后，继续从包裹的InputStream中读取数据</span></div><div class="line">    <span class="keyword">if</span> (len &gt; <span class="number">0</span>) &#123;</div><div class="line">        len = <span class="keyword">super</span>.read(b, off, len);</div><div class="line">        <span class="keyword">if</span> (len == -<span class="number">1</span>) &#123;</div><div class="line">            <span class="comment">// 缓冲区无数据，包裹的InputStream也没有数据</span></div><div class="line">            <span class="keyword">return</span> avail == <span class="number">0</span> ? -<span class="number">1</span> : avail;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> avail + len;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> avail;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="推回数据"><a href="#推回数据" class="headerlink" title="推回数据"></a>推回数据</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 推回一个字节数据，即将它拷贝到本类的缓冲数组中</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unread</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    ensureOpen();</div><div class="line">    <span class="comment">// pos为0说明缓冲数组已满</span></div><div class="line">    <span class="keyword">if</span> (pos == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Push back buffer is full"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 从后往前赋值</span></div><div class="line">    buf[--pos] = (<span class="keyword">byte</span>)b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 推回字节数组的一部分到缓冲数组中，</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unread</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</div><div class="line">    ensureOpen();</div><div class="line">    <span class="keyword">if</span> (len &gt; pos) &#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Push back buffer is full"</span>);</div><div class="line">    &#125;</div><div class="line">    pos -= len;</div><div class="line">    System.arraycopy(b, off, buf, pos, len);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上就是这个类的主要方法。我们可以看出，当单个推回数据时，是逆序插入缓冲数组，同时读取数据时，是正序读出。所以是后入先出。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/01/PushbackInputStream/" data-id="cj3b1vxuc0000i8is3paa23ud" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-ArrayList" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/01/ArrayList/" class="article-date">
  <time datetime="2017-02-28T16:59:03.000Z" itemprop="datePublished">2017-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/01/ArrayList/">Java集合中的ArrayList类（一）：构造实例和添加元素</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ArrayList有三个构造器，分别是无参构造器，传入一个整形参数的构造器，以及传入一个Collection实例的构造器。本文主要介绍前两种构造器。</p>
<h2 id="无参构造器"><a href="#无参构造器" class="headerlink" title="无参构造器"></a>无参构造器</h2><p>示例代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayListTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        List&lt;String&gt; strings = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">        strings.add(<span class="string">"abc"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>下面看调用构造器以及添加元素的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 用初始的10的容量大小构造一个空的list</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从上述构造器可以看出，无参构造器只是很简单将常量DEFAULTCAPACITY_EMPTY_ELEMENTDATA赋给成员变量elementData。这个成员变量和常量如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * Shared empty array instance used for default sized empty instances. We</div><div class="line"> * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</div><div class="line"> * first element is added.</div><div class="line"> */</div><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * The array buffer into which the elements of the ArrayList are stored.</div><div class="line"> * The capacity of the ArrayList is the length of this array buffer. Any</div><div class="line"> * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</div><div class="line"> * will be expanded to DEFAULT_CAPACITY when the first element is added.</div><div class="line"> */</div><div class="line"><span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></div></pre></td></tr></table></figure>
<p>从注释可以看出，DEFAULTCAPACITY_EMPTY_ELEMENTDATA是一个空的数组实例，用来作为默认大小的空List。它与EMPTY_ELEMENTDATA同时存在，是为了当第一个元素被添加到list中时，能算出要扩展多大的容量。</p>
<p>elementData是ArrayList中用于实际存储元素的数组。一个ArrayList实例的容量就是这个数组的长度。任何调用了默认构造器生成的ArrayList实例，都执行了elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA，当第一个元素被添加到list中时，都会被扩展到默认的容量大小，即DEFAULT_CAPACITY（10）。</p>
<p>末尾添加元素的函数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* Appends the specified element to the end of this list.</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> e element to be appended to this list</div><div class="line">* <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</div><div class="line">*/</div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</div><div class="line">    ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></div><div class="line">    <span class="comment">// 扩容之后将新增的元素加到末尾，同时将list的size加一。</span></div><div class="line">    elementData[size++] = e;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>该方法首先调用了ensureCapacityInternal函数，用于确保容量足以添加一个元素。ensureCapacityInternal方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123; <span class="comment">// 插入“abc”时，minCapacity为1</span></div><div class="line">    <span class="comment">// 当调用无参构造器时，初始存储元素的数组是DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></div><div class="line">    <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</div><div class="line">        <span class="comment">// 比较参数和默认容量大小，取大者作为扩展多容量</span></div><div class="line">        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); <span class="comment">// minCapacity变为10</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ensureExplicitCapacity(minCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>之后调用了ensureExplicitCapacity函数，继续扩展容量大操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    modCount++;</div><div class="line"></div><div class="line">    <span class="comment">// 检查目标容量是否大于当前数组的实际长度</span></div><div class="line">    <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</div><div class="line">        grow(minCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述方法继续调用grow函数，完成扩容：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Increases the capacity to ensure that it can hold at least the</div><div class="line"> * number of elements specified by the minimum capacity argument.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@param</span> minCapacity the desired minimum capacity</div><div class="line"> */</div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</div><div class="line">    <span class="comment">// overflow-conscious code</span></div><div class="line">    <span class="keyword">int</span> oldCapacity = elementData.length;</div><div class="line">    <span class="comment">// 容量扩充增量为当前数组容量大50%</span></div><div class="line">    <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</div><div class="line">    <span class="comment">// 若扩充后仍达不到目标容量，则直接使用目标容量作为新容量</span></div><div class="line">    <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</div><div class="line">        newCapacity = minCapacity;</div><div class="line">    <span class="comment">// 若超过最大容量，则调用hugeCapacity函数</span></div><div class="line">    <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</div><div class="line">        newCapacity = hugeCapacity(minCapacity);</div><div class="line">    <span class="comment">// 调用工具函数扩容，末尾用null补全</span></div><div class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从注释可知，该方法增长容量以确保list至少能保存传入参数大小数量多元素。之后，就可以插入元素“abc”。插入之后，list的size为1，容量为10.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/01/ArrayList/" data-id="cj3b1vxug0001i8isexm53hzr" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-hello-world" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2017/03/01/hello-world/" class="article-date">
  <time datetime="2017-02-28T16:59:03.000Z" itemprop="datePublished">2017-03-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/03/01/hello-world/">《Java核心技术（英文版）》读书笔记：Object类的equals方法</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Object类是Java中的一个全局超类——每一个Java类都扩展了它。但是你不必显示地如下声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">Object</span></span></div></pre></td></tr></table></figure>
<h2 id="equals方法"><a href="#equals方法" class="headerlink" title="equals方法"></a>equals方法</h2><h3 id="引用同一"><a href="#引用同一" class="headerlink" title="引用同一"></a>引用同一</h3><p>equals方法是Object类中用于判断一个对象和另一个对象是否相等的方法。在Object类中的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (<span class="keyword">this</span> == obj);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从源代码可知，该实现是检查两个对象的引用是否相等，也即是检查两个对象是否指向Java堆中的同一个对象。这是因为，如果两个对象的引用指向同一个Java堆中的对象，则这两个对象必然是相等的。对极少数类的<br>对象来说，这个实现已经足够了。例如两个PrintStream对象。</p>
<h3 id="状态相等"><a href="#状态相等" class="headerlink" title="状态相等"></a>状态相等</h3><p>如上文所述，对大多数类来说，Object中的equals实现是不够用的。因为很多时候，我们认为两个对象相等是基于它们具有相同的状态（即对象的属性，field）。例如，两个Employee对象，如果它们具有相同的姓名（name），<br>工资（salary）和雇佣日期（hire day），那它们就是相等的。它的实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object otherObject)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == otherObject)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        <span class="keyword">if</span> (otherObject == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        <span class="keyword">if</span> (getClass() ！= otherObject.getClass())</div><div class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">        Employee other = (Employee) otherObject;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> name.equals(other.name)</div><div class="line">            &amp;&amp; salary == other.salary;</div><div class="line">            &amp;&amp; hireDay.equals(other.hireDay);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码中，首先判断两个对象是否同一，其次判断被比较对象是否为null，再次比较两个对象所属的类是否相同（在此处，假定必须类相同才有可能相等），最后比较各个状态是否相等。注意如果状态也是对象的话，<br>则会递归调用它们的equals方法。</p>
<p>这里要注意的是，Employee对象的name和hireDay等状态是有可能为null的，为了确保在这种情况下程序也是正确的，可以使用Objects.equals方法。调用Objects.equals(a, b)，若两个参数都是null返回true，<br>若其中一个为null返回false，以上都不成立则调用a.equals(b)。因此，上面方法的最后一条语句可修改为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> Objects.equals(name, other.name)</div><div class="line">    &amp;&amp; salary == other.salary;</div><div class="line">    &amp;&amp; Objects.equals(hireDay, other.hireDay);</div></pre></td></tr></table></figure>
<p>当在扩展类中定义了equals方法时，须首先调用超类的equals方法，如果返回false，则两个对象不可能相等。若返回true，即是超类定义的状态相等。则继续比较子类定义的状态。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2017/03/01/hello-world/" data-id="cj3b1vxul0005i8istbvwr5ta" class="article-share-link">Partager</a>
      
      
    </footer>
  </div>
  
</article>


  

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/05/">May 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Articles récents</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2017/05/29/RabbitMQ-HelloWorld/">RabbitMQ的Java客户端（一）</a>
          </li>
        
          <li>
            <a href="/2017/03/01/kotlin-new-feature-1/">Kotlin的新特性（一）：基本类型</a>
          </li>
        
          <li>
            <a href="/2017/03/01/Java-synchronized/">Java中synchronized关键字的研究</a>
          </li>
        
          <li>
            <a href="/2017/03/01/PushbackInputStream/">Java IO 中的PushbackInputStream类</a>
          </li>
        
          <li>
            <a href="/2017/03/01/ArrayList/">Java集合中的ArrayList类（一）：构造实例和添加元素</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2017 wts<br>
      Propulsé by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>